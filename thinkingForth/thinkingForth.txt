Leo Brodie

THINKING FORTH A Language and Philosophy for Solving Problems Obsahuje rozhovory s vynálezcem jazyka Forth, C HARLESEM H. M OOREM, a dalšími mysliteli Forthu S ilustracemi autora

Leo Brodie se profesionálně zabývá vývojem softwaru od roku 1980, kdy nastoupil do společnosti Forth, Inc. jako technický spisovatel. Pracoval také jako konzultant, autor, vývojář a programový manažer pro společnosti IBM, NCR, Digalog Corp., Microsoft a Real Networks. Je také majitelem společnosti Punch & Brodie productions, která příležitostně poskytuje loutkové postavy pro firemní videa a firemní setkání. Je ženatý a je otcem tří dětí. Je také autorem knihy Starting Forth (Prentice-Hall, 1981).

Není možné oddělit jazyk od vědy nebo vědu od jazyka, protože každá přírodní věda vždy zahrnuje tři věci: sled jevů, na nichž je věda založena, abstraktní pojmy, které tyto jevy vyvolávají, a slova, jimiž jsou tyto pojmy vyjádřeny. K vyvolání pojmu je zapotřebí slovo; k zobrazení jevu je zapotřebí pojem. Všechny tři pojmy odrážejí jednu a tutéž skutečnost. -Antoine Lavoisier, 1789.

PŘEDMLUVA K VYDÁNÍ Z ROKU 2004

Je mi ctí, že dvacet let po původním vydání knihy Myšlení vpřed píši znovu předmluvu. Je potěšující vědět, že koncepty, které jsou zde popsány, jsou stále aktuální i poté, co se na vlnách popularity vystřídalo tolik technologií. Jsou to prostě koncepty dobrého programování, které v průběhu let objevil a znovuobjevil nespočet pracujících vývojářů a kterým dal nový nádech génius jménem Chuck Moore. Nikdy jsem netvrdil, že jsem odborník na srovnávací jazykové studie. Moje nedávná kariéra se soustředila spíše na požadavky a funkční návrh než na vývojové technologie. Ale s ctí napsat další předmluvu k této knize přichází další příležitost vyjádřit svůj názor. V průběhu navrhování internetových aplikací jsem pochytil něco málo z Javy a C#. Dost na to, abych v nich rozpoznal záblesky elegance, kterou Chuck celou dobu prosazoval, ale zatížené bagáží. Nahlédl jsem do některých nedávných knih, které popisují návrhové vzory, s předpokladem, že se budou zabývat opakujícími se návrhy kódu pro reálný jev. Některé vzory to dělají, jako například vzor controller, ale příliš mnoho jiných, jako například vzor factory, řeší problémy, které jsou vytvářeny samotným programovacím jazykem. V předmluvě z roku 1994 jsem se omluvil, že mé odmítnutí objektově orientovaného programování ve vydání z roku 1984 bylo poněkud přehnané. K této omluvě mě vedlo to, že jsem nějakou dobu pracoval s objektově orientovanou variantou jazyka Forth, kterou vyvinul Gary Friedlander pro společnost Digalog Corp. Zjistil jsem, že principy zapouzdření lze elegantně aplikovat na "objekty" jazyka Forth, které jsou odvozeny od tříd, z nichž každá má vlastní implementaci společných metod. Objekty o sobě "věděly" informace, což zjednodušilo kód, který je volal. Stále se však jednalo o pouhé konstrukce jazyka Forth a syntaxe byla stále v jazyce Forth. Nebyla to Java napsaná ve Forthu. Nebylo potřeba garbage collection atd. Nebudu se nyní omlouvat za svou tehdejší omluvu, ale vězte, že jsem se nechtěl zaprodat ve prospěch plnohodnotných objektově orientovaných jazyků.

Předmluva k vydání z roku 2004

v

Někteří lidé si všimli paralel mezi Thinking Forth a Extrémním programováním. Například důraz na iterativní vývoj, inkrementální vylepšování kódu, který "funguje", a neřešení problému nadoraz a podobně. Podle mého názoru však Extrémní programování zřejmě opomíjí důležitý krok v životním cyklu vývoje softwaru: návrh koncepčního modelu. Pokud na projektu pracuje pouze jeden nebo dva vývojáři, není třeba tuto fázi formalizovat, protože dobří vývojáři ji provádějí intuitivně. Ale v projektech, na kterých jsem pracoval a na kterých se podílelo pět a více vývojářů, je klíčová. Konceptuální model definuji jako znázornění toho, jak se zdá, že software funguje. Konceptuální model není jen převyprávění požadavků. Je to výsledek pečlivé analýzy požadavků nejvyšší úrovně a jejich kreativního řešení v návrhu, který bude dávat uživateli smysl. Příkladem může být konstrukce "nákupního košíku" v obchodní aplikaci. Koncepční návrh tvoří základ pro druhou úroveň požadavků a řídí případy užití popisující interakce mezi uživatelem a systémem. Tato druhá úroveň požadavků pak řídí technický návrh a implementaci, neboli to, jak software skutečně funguje. Koncepční model je navrhován společně vedoucím programu, vývojáři a vlastníky podniku. Co jsem četl o extrémním programování, zdá se, že místo toho se předpokládá, že požadavky přímo řídí implementaci. Ve své kariéře jsem tíhl k pozici programového manažera, zastánce koncepčního modelu. Většina vývojářů softwaru, se kterými jsem pracoval, oceňuje mou pozornost věnovanou definování koncepčního modelu předtím, než se zavážu k logickému a technickému návrhu. Ironií při srovnávání Thinking Forth s Extrémním programováním však je, že někteří vývojáři z řad XP (a kteří samozřejmě o této knize nikdy neslyšeli) vůbec nevidí hodnotu specifikace! Ach, dobře. Nechť moudrost, zábava a vyšší dobro září v celé vaší práci.

Leo Brodie

Poděkování za vydání z roku 2004 Obvykle zde autor děkuje těm, kteří se na knize podíleli. V tomto případě je to naopak. Celý tento projekt vymyslela, realizovala a dokončila skupina inspirovaných lidí bez mého podnětu nebo výrazné pomoci. Proto jsem je požádal, aby svůj přínos popsali vlastními slovy:

vi

Předmluva k vydání z roku 2004

John R. Hogerhuis: Kontaktoval jsem Lea Brodieho, abychom projednali podmínky, za kterých by byl ochoten povolit opětovné publikování Thinking Forth v elektronické podobě pod licencí otevřeného obsahu. Získal jsem kopii vydání z roku 1984, odřízl vazbu a naskenoval ji. Pak jsem provedl zkušební verzi a první kapitolu knihy jsem napsal v LyXu. Ukázalo se, že je to mnohem víc práce, než jsem měl čas udělat sám (někdy mám víc ambicí než rozumu, jak dosvědčí moje žena), a tak jsem požádal o pomoc komunitu Forthu na comp.lang.forth. Příliv podpory, založené na lásce k této knize, byl tak obrovský, že jsem zjistil - po rozdělení práce a stanovení základních pravidel (držet se verze z roku 1984, používat LATEX jako jazyk pro sazbu a autorská práva musela být přidělena Leo Brodiemu) - že čím více jsem se držel stranou a vyhýbal se tomu, abych byl úzkým místem, tím rychleji šla práce dohromady. V určitém okamžiku jsem také provedl OCR všech stránek pomocí nástroje Transym OCR (ostatní použili stejný nástroj při přepisu) a provedl jsem vyčištění/vektorizaci obrázků pro třetí kapitolu.

Bernd Paysan: Vytvořil jsem infrastrukturu. Nechal jsem projekt schválit na Sourceforge, nastavil CVS, poštovní konference a přidal vývojáře. Za schválení i přes nekomerční licenci vděčíme Jacobu Moormanovi, který tuto knihu znal ("navzdory omezením použití doporučuji schválit; jedná se o jedinečný a vynikající zdroj informací o Forthu"). Vlastní schválení zpracoval David Burley. Jako guru LATEXu jsem vytvořil většinu stylového souboru a vyčistil většinu příspěvků tak, aby se stylovým souborem fungovaly. Vyčistil jsem obrázky, obnovil polotóny a podle potřeby odstranil rastr. Převedl jsem do LATEXu obrázky, které nebyly nakresleny rukou.∗

Andrew Nicholson: - extrahoval, otočil a převedl naskenované obrázky z první, druhé, sedmé a osmé kapitoly do formátu PNG a přidal obrázky na správná místa. - přepsal druhou kapitolu z OCR do LATEXu - obnovil rejstřík z roku 1984 - revidoval a vyčistil první a pátou kapitolu - vyčistil šestou, sedmou a osmou kapitolu.

∗ Poznámka od Johna: Dodám, že Bernd se opravdu chopil míče a rozběhl se s ním, přičemž použil model vývoje "svobodného softwaru" s působivým účinkem. Důležitou součástí většiny projektů svobodného softwaru je samozřejmě jeden oddaný super vývojář, který razí cestu a odvádí velké procento práce. Tímto člověkem je Bernd.

Poděkování za vydání 2004

vii

Nils Holm: Přepis/prvotní sazba čtvrté kapitoly, sedmé kapitoly a osmé kapitoly

Anton Ertl: Provedl jsem LATEXifikaci (sazbu) a vyčištění třetí kapitoly.

Joseph Knapka: Přepis třetí kapitoly

Josef Gabriel: Přepsal jsem šestou kapitolu. Svůj přínos vidím v tom, že jsem pomohl předat Forth dalším lidem. Doufám, že si lidé přečtou "Thinking Forth" a nechají si změnit svůj kód.

Ed Beroset: Přeložil jsem epilog a dodatky a provedl část kódování v LATEXu.

Albert van der Horst: Přepsal/provedl počáteční sazbu páté kapitoly.

Steve Fisher: Provedl OCR pro sedmou a osmou kapitolu

Všem výše uvedeným jsem hluboce zavázán a poctěn. Leo Brodie Seattle, WA listopad 2004

viii

Předmluva k vydání z roku 2004

PŘEDMLUVA K VYDÁNÍ Z ROKU 1994

Jsem poctěn, že zájmová skupina Forth znovu vydává knihu Thinking Forth. Je potěšující vědět, že kniha může mít hodnotu pro znalce a uživatele jazyka Forth. Toto vydání je reprodukcí původního vydání, pouze s drobnými typografickými opravami. Za deset let od původního vydání knihy se toho hodně událo, takže některé názory jsou zastaralé nebo přinejlepším archaické. "Revidované, aktualizované vydání" by si vyžádalo přepsání mnoha částí, což je větší úsilí, než jaké jsem schopen v současné době vynaložit. Ze všech názorů v knize mě nejvíce mrzí, že jsem je viděl vytištěné, a to kritika objektově orientovaného programování. Od napsání této knihy jsem měl to potěšení napsat aplikaci ve verzi jazyka Forth s podporou objektově orientovaného programování, kterou vyvinula společnost Digalog Corp. z Ventury v Kalifornii. Nejsem žádný odborník, ale je jasné, že tato metodika má co nabídnout. Díky tomu všemu se domnívám, že mnohé myšlenky v knize Thinking Forth jsou dnes stejně platné jako tehdy. Jistě, komentáře Charlese Moora zůstávají výmluvným vhledem do filozofie, která podnítila vývoj Forthu. Chtěl bych poděkovat Marlinu Ouversonovi za jeho vynikající práci, kdy trpělivě bojoval s nekompatibilními formáty souborů a chybami OCR, aby uvedl tento reprint do života.

Předmluva k vydání z roku 1994

ix

PŘEDMLUVA

Programování počítačů může být bláznivé. V jiných profesích si můžete dopřát ten luxus, že vidíte hmatatelný důkaz svého úsilí. Hodinář může sledovat ozubená kolečka, švadlena může sledovat, jak se s každým stehem spojují švy. Ale programátoři navrhují, staví a opravují věci, které si jen představujeme, přízračné mechanismy, které unikají smyslům. Naše práce se neodehrává v operační paměti, ani v editoru, ale v naší vlastní mysli. Budování modelů v mysli je výzvou i radostí programování. Jak bychom se na to měli připravit? Vyzbrojit se lepšími debuggery, dekompilátory a disassemblery? Pomáhají, ale naše nejpodstatnější nástroje a techniky jsou mentální. Potřebujeme důslednou a praktickou metodiku přemýšlení o softwarových problémech. To jsem se pokusil zachytit v této knize. Kniha Thinking Forth je určena všem, kteří se zajímají o psaní softwaru za účelem řešení problémů. Zaměřuje se na návrh a implementaci; rozhodování o tom, čeho chcete dosáhnout, návrh komponent systému a nakonec sestavení programu. Kniha zdůrazňuje důležitost psaní programů, které nejen fungují, ale jsou také čitelné, logické a vyjadřují nejlepší řešení co nejjednoduššími slovy. Přestože většinu zde popsaných principů lze aplikovat na jakýkoli jazyk, představil jsem je v kontextu jazyka Forth. Forth je jazyk, operační systém, sada nástrojů a filozofie. Je ideálním prostředkem pro myšlení, protože odpovídá způsobu, jakým pracuje naše mysl. Myslet ve Forthu znamená myslet jednoduše, myslet elegantně, myslet flexibilně. Není omezující, není komplikované, není příliš obecné. Nemusíte znát Forth, abyste měli z této knihy užitek. Myšlení ve Forthu syntetizuje přístup Forthu s mnoha principy, které učí moderní informatika. Skloubení jednoduchosti Forthu s tradičními disciplínami analýzy a stylu vám poskytne nový a lepší pohled na softwarové problémy a bude užitečné ve všech oblastech počítačových aplikací. Pokud se chcete o Forthu dozvědět více, další moje kniha Starting Forth se zabývá jazykovými aspekty Forthu. V opačném případě se v příloze A této knihy seznámíte se základy jazyka Forth.

Předmluva

xi

Několik slov o uspořádání knihy: Po první kapitole věnované základním pojmům jsem knihu koncipoval podle vzoru cyklu vývoje softwaru; od počáteční specifikace až po implementaci. Přílohy v zadní části obsahují přehled jazyka Forth pro ty, kteří s ním teprve začínají, kód několika popisovaných utilit, odpovědi na problémy a shrnutí stylistických konvencí. Mnoho myšlenek v této knize je nevědeckých. Jsou založeny na subjektivních zkušenostech a pozorování vlastního lidství. Z tohoto důvodu jsem do knihy zařadil rozhovory s různými odborníky na jazyk Forth, z nichž ne všichni se zcela shodují mezi sebou nebo se mnou. Všechny tyto názory se mohou bez předchozího upozornění změnit. Kniha nabízí také návrhy zvané "tipy". Ty je třeba brát pouze tak, jak se vztahují k vaší situaci. Forthovo myšlení neuznává žádná nedotknutelná pravidla. Aby byla zajištěna co nejširší shoda s dostupnými systémy Forth, jsou všechny kódované příklady v této knize v souladu se standardem Forth-83. Jednou z osobností, která výrazně ovlivnila tuto knihu, je muž, který Forth vynalezl, Charles Moore. Kromě toho, že jsem s ním strávil několik dní rozhovory pro tuto knihu, jsem měl tu čest sledovat ho při práci. Je to mistr řemesla, pohybuje se rychle a obratně, jako by fyzicky měnil koncepční modely uvnitř stroje - staví, šťourá, hraje si. Dosahuje toho s minimem nástrojů (výsledek neustálého boje se zákeřnou složitostí) a s minimem jiných omezení než těch, která mu ukládají jeho vlastní techniky. Doufám, že tato kniha zachycuje část jeho moudrosti. Užijte si to!

Poděkování Děkuji všem dobrým lidem, kteří věnovali svůj čas a nápady této knize, mj: Charlesi Moorovi, Dr. Marku Bernsteinovi, Daveu Johnsonovi, Johnu Teleskovi, Dr. Michaelu Starlingovi, Dr. Peteru Koggeovi, Tomu Dowlingovi, Donaldu Burgessovi, Carymu Campbellovi, Dr. Raymondu Dessymu, Michaelu Hamovi a Kim Harrisové. Další z respondentů, Michael LaManna, zemřel v době, kdy tato kniha vznikala. Těm z nás, kteří ho měli rádi, velmi chybí.

JEDNA

Filozofie Forthu

Forth je jazyk a operační systém. Ale to není všechno: je také ztělesněním filozofie. Filosofie není obecně popisována jako něco jiného než Forth. Nepředcházela Forthu, není popisována nikde mimo diskuse o Forthu a nemá ani jiné jméno než "Forth". Co je to za filozofii? Jak ji můžete použít při řešení svých softwarových problémů? Než si na tyto otázky odpovíme, udělejme 100 kroků zpět a prozkoumejme některé z hlavních filozofií, které v průběhu let prosazovali počítačoví vědci. Poté, co budeme sledovat trajektorii těchto pokroků, porovnáme - a porovnáme - filozofii Forth s těmito nejmodernějšími principy programování.

Historie elegance softwaru v křesle V prehistorických dobách programování, kdy počítače byly dinosaury, byl už jen fakt, že nějaký génius dokázal program správně spustit, velkým důvodem k údivu. Jak se počítače stávaly civilizovanějšími, údiv se vytrácel. Management chtěl od programátorů a jejich programů víc. S tím, jak neustále klesaly náklady na hardware, rostly náklady na software. Už nestačilo, aby program běžel správně. Musel být také rychle vyvíjen a snadno udržován. Nový požadavek se začal dělit o pozornost se správností. Chybějící kvalita se nazývala "elegance". V této části nastíníme historii nástrojů a technik pro psaní elegantnějších programů.

Zapamatovatelnost První počítačové programy vypadaly přibližně takto: 00110101 11010011 11011001

2

Filozofie jazyka Forth

Programátoři zadávali tyto programy nastavením řad přepínačů - "zapnuto", pokud byla číslice "1", "vypnuto", pokud byla číslice "0". Tyto hodnoty byly pro počítač "strojovými instrukcemi" a každá z nich způsobila, že počítač provedl nějakou prozaickou operaci, jako například "Přesuň obsah registru B do registru A" nebo "Přidej obsah registru C do obsahu registru A". To se ukázalo jako poněkud únavné. Jelikož je nuda macechou vynálezů, někteří chytří programátoři si uvědomili, že by jim mohl pomoci samotný počítač. Napsali tedy program, který překládal snadno zapamatovatelné zkratky do těžko zapamatovatelných bitových vzorců. Nový jazyk vypadal asi takto: MOV B,A ADD C,A JMC REC1 Překládací program se nazýval assembler, nový jazyk assembler. Každá instrukce "sestavovala" příslušný bitový vzor pro danou instrukci, přičemž mezi instrukcí assembleru a strojovou instrukcí existovala shoda jedna ku jedné. Názvy jsou však pro programátory snáze zapamatovatelné. Proto se novým instrukcím začalo říkat mnemotechnické.

Výkonné programování v jazyce assembleru se vyznačuje korespondencí jedna ku jedné mezi každým příkazem, který programátor zadá, a každým příkazem, který procesor provede. V praxi se programátoři často setkávali s tím, že opakovali stále stejnou sekvenci instrukcí, aby dosáhli stejné věci v různých částech programu. Jak příjemné by bylo mít název, který by reprezentoval každou z těchto běžných sekvencí. Tuto potřebu uspokojil "makroasembler", složitější assembler, který dokázal rozpoznat nejen běžné instrukce, ale také speciální názvy ("makra"). Pro každé jméno asembler maker sestaví pět nebo deset strojových instrukcí, které toto jméno představuje, stejně jako kdyby je programátor napsal celé.

Abstrakce Významným pokrokem byl vynález "jazyka vysoké úrovně". Opět se jednalo o překládací program, ale výkonnější. Vysokoúrovňové jazyky umožnily programátorům psát kód tímto způsobem: X = Y (456/A) - 2, což se velmi podobá algebře. Díky vysokoúrovňovým jazykům mohli začít psát programy i inženýři, nejen bizarní bitoví žolíci. Příkladem vysokoúrovňových jazyků jsou BASIC a FORTRAN.

Power

3

Pak jsem tedy napsal GOTO 500 - a jsem tady!

Vysokoúrovňové jazyky jsou zjevně "výkonnější" než assemblerové jazyky v tom smyslu, že z každé instrukce lze zkompilovat desítky strojových instrukcí. Ještě významnější však je, že vysokoúrovňové jazyky odstraňují lineární korespondenci mezi zdrojovým kódem a výslednými strojovými instrukcemi. Skutečné instrukce závisí na každém celém "příkazu" zdrojového kódu, který je brán jako celek. Operátory jako + a = nemají samy o sobě žádný význam. Jsou pouze součástí složité symboliky, která závisí na syntaxi a umístění operátoru v příkazu. Tato nelineární, na syntaxi závislá korespondence mezi zdrojovým a objektovým kódem je všeobecně považována za neocenitelný krok v pokroku metodologie programování. Jak ale uvidíme, tento přístup nakonec nabízí více omezení než svobody.

Ovladatelnost Většina počítačových programů zahrnuje mnohem více než seznamy instrukcí, které je třeba zpracovat od začátku do konce. Zahrnují také testování různých podmínek a následné "větvení" do příslušných částí kódu v závislosti na výsledku. Zahrnují také opakované "zacyklení" stejných částí kódu, přičemž se obvykle testuje okamžik, kdy je třeba ze smyčky odbočit. Jak assembler, tak vysokoúrovňové jazyky umožňují větvení a smyčkování. V jazycích assembleru se používají "instrukce skoku", v některých vysokoúrovňových jazycích se používají příkazy "GO TO". Když se tyto možnosti používají co nejhrubším způsobem, programy mají tendenci vypadat jako změť, kterou vidíte na obrázku 1.1. Tento přístup, stále hojně používaný v jazycích jako FORTRAN a BASIC, trpí tím, že se obtížně píše a obtížně se mění, pokud je třeba provést opravy. V této "misce špaget" programátorské školy je nemožné otestovat jedinou část kódu nebo zjistit, jak se vykonává něco, co se vykonávat nemá. Potíže se špagetovými programy vedly k objevu "vývojových diagramů". Jednalo se o perokresby znázorňující "tok" provádění kódu, které programátor používal jako pomůcku pro pochopení psaného kódu. Bohužel programátor musel převod z kódu do vývojového diagramu a zpět provádět ručně. Mnoho programátorů považovalo staromódní vývojové diagramy za méně než užitečné.

Modularita Významný pokrok nastal s vynálezem "strukturovaného programování", metodiky založené na pozorování, že velké problémy se snáze řeší, pokud se k nim přistupuje jako k souborům menších problémů [1]. Každá část se nazývá modul. Programy se skládají z modulů v modulech. Strukturované programování eliminuje špagetové kódování tím, že trvá na tom, že tok řízení lze přesměrovat pouze v rámci modulu. Nelze vyskočit z prostředku jednoho modulu doprostřed jiného modulu.

Spravovatelnost

5

Obrázek 1.1: Nestrukturovaný kód používající skoky nebo "GOTO". INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE INSTRUKCE TEST JUMP TEST JUMP Například na obr. 1. 2 ukazuje strukturované schéma modulu "Udělat snídani", který se skládá ze čtyř dílčích modulů. V každém submodulu najdete celou další úroveň složitosti, kterou není třeba na této úrovni zobrazovat. V tomto modulu dochází k větvenému rozhodnutí o volbě mezi modulem "studené cereálie" a modulem "vejce", ale tok řízení zůstává uvnitř vnějšího modulu Strukturované programování má tři předpoklady: 1. Každý program je popsán jako lineární posloupnost samostatných funkcí, kterým se říká moduly. Každý modul má přesně jeden vstupní a jeden výstupní bod. 2. Každý modul se skládá z jedné nebo více funkcí, z nichž každá má přesně jeden vstupní bod a jeden výstupní bod a sama může být popsána jako modul.

6

Filozofie jazyka Forth

Obrázek 1.2: Návrh strukturovaného programu

3. Modul může obsahovat: (a) operace nebo jiné moduly (b) rozhodovací struktury (příkazy IF THEN) (c) smyčkové struktury Myšlenka modulů, které mají "jeden vstup a jeden výstup", spočívá v tom, že je můžete odpojit, změnit jejich vnitřnosti a znovu je zapojit, aniž byste narušili spojení se zbytkem programu. To znamená, že můžete testovat každou část samostatně. To je možné pouze v případě, že přesně víte, na jakém místě stojíte při spuštění modulu a na jakém při jeho opuštění. V modulu "Udělat snídani" buď opravíte cereálie, nebo uděláte vajíčka, ne obojí. A vždy budete uklízet. (Někteří programátoři, které znám, obcházejí tento poslední modul tím, že si každé tři měsíce pronajmou nový byt.) Strukturované programování bylo původně koncipováno jako návrhový přístup. Moduly byly imaginární entity, které existovaly v mysli programátora nebo návrháře, nikoli skutečné jednotky zdrojového kódu. Když se techniky návrhu strukturovaného programování aplikují na nestrukturované jazyky, jako je BASIC, vypadá výsledek nějak jako na obrázku 1.3.

Modularita

7

Obrázek 1.3: Strukturované programování s nestrukturovaným jazykem o 10 INSTRUKCE Rozhodněte se - spěcháte? 20 INSTRUKCE 30 IF H=TRUE THEN GOTO 80 Pokud ano, přejdi na instr.# 80 ) 40 INSTRUKCE 50 INSTRUKCE Make eggs 60 INSTRUKCE 70 GOTO 110 Přejdi na instr.# 110 ) 80 INSTRUKCE 90 INSTRUKCE Make cereal 100 INSTRUKCE ) 110 INSTRUKCE 120 INSTRUKCE Clean up 130 INSTRUKCE

Možnost zápisu K používání strukturovaných programů přispěl ještě jeden průlom: strukturované programovací jazyky. Tyto jazyky obsahují řídicí struktury ve svých sadách příkazů, takže lze psát programy, které mají modulárnější vzhled. Takovým jazykem je Pascal, který vymyslel Niklaus Wirth, aby naučil principy strukturovaného programování své studenty. Obrázek 1.4 ukazuje, jak by tento typ jazyka umožnil napsat program "Make Breakfast". Strukturované programovací jazyky obsahují operátory řídicí struktury, jako jsou IF a THEN, které zajišťují modularitu toku řízení. Jak je vidět, odsazení je důležité pro čitelnost, protože všechny instrukce v rámci

Obrázek 1.4: INSTRUCTION INSTRUCTION IF HURRIED THEN INSTRUCTION INSTRUCTION INSTRUCTION ELSE INSTRUCTION INSTRUCTION INSTRUCTION ENDIF INSTRUCTION INSTRUCTION INSTRUCTION

8

Filozofie jazyka Forth

strukturovaný jazyk. o Rozhodnout - spěcháte? )

Vyrobte si obiloviny

)

Udělejte vajíčka

o

Uklidit

jednotlivé moduly se stále vypisují, místo aby se na ně odkazovalo názvem (např. "MAKE-CEREAL"). Hotový program může mít deset stran, přičemž ELSE je na straně pět.

Navrhování od začátku Jak se postupuje při navrhování těchto modulů? Metodika nazývaná "návrh shora dolů" hlásá, že moduly by se měly navrhovat v pořadí od nejobecnějšího, celkového modulu a postupovat dolů až k detailním modulům. Zastánci návrhu shora dolů byli svědky ostudného plýtvání časem v důsledku nedostatečného plánování. Na základě bolestných zkušeností se naučili, že snažit se opravovat programy po jejich napsání - praxe známá jako "patchování" - je jako zamykat vrata od stodoly, když už kůň utekl. Proto jako protiopatření nabízejí toto oficiální pravidlo programování shora dolů: Nepište žádný kód, dokud nemáte naplánovaný každý detail.

Protože programy lze po napsání jen obtížně měnit, mělo by se podle návrhu shora dolů odhalit jakékoli nedopatření návrhu ve fázi předběžného plánování ještě před napsáním skutečných modulů na úrovni kódu, jinak se může stát, že se promarní člověkoroky úsilí při psaní kódu, který nelze použít.

Podprogramy O "modulech" jsme dosud hovořili pouze jako o abstraktních entitách. Všechny vysokoúrovňové programovací jazyky však obsahují techniky, které umožňují kódovat moduly návrhu jako moduly kódu - diskrétní jednotky, kterým lze přidělit jména a "vyvolat" je jinými částmi kódu. Tyto jednotky se nazývají podprogramy, procedury nebo funkce, v závislosti na konkrétním vysokoúrovňovém jazyce a na způsobu jejich implementace. Předpokládejme, že jako podprogram zapíšeme "MAKE-CEREAL". Mohlo by to vypadat takto: procedure make-cereal get clean bowl open cereal box pour cereal open milk pour milk get spoon end Jako podprogramy můžeme zapsat také "MAKE-EGGS" a "CLEANUP". Na jiném místě můžeme definovat "MAKE-BREAKFAST" jako jednoduchou rutinu, která vyvolá nebo zavolá tyto podprogramy:

Navrhování shora

9

Softwarové záplaty jsou ošklivé a skrývají strukturální nedostatky.

procedura make-breakfast var h: boolean (indikuje uspěchanost) test for uspěchanost if h = true then call make-cereal else call make-eggs end call cleanup end Výraz "call make-cereal" způsobí, že se provede podprogram s názvem "make-cereal". Po dokončení provádění podprogramu se řízení vrátí zpět do volajícího programu v bodě následujícím za voláním. Podprogramy se řídí pravidly strukturovaného programování. Jak vidíte, efekt volání podprogramu je stejný, jako kdyby byl kód podprogramu vypsán celý v rámci volajícího modulu. Ale na rozdíl od kódu vytvořeného makrem assembleru může být podprogram zkompilován jinde v paměti a může se na něj pouze odkazovat. Nemusí být nutně zkompilován v rámci objektového kódu hlavního programu (obrázek 1.5). V průběhu let začali počítačoví vědci stále důrazněji upřednostňovat používání mnoha malých podprogramů před dlouhými souvislými programy. Podprogramy lze psát a testovat nezávisle na sobě. To usnadňuje opakované použití částí dříve napsaných programů a zadávání různých částí programu různým programátorům. Nad menšími částmi kódu se lépe přemýšlí a snadněji se ověřuje jejich správnost. Obrázek 1.5: Hlavní program a podprogram v paměti.

Podprogramy

11

Pokud jsou podprogramy zkompilovány v oddělených částech paměti a je na ně odkazováno, můžete v průběhu programu mnohokrát vyvolat stejný podprogram, aniž byste plýtvali místem na opakovaný objektový kód. Rozumné používání podprogramů tak může také snížit velikost programu. Při použití podprogramu bohužel dochází k penalizaci rychlosti provádění. Jedním z problémů je režie spojená s ukládáním registrů před skokem do podprogramu a jejich následným obnovením. Ještě větší časovou náročnost představuje neviditelný, ale významný kód potřebný k předávání parametrů do podprogramu a z něj. Podprogramy jsou také náročné na způsob jejich vyvolání a zejména na způsob předávání dat do nich a z nich. Chcete-li je testovat samostatně, musíte napsat speciální testovací program, ze kterého je budete volat. Z těchto důvodů informatici doporučují jejich používání s mírou. V praxi jsou podprogramy obvykle poměrně rozsáhlé v délce mezi půl až celou stránkou zdrojového kódu.

Postupné zpřesňování Přístup, který se na podprogramy ve velké míře spoléhá, se nazývá "postupné zpřesňování" [2]. Myšlenka spočívá v tom, že začnete psát kostrovou verzi programu s použitím přirozených názvů procedur pro datové struktury. Poté napíšete verze jednotlivých pojmenovaných procedur. V tomto procesu pokračujete do vyšších úrovní detailů, dokud procedury nelze napsat pouze v samotném počítačovém jazyce. V každém kroku musí programátor učinit rozhodnutí o použitých algoritmech a o datových strukturách, na které se použijí. Rozhodnutí o algoritmech a souvisejících datových strukturách by měla být činěna paralelně. Pokud se nějaký přístup neosvědčí, je programátor vyzván, aby se vrátil zpět, jak daleko je to nutné, a začal znovu. Všimněte si, že jde o postupné zpřesňování: Žádnou část programu nemůžete ve skutečnosti spustit, dokud nejsou napsány jeho součásti nejnižší úrovně. Obvykle to znamená, že program nemůžete otestovat, dokud jej kompletně nenavrhnete. Všimněte si také: Postupné zdokonalování vás nutí propracovat všechny detaily řídicí struktury na každé úrovni, než přejdete na další nižší úroveň.

Strukturovaný návrh V polovině konce 70. let už počítačový průmysl vyzkoušel všechny koncepty, které jsme popsali, a stále byl nešťastný. Náklady na údržbu softwaru - udržení jeho funkčnosti tváří v tvář změnám - tvořily více než polovinu celkových nákladů na software, podle některých odhadů až devadesát procent! Všichni se shodli na tom, že tato zvěrstva lze obvykle vysledovat z neúplné analýzy programu nebo špatně promyšlených návrhů. Ne že by na strukturovaném programování jako takovém bylo něco špatného. Když přišly projekty pozdě, neúplné nebo chybné, vzali na sebe vinu návrháři, protože nepředvídali nepředvídatelné.

12

Filozofie jazyka Forth

Tobiasi, myslím, že jsi postupné zdokonalování tohoto modulu dovedl dost daleko.

Učenci přirozeně reagovali tím, že kladli větší důraz na design. "Příště si to lépe promyslíme". Zhruba v té době vznikla nová filozofie, popsaná v článku nazvaném "Strukturovaný design" [3]. Jeden z jejích principů je uveden v tomto odstavci: Jednoduchost je hlavním měřítkem doporučeným pro hodnocení alternativních návrhů ve vztahu ke zkrácení doby ladění a úprav. Jednoduchost lze zvýšit rozdělením systému na jednotlivé části takovým způsobem, aby bylo možné jednotlivé části zvažovat, implementovat, opravovat a měnit s minimálním ohledem nebo vlivem na ostatní části systému.

Rozdělením problému na jednoduché moduly se očekávalo, že programy se budou snadněji psát, snadněji měnit a budou srozumitelnější. Co je to však modul a na základě čeho se toto dělení provádí? "Strukturovaný návrh" uvádí tři faktory pro navrhování modulů.

Funkční síla Jedním z faktorů je něco, čemu se říká "funkční síla", což je míra jednotnosti účelu všech příkazů v rámci modulu. Pokud lze všechny příkazy uvnitř modulu společně považovat za příkazy plnící jeden úkol, jsou funkčně vázané. Zda jsou příkazy v modulu funkčně vázané, lze obecně zjistit položením následujících otázek. Zaprvé, dokážete jednou větou popsat jeho účel? Pokud ne, modul pravděpodobně není funkčně vázaný. Dále si o modulu položte tyto čtyři otázky: 1. Musí být popis složenou větou? 2. Jsou v něm použita slova zahrnující čas, jako například "nejprve", "dále", "pak" atd. 3. Používá za slovesem obecný nebo nespecifický předmět? 4. Používá slova jako "inicializovat", která naznačují, že se provádí mnoho různých funkcí najednou? Pokud je odpověď na některou z těchto čtyř otázek "ano", jedná se o nějaký méně soudržný typ vazby, než je funkční vazba. Mezi slabší formy vazby patří např: Koincidenční vazba: (příkazy se prostě náhodou objevují ve stejném modulu) Logická vazba: (modul má několik souvisejících funkcí a vyžaduje příznak nebo parametr, který rozhoduje o tom, která konkrétní funkce se má provést) Časová vazba: (modul obsahuje skupinu příkazů, které se odehrávají ve stejnou dobu, například inicializace, ale nemají žádný jiný vztah) Komunikační vazba: (modul obsahuje skupinu příkazů, které se všechny vztahují ke stejné množině dat)

14

Filozofie jazyka Forth

Sekvenční vazba: (Náš modul "MAKE-CEREAL" vykazuje funkční vazbu, protože jej lze považovat za modul, který dělá jednu věc, i když se skládá z několika podřízených úloh.

Vazba Druhý princip strukturovaného návrhu se týká "vazby", což je měřítko toho, jak moduly ovlivňují chování jiných modulů. Silná vazba je považována za špatnou formu. Nejhorší případ je, když jeden modul skutečně modifikuje kód uvnitř jiného modulu. Nebezpečné je i předávání řídicích příznaků jiným modulům s úmyslem řídit jejich funkci. Přijatelnou formou vazby je "datová vazba", která zahrnuje předávání dat (nikoli řídicích informací) z jednoho modulu do druhého. I v tomto případě se systémy nejsnáze vytvářejí a udržují, pokud jsou datová rozhraní mezi moduly co nejjednodušší. Pokud k datům může přistupovat mnoho modulů (například globální proměnné), je vazba mezi moduly silnější. Pokud programátor potřebuje změnit jeden modul, je větší nebezpečí, že ostatní moduly budou vykazovat "vedlejší účinky". Nejbezpečnějším druhem datové vazby je předávání lokálních proměnných jako parametrů z jednoho modulu do druhého. Volající modul podřízenému modulu v podstatě říká: "Chci, abys použil data, která jsem vložil do těchto proměnných s názvy X a Y, a až skončíš, očekávám, že odpověď vložíš do proměnné s názvem Z. Nikdo jiný tyto proměnné používat nebude." Modul, který je volá, je tedy v podstatě "podřízený". Jak jsme si řekli, konvenční jazyky, které podporují podprogramy, obsahují propracované metody předávání argumentů z jednoho modulu do druhého.

Hierarchické navrhování vstupů, procesů a výstupů Třetí zásada strukturovaného návrhu se týká procesu návrhu. Návrhářům se doporučuje používat přístup shora dolů, ale zpočátku věnovat méně pozornosti řídicím strukturám. "Rozhodovací navrhování" může počkat až na pozdější, podrobný návrh modulů. Místo toho by se měl počáteční návrh zaměřit na hierarchii programu (které moduly volají které moduly) a na předávání dat z jednoho modulu do druhého. Aby se návrhářům usnadnilo uvažování v tomto novém směru, bylo vynalezeno grafické znázornění, které se nazývá "strukturní diagram". (Mírně odlišná forma se nazývá "HIPO diagram", což je zkratka pro "hierarchický vstup-proces-výstup"). Strukturní grafy obsahují dvě části, hierarchický graf a vstupně-výstupní graf. Obrázek 1.6 ukazuje tyto dvě části. Hlavní program, nazvaný DOIT, se skládá ze tří podřízených modulů, které zase vyvolávají další moduly zobrazené pod nimi. Jak je vidět, návrh klade důraz na transformaci vstupu na výstup.

Spojení

15

Obrázek 1.6: Podoba strukturovaného diagramu, z knihy "Structured Design", IBM Systems Journal. DOIT 5

6 ...

7

...

... TRANSFORMACE DO D

GETC 3

8

4

TRANSFORMACE DO C

GETB 1

PUTD 9

TRANSFORMOVAT DO E

PUTE 10

2

. . .

11 . . .

TRANSFORMACE DO B

TRANSFORMACE NA F

ČTENÍ

ZÁPIS 1 2 3 4 5 6 7 8 9 10 11

A B C D D E E F

OUT A B B C C D E F

Malá čísla hierarchického grafu odkazují na řádky na grafu in-out. V bodě 1 (modul READ) je výstupem hodnota A. V bodě 2 (modul TRANSFORM-TO-B) je vstupem A a výstupem B. Snad největším přínosem tohoto přístupu je poznání, že rozhodnutí o toku řízení by nemělo dominovat vznikajícímu návrhu. Jak uvidíme, tok řízení je povrchním aspektem problému. Drobné změny v požadavcích mohou zásadně změnit řídicí struktury programu a "hluboce pošramotit" roky práce. Pokud jsou však programy navrženy s ohledem na jiné problémy, například tok dat, pak změna plánu nebude mít tak katastrofální dopad.

Skrývání informací V článku [4] publikovaném již v roce 1972 Dr. David L. Parnas ukázal, že kritériem pro rozklad modulů by neměly být kroky v procesu, ale spíše části informací, které se mohou případně změnit. Moduly by měly sloužit ke skrytí takových informací.

16

Filozofie jazyka Forth

Podívejme se na tuto důležitou myšlenku "skrývání informací": Předpokládejme, že píšete příručku postupů pro vaši společnost. Zde je její část: Jay zaeviduje oranžovou kopii do červeného pořadače na svém stole a vyplní balicí list.

Všichni se shodnou na tom, že tento postup je správný, a vaše příručka se rozešle všem zaměstnancům společnosti. Pak Jay skončí a jeho místo převezme Marilyn. Nové duplikáty formulářů mají zelené a žluté listy, nikoli modré a oranžové. Červený pořadač se zaplní a nahradí se černým. Celá vaše příručka je zastaralá. Zastaralosti jste se mohli vyhnout tím, že byste místo jména "Jay" použili termín "pracovník expedice", místo "modrý" a "oranžový" termíny "kopie z oddělení účetnictví" a "kopie z oddělení expedice" atd. Tento příklad ilustruje, že v zájmu zachování správnosti tváří v tvář měnícímu se prostředí by měly být z postupů vyloučeny libovolné detaily. Podrobnosti lze v případě potřeby zaznamenat jinde. Například personální oddělení by mohlo přibližně každý týden vydat seznam zaměstnanců a jejich pracovních pozic, takže každý, kdo by potřeboval vědět, kdo je pracovník expedice, by si to mohl vyhledat v tomto jediném zdroji. S tím, jak by se měnil personál, by se tento seznam měnil. Tato technika je velmi důležitá při psaní softwaru. Proč by se měl program vůbec měnit, když už jednou běží? Z milionu důvodů. Můžete chtít spustit starý program na novém zařízení; program musí být změněn právě tak, aby se přizpůsobil novému hardwaru. Program nemusí být dostatečně rychlý nebo výkonný, aby vyhovoval lidem, kteří ho používají. Většina softwarových skupin se ocitá v situaci, kdy píše "rodiny" programů; to znamená mnoho verzí příbuzných programů v určité oblasti použití, z nichž každá je variantou staršího programu. Aby bylo možné aplikovat princip skrývání informací na software, měly by být určité detaily programu omezeny na jediné místo a každá užitečná informace by měla být vyjádřena pouze jednou. Programy, které tuto zásadu ignorují, se dopouštějí redundance. Zatímco hardwarová redundance (záložní počítače atd.) může zvýšit bezpečnost systému, redundance informací je nebezpečná. Jak vám řekne každý zkušený programátor, číslo, které se může v budoucích verzích programu pravděpodobně změnit, by mělo být vytvořeno jako "konstanta" a v celém programu by se na něj mělo odkazovat jménem, nikoli hodnotou. Například počet sloupců představující šířku papírových formulářů v počítači by měl být vyjádřen jako konstanta. I assemblerové jazyky poskytují "EQU" a značky pro přiřazení hodnot, jako jsou adresy a bitové vzory, ke jménům. Každý dobrý programátor také při vývoji podprogramů uplatní koncept skrývání informací, který zajistí, aby každý modul věděl co nejméně

Skrývání informací

17

možné o vnitřnostech ostatních modulů. Současné programovací jazyky, jako jsou C, Modula 2 a Edison, uplatňují tento koncept v architektuře svých procedur. Parnas však tuto myšlenku posouvá mnohem dále. Navrhuje, aby byl tento koncept rozšířen na algoritmy a datové struktury. Skrývání informací - nikoliv rozhodovací struktura nebo hierarchie volání - by vlastně mělo být hlavním základem návrhu!

Povrchnost struktury Parnas navrhuje dvě kritéria dekompozice: 1. možné (i když v současnosti neplánované) opakované použití a 2. možné (i když neplánované) změny.

Tento nový pohled na "modul" je jiný než tradiční pohled. Tento "modul" je soubor rutin, obvykle velmi malých, které společně skrývají informace o některém aspektu problému. Dva další autoři popisují stejnou myšlenku jiným způsobem a používají termín "datová abstrakce" [5]. Jejich příkladem je zásobník push-down. "Modul" zásobníku se skládá z rutin pro inicializaci zásobníku, odeslání hodnoty na zásobník, vyskočení hodnoty ze zásobníku a určení, zda je zásobník prázdný. Tento "víceprocedurní modul" skrývá informace o tom, jak je zásobník konstruován, před zbytkem aplikace. Procedury jsou považovány za jeden modul, protože jsou na sobě vzájemně závislé. Nelze změnit metodu pro vysunutí hodnoty, aniž by se zároveň změnila metoda pro vysunutí hodnoty. Důležitou roli v tomto pojetí hraje slovo uses. Parnas o tom píše v pozdějším článku [6]: Systémy, které dosáhly určité "elegance". . toho dosáhly tím, že části systému používají jiné části. . . Pokud takové hierarchické uspořádání existuje, pak každá úroveň nabízí testovatelnou a použitelnou podmnožinu systému. . . Návrh hierarchie "použití" by měl být jedním z hlavních milníků při návrhu. Rozdělení systému na nezávisle volatelné podprogramy musí probíhat souběžně s rozhodováním o užitích, protože se navzájem ovlivňují.

Návrh, v němž jsou moduly seskupeny podle toku řízení nebo posloupnosti, neumožní snadno provádět změny návrhu. Struktura ve smyslu nebo hierarchie toku řízení je povrchní. Návrh, v němž jsou moduly seskupeny podle věcí, které se mohou měnit, může snadno umožnit změny.

18

Filozofie jazyka Forth

Ohlédnutí zpět a Forth V této části si projdeme základní vlastnosti jazyka Forth a dáme je do souvislosti s tím, co jsme viděli o tradičních metodikách. Zde je příklad kódu jazyka Forth; : SNÍDANĚ HURÁ?

IF

CEREAL

ELSE

EGGS

POTOM ČISTÝ ;

Tento postup je strukturálně shodný s postupem MAKE-BREAKFAST na straně 8. (Pokud jste ve Forthu nováčci, podívejte se na vysvětlení v příloze A.) Slova HURRIED?, CEREAL, EGGS a CLEAN jsou (s největší pravděpodobností) také definována jako definice dvojtečky. Až do určitého bodu vykazuje Forth všechny vlastnosti, které jsme studovali: mnemotechnickou hodnotu, abstrakci, výkon, strukturované řídicí operátory, silnou funkční vazbu, omezenou vazbu a modularitu. Co se však týče modularity, setkáváme se s něčím, co může být nejvýznamnějším průlomem jazyka Forth: Nejmenší atom programu Forth není modul, podprogram nebo procedura, ale "slovo".

Navíc neexistují žádné podprogramy, hlavní programy, utility nebo exekutivy, z nichž každá musí být vyvolána jinak. Všechno ve Forthu je slovo. Než se budeme zabývat významem prostředí založeného na slovech, prostudujme si nejprve dva vynálezy jazyka Forth, které to umožňují.

Implicitní volání Za prvé, volání jsou implicitní. Nemusíte říkat CALL CEREAL, stačí říct CEREAL. Ve Forthu definice CEREAL "ví", o jaký druh slova se jedná a jakou proceduru má použít pro své vyvolání. Proměnné a konstanty, systémové funkce, utility, stejně jako libovolné uživatelsky definované příkazy nebo datové struktury lze tedy "volat" jednoduše jménem.

Implicitní předávání dat Za druhé, předávání dat je implicitní. Mechanismus, který tento efekt vytváří, je datový zásobník jazyka Forth. Jazyk Forth na něj automaticky vkládá čísla; slova, která vyžadují čísla jako vstup, je automaticky ze zásobníku vybírají; slova, která vytvářejí čísla jako výstup, je automaticky na zásobník vkládají. Slova PUSH a POP ve vysokoúrovňovém jazyce Forth neexistují. Můžeme tedy napsat: : DOIT GETC

TRANSFORM-TO-D PUT-D ;

s jistotou, že GETC získá "C" a ponechá ho na zásobníku. TRANSFORM-TO-D vyzvedne "C" ze zásobníku, transformuje ho a ponechá "D" na zásobníku. Nakonec,

Pohled zpět a vpřed

19

PUT-D vyzvedne "D" ze zásobníku a zapíše ho. Forth z našeho kódu eliminuje akt předávání dat a ponechává nám možnost soustředit se na funkční kroky transformace dat. Protože jazyk Forth používá pro předávání dat zásobník, mohou se slova vnořovat do slov. Každé slovo může na zásobník vkládat čísla a odebírat je z něj, aniž by narušilo f1ow dat mezi slovy na vyšší úrovni (samozřejmě za předpokladu, že slovo nespotřebuje nebo nezanechá neočekávané hodnoty). Zásobník tak podporuje strukturované, modulární programování a zároveň poskytuje jednoduchý mechanismus pro předávání lokálních argumentů. Forth z našich programů odstraňuje detaily toho, jak jsou slova vyvolávána a jak jsou předávána data. Co zůstává? Pouze slova, která popisují náš problém. Máme-li slova, můžeme plně využít Parnasova doporučení - rozložit problémy podle věcí, které se mohou měnit, a nechat každý "modul" sestávat z mnoha malých funkcí, tolika, kolik je potřeba k ukrytí informací o daném modulu. Ve Forthu můžeme napsat tolik slov, kolik k tomu potřebujeme, bez ohledu na to, jak jednoduché každé z nich může být. Řádek z typické aplikace Forth by mohl znít: 20 ROTATE LEFT TURRET Málokterý jiný jazyk by vás vybízel k vymýšlení podprogramu s názvem LEFT, který by sloužil pouze jako modifikátor, nebo podprogramu s názvem TURRET, který by sloužil pouze k pojmenování části hardwaru. Protože slovo jazyka Forth se vyvolává snadněji než podprogram (už jen tím, že je pojmenováno, nikoliv tím, že je voláno), je pravděpodobné, že program jazyka Forth bude rozložen na více slov než běžný program na podprogramy.

Komponentní programování Větší množina jednodušších slov usnadňuje použití techniky, kterou budeme nazývat "komponentní programování". Abychom to vysvětlili, nejprve si znovu probereme ony kolekce, které jsme nejasně popsali jako "věci, které se mohou měnit". V typickém systému se může změnit téměř vše: Změny se týkají vstupně-výstupních zařízení, jako jsou terminály a tiskárny, rozhraní, jako jsou čipy UART, operačního systému, jakékoli datové struktury nebo reprezentace dat, jakéhokoli algoritmu atd. Otázka zní: "Jak můžeme minimalizovat dopad každé takové změny? Jaká je nejmenší množina dalších věcí, které se musí změnit spolu s takovou změnou?". Odpověď zní: "Nejmenší množina vzájemně se ovlivňujících datových struktur a algoritmů, které sdílejí znalosti o tom, jak společně fungují.". Této jednotce budeme říkat "komponenta". Komponenta je zdroj. Může to být kus hardwaru, například UART nebo hardwarový zásobník. Nebo může být komponentou softwarový prostředek, například fronta, slovník nebo softwarový zásobník.

20

Filozofie jazyka Forth

Obrázek 1.7: Strukturovaný návrh vs. návrh komponent.

Všechny komponenty zahrnují datové objekty a algoritmy. Nezáleží na tom, zda je datový objekt fyzický (například hardwarový registr), nebo abstraktní (například místo v zásobníku nebo pole v databázi). Nezáleží na tom, zda je algoritmus popsán ve strojovém kódu nebo v problémově orientovaných slovech, jako jsou CEREAL a EGGS. Na obrázku 1.7 jsou porovnány výsledky strukturovaného návrhu s výsledky návrhu pomocí komponent. Místo modulů nazvaných READ-RECORD, EDIT-RECORD a WRITE-RECORD se zabýváme komponentami, které popisují strukturu záznamů, poskytují sadu příkazů editoru a zajišťují rutiny pro čtení/zápis do úložiště. Co jsme udělali? Do procesu vývoje jsme vložili novou fázi: V našem návrhu jsme provedli dekompozici podle komponent, poté jsme popsali posloupnost, hierarchii a vstupy-procesy-výstupy v naší implementaci. Ano, je to krok navíc, ale nyní máme další rozměr dekompozice - nejen krájení, ale i kostičkování.

Programování komponent

21

Obrázek 1.8: Lexikon popisuje komponentu.

Předpokládejme, že po napsání programu potřebujeme změnit strukturu záznamu. V sekvenčním, hierarchickém návrhu by tato změna ovlivnila všechny tři moduly. V návrhu podle komponent by se změna omezila na komponentu struktury záznamů. Žádný kód, který tuto komponentu používá, se o změně nemusí dozvědět. Kromě údržby je výhodou tohoto schématu to, že programátoři v týmu mohou mít komponenty přiděleny individuálně, s menší vzájemnou závislostí. Princip komponentového programování platí jak pro řízení týmu, tak pro návrh softwaru. Soubor slov, která popisují komponentu, budeme nazývat "lexikon". (Jeden z významů lexikonu je "soubor slov vztahujících se k určité oblasti zájmu"). Lexikon je vaším rozhraním s komponentou zvenčí (obrázek 1.8). V této knize se termín "lexikon" vztahuje pouze na ta slova komponenty, která se používají podle názvu mimo komponentu. Komponenta může také obsahovat definice napsané výhradně pro podporu lexikonu viditelného zvenčí. Podpůrným definicím budeme říkat "vnitřní" slova. Lexikon poskytuje logické ekvivalenty datových objektů a algoritmů ve formě jmen. Lexikon zahaluje datové struktury a algoritmy komponenty - to, "jak to funguje". Představuje světu pouze "konceptuální model" komponenty popsaný jednoduchými slovy - "co to dělá". Tato slova se pak stávají jazykem pro popis datových struktur a algoritmů komponent napsaných na vyšší úrovni. "Co" jedné komponenty se stává "jak" komponenty vyšší. Celá aplikace napsaná v jazyce Forth se skládá pouze z komponent. Obrázek 1.9 ukazuje, jak by mohla být rozložena robotická aplikace. Dalo by se dokonce říci, že každý lexikon je speciální překladač napsaný výhradně za účelem co nejefektivnější a nejspolehlivější podpory kódu aplikace vyšší úrovně.

22

Filozofie jazyka Forth

Obrázek 1.9: Celá aplikace se skládá z komponent.

Mimochodem, samotný jazyk Forth komponenty nepodporuje. Ani to nepotřebuje. Komponenty jsou produktem dekompozice návrháře programu. (Forth však má "obrazovky" - malé jednotky hromadného úložiště pro ukládání zdrojového kódu. Komponentu lze obvykle napsat v jedné nebo dvou obrazovkách jazyka Forth). Je důležité si uvědomit, že lexikon může být používán všemi komponentami na vyšších úrovních. Každá následující komponenta nepohřbívá své podpůrné komponenty, jak tomu často bývá u vrstevnatých přístupů k návrhu. Místo toho může každý lexikon volně používat všechny příkazy pod ním. Příkaz robotmovement se spoléhá na kořenový jazyk s jeho proměnnými, konstantami, operátory zásobníku, matematickými operátory atd. stejně silně jako kterákoli jiná komponenta. Důležitým výsledkem tohoto přístupu je, že celá aplikace používá jedinou syntaxi, což usnadňuje její učení a údržbu. Proto používám termín "lexikon", a ne "jazyk". Jazyky mají jedinečné syntaxe.

Programování komponent

23

Tato dostupnost příkazů také výrazně usnadňuje proces testování a ladění. Protože jazyk Forth je interaktivní, může programátor zadávat a testovat primitivní příkazy, jako je RIGHT SHOULDER 20 PIVOT "zvenčí", stejně snadno jako ty mocnější, jako je LIFT COFFEE-POT Současně může (pokud chce) záměrně zapečetit jakékoli příkazy, včetně samotného jazyka Forth, aby k nim po dokončení aplikace neměl přístup koncový uživatel. Nyní je metodika Forthu jasná. Programování ve Forthu spočívá v rozšiřování kořenového jazyka směrem k aplikaci a v poskytování nových příkazů, které lze použít k popisu daného problému. Programovací jazyky určené speciálně pro konkrétní aplikace, jako je robotika, řízení zásob, statistika atd. se nazývají "aplikačně orientované jazyky". Forth je programovací prostředí pro tvorbu aplikačně orientovaných jazyků. (Poslední věta je možná nejstručnějším popisem jazyka Forth, který najdete.) Ve skutečnosti byste ve Forthu neměli psát žádnou seriózní aplikaci; jako jazyk prostě není dostatečně výkonný. Co byste měli udělat, je napsat si ve Forthu vlastní jazyk (lexikony), v němž budete modelovat své chápání problému a v němž budete moci elegantně popsat jeho řešení.

Skrýt se před kým? Protože moderní mainstreamové jazyky dávají slovnímu spojení "skrývání informací" poněkud jiný význam, měli bychom si to ujasnit. Před čím nebo před kým skrýváme informace? Nejnovější tradiční jazyky (například Modula 2) se ohýbají, aby zajistily, že moduly skryjí vnitřní rutiny a datové struktury před ostatními moduly. Cílem je dosáhnout nezávislosti modulů (minimální provázanosti). Zdá se, že panuje obava, že moduly se snaží napadat navzájem jako mimozemské protilátky. Nebo jinak, že zlé bandy záškodnických modulů chtějí zlikvidovat vzácné rodinné datové struktury. Toho se však neobáváme. Účelem skrývání informací, jak ho máme na mysli, je jednoduše minimalizovat dopady případné změny návrhu lokalizací věcí, které by se mohly změnit v rámci jednotlivých komponent. Programátoři jazyka Forth obecně dávají přednost tomu, aby měli program pod vlastní kontrolou a nepoužívali žádné techniky fyzického skrývání datových struktur. (Nicméně brilantně jednoduchou techniku pro přidávání modulů typu Modula do jazyka Forth implementoval Dewey Val Shorre [7], a to v pouhých třech řádcích kódu).

24

Filozofie jazyka Forth

Skrytí konstrukce datových struktur Všimli jsme si dvou vynálezů jazyka Forth, které umožňují námi popsanou metodiku - implicitní volání a implicitní předávání dat. Třetí vlastnost umožňuje popsat datové struktury v rámci komponenty z hlediska dříve definovaných komponent. Touto vlastností je přímý přístup k paměti. Předpokládejme, že definujeme proměnnou s názvem APPLES takto: Do této proměnné můžeme uložit číslo, které udává, kolik jablek právě máme: 20 JABLEK ! Obsah proměnné můžeme zobrazit: APPLES ? 20 ok Můžeme zvýšit počet jablek o jedna: 1 APPLES +! (Mechaniku těchto výrazů si nováček může prostudovat v příloze A.) Slovo APPLES má jedinou funkci: umístit na zásobník adresu paměťového místa, kde se uchovává počet jablek. Na sčítání lze pohlížet jako na "věc", zatímco slova, která sčítání nastavují, čtou nebo inkrementují, lze považovat za "akce". Jazyk Forth vhodně odděluje "věci" od "akcí" tím, že umožňuje předávat adresy datových struktur na zásobníku a poskytuje příkazy "fetch" a "store". Probrali jsme důležitost návrhu kolem věcí, které se mohou měnit. Předpokládejme, že jsme napsali spoustu kódu, který používá tuto proměnnou APPLES. A nyní, v jedenáctou hodinu, zjistíme, že musíme sledovat dva různé druhy jablek, červené a zelené! Nemusíme si mnout ruce, ale raději si vzpomeňme na funkci proměnné APPLES: poskytnout adresu. Potřebujeme-li dvě oddělené soupisky, APPLES nám může poskytnout dvě různé adresy podle toho, o jaký druh jablka se právě jedná. Definujeme tedy složitější verzi APPLES takto: PROMĚNNÁ PROMĚNNÁ : RED ( : GREEN : APPLES

COLOR ( ukazatel na aktuální součet) REDS ( součet červených jablek) GREENS ( součet zelených jablek) set apple-type to RED) REDS COLOR ! ; ( set apple-type to GREEN) GREENS COLOR ! ; ( -- adr aktuálního sčítání jablek) COLOR @ ;

Skrytí konstrukce datových struktur

25

Obrázek 1.10: Změna nepřímého ukazatele.

Zde jsme nadefinovali APPLES. Nyní načítá obsah proměnné s názvem COLOR. COLOR je ukazatel buď na proměnnou REDS, nebo na proměnnou GREENS. Tyto dvě proměnné jsou skutečnými hodnotami. Pokud nejprve řekneme RED, pak můžeme použít APPLES pro odkaz na červená jablka. Pokud řekneme ZELENÁ, můžeme ji použít pro odkaz na zelená jablka (obrázek 1.10). Nemuseli jsme měnit syntaxi žádného stávajícího kódu, který používá APPLES. Stále můžeme říkat 20 APPLES ! a 1 APPLES +! Podívejte se znovu na to, co jsme udělali. Změnili jsme definici APPLES z definice proměnné na definici dvojtečky, aniž bychom ovlivnili její použití. Forth nám umožňuje skrýt detaily toho, jak je APPLES definován, před kódem, který jej používá. To, co se původnímu kódu jeví jako "věc" (proměnná), je ve skutečnosti v rámci komponenty definováno jako "akce" (definice dvojtečky). Forth podporuje používání abstraktních datových typů tím, že umožňuje definovat datové struktury v termínech komponent nižší úrovně. Pouze jazyk Forth, který eliminuje CALL z procedur, který umožňuje implicitní předávání adres a dat přes zásobník a který poskytuje přímý přístup k paměťovým místům pomocí @ a !, může nabídnout tuto úroveň skrývání informací. Forth věnuje jen malou pozornost tomu, zda je něco datovou strukturou nebo algoritmem. Tato lhostejnost nám programátorům umožňuje neuvěřitelnou volnost při vytváření částí řeči, které potřebujeme k popisu našich aplikací.

26

Filozofie jazyka Forth

Mám tendenci považovat každé slovo, které vrací adresu, například APPLES, za "podstatné jméno" bez ohledu na to, jak je definováno. Slovo, které vykonává zřejmou činnost, je "sloveso". Slova jako ČERVENÝ a ZELENÝ v našem příkladu lze nazvat pouze "přídavnými jmény", protože modifikují funkci slova APPLES. Věta RED APPLES ? se liší od GREEN APPLES ? Předložková slova mohou sloužit také jako příslovce a předložky. Nemá velký význam snažit se určit, jakou částí řeči je konkrétní slovo, protože Forthu je to stejně jedno. Stačí, když si budeme užívat snadnost popisu aplikace přirozenými výrazy.

Je to ale jazyk vysoké úrovně? V našem stručném technickém přehledu jsme uvedli, že tradiční vysokoúrovňové jazyky se od asembleru oddělily tím, že odstranily nejen korespondenci jedna ku jedné mezi příkazy a strojovými operacemi, ale také lineární korespondenci. Je zřejmé, že Forth si činí nárok na první rozdíl; pokud jde o druhý, pořadí slov, která použijete v definici, je pořadím, v němž jsou tyto příkazy kompilovány. Diskvalifikuje to Forth z řad vysokoúrovňových jazyků? Než si odpovíme, prozkoumejme výhody přístupu Forthu.

Zde je vyjádření Charlese Moora, vynálezce jazyka Forth: Definujte každé slovo tak, aby počítač věděl, co znamená. Způsob, jakým to ví, je ten, že v důsledku vyvolání provede nějaký kód. Počítač provede na každé slovo nějakou akci. Neukládá si slovo do paměti a nepamatuje si ho na později. Ve filozofickém smyslu to podle mě znamená, že počítač "rozumí" slovu. Rozumí slovu DUP, možná hlouběji než vy, protože v jeho mysli nikdy nevznikne otázka, co slovo DUP znamená. Spojení mezi slovy, která mají význam pro vás, a slovy, která mají význam pro počítač, je hluboké. Počítač se stává prostředkem komunikace mezi člověkem a pojmem.

Je to však jazyk vysoké úrovně?

27

Dva úhly pohledu.

Jednou z výhod shody mezi zdrojovým kódem a strojovým provedením je obrovské zjednodušení překladače a interpretu. Toto zjednodušení zlepšuje výkonnost několika způsoby, jak uvidíme v pozdější části. Z hlediska metodiky programování je výhodou přístupu Forth to, že lze snadno přidávat nová slova a nové syntaxe. O jazyku Forth nelze říci, že by "hledal" slova - on slova najde a provede je. Pokud přidáte nová slova, Forth je také najde a provede. Není rozdíl mezi existujícími slovy a slovy, která přidáte. A co víc, tato "rozšiřitelnost" se vztahuje na všechny typy slov, nejen na funkce typu akce. Forth například umožňuje přidávat nová kompilační slova - jako IF a THEN, která zajišťují strukturovaný tok řízení. Můžete snadno přidat příkaz case nebo smyčku s vícenásobným ukončením, pokud je potřebujete, nebo, což je stejně důležité, je odstranit, pokud je nepotřebujete. Naproti tomu každý jazyk, který je pro pochopení příkazu závislý na pořadí slov, musí "znát" všechna legální slova a všechny legální kombinace. Jeho šance, že bude obsahovat všechny konstrukce, které byste chtěli, je mizivá. Jazyk existuje tak, jak určil jeho výrobce; jeho znalosti nemůžete rozšířit. Laboratorní výzkumníci uvádějí flexibilitu a rozšiřitelnost jako jedny z nejdůležitějších výhod jazyka Forth v jejich prostředí. Lexikony lze vytvořit tak, aby skrývaly informace o nejrůznějších testovacích zařízeních připojených k počítači. Jakmile tuto práci odvede zkušenější programátor, mohou výzkumníci volně využívat svou "softwarovou sadu nástrojů" malých slov k psaní jednoduchých programů pro experimenty. Jak se objevují nová zařízení, přidávají se nové lexikony. Mark Bernstein popsal problém používání hotové knihovny účelových procedur v laboratoři [8]: "Počítač, nikoliv uživatel, dominuje experimentu." Ale v případě Forthu, píše, "počítač ve skutečnosti podněcuje vědce k tomu, aby software upravovali, opravovali a vylepšovali, aby experimentovali se svým vybavením a charakterizovali ho. Iniciativa se opět stává výsadou výzkumníka". Těm puristům, kteří se domnívají, že Forth není vhodný k tomu, aby se nazýval vysokoúrovňovým jazykem, Forth situaci ještě zhoršuje. Zatímco silná kontrola syntaxe a typování dat se stávají jedním z hlavních tahounů současných programovacích jazyků, Forth neprovádí téměř žádnou kontrolu syntaxe. Aby mohl poskytnout takovou volnost a flexibilitu, jakou jsme popsali, nemůže vám říct, že jste chtěli napsat RED APPLES místo APPLES RED. Právě jste vymysleli syntaxi! Přesto Forth toto opomenutí více než vynahrazuje tím, že vám umožňuje zkompilovat každou definici po jedné, a to s obratem v řádu sekund. Na svou chybu přijdete poměrně brzy, když definice nefunguje. Kromě toho můžete do svých definic přidat příslušnou kontrolu syntaxe, pokud chcete.

Je to ale jazyk vysoké úrovně?

29

Dvě řešení problému bezpečnosti.

Štětec malíře na chybu neupozorní, to posoudí malíř. Kuchařova pánev a skladatelův klavír zůstávají jednoduché a poddajné. Proč nechat programovací jazyk, aby se vás snažil přechytračit? Je tedy Forth vysokoúrovňový jazyk? V otázce kontroly syntaxe se vymyká. V otázce abstrakce a výkonu se zdá, že má nekonečnou úroveň - podporuje vše od manipulace s bity na výstupním portu až po obchodní aplikace. Rozhodněte se sami. (Forthu je to jedno.)

Jazyk návrhu Forth je jazyk návrhu. Pro studenta tradiční informatiky je toto tvrzení v rozporu samo se sebou. "Člověk nenavrhuje pomocí jazyka, ale implementuje pomocí jazyka. Návrh předchází implementaci." Zkušení programátoři jazyka Forth s tímto názorem nesouhlasí. Ve Forthu můžete psát abstraktní kód na úrovni návrhu, a přesto jej můžete kdykoli otestovat, protože využijete dekompozici na lexikony. Komponentu lze v průběhu vývoje snadno přepsat pod všechny komponenty, které ji používají. Zpočátku mohou slova v komponentě místo ovládání krokových motorů vypisovat na terminálu čísla. Mohou vypisovat svá vlastní jména, jen abyste věděli, že se provedla. Možná nebudou dělat vůbec nic. Pomocí této filozofie můžete napsat jednoduchou, ale testovatelnou verzi aplikace a pak ji postupně měnit a vylepšovat, dokud nedosáhnete svého cíle. Dalším faktorem, který umožňuje návrh v kódu, je to, že Forth, podobně jako některé novější jazyky, eliminuje vývojovou sekvenci "dávkové kompilace" (editovat-kompilovat-testovat-editovat-kompilovat-testovat). Protože zpětná vazba je okamžitá, stává se médium partnerem v tvůrčím procesu. Programátor používající jazyk s dávkovým kompilátorem může málokdy dosáhnout produktivního stavu mysli, jakého dosahují umělci, když tvůrčí proud proudí bez zábran. Z těchto důvodů tráví programátoři ve Forthu méně času plánováním než jejich klasičtí kolegové, kteří se cítí být při plánování spravedliví. Neplánování jim připadá lehkomyslné a nezodpovědné. Tradiční prostředí nutí programátory plánovat, protože tradiční programovací jazyky se neumí snadno přizpůsobit změnám. Bohužel lidská předvídavost je omezená i za těch nejlepších podmínek. Příliš mnoho plánování se stává kontraproduktivním. Forth samozřejmě plánování nevylučuje. Umožňuje tvorbu prototypů. Konstrukce prototypu je rafinovanějším způsobem plánování, podobně jako je v návrhu elektroniky breadboarding. Jak uvidíme v další kapitole, experimentování se ukazuje jako spolehlivější způsob, jak dospět k pravdě, než dohady při plánování.

Jazyk návrhu

31

Jazyk výkonu Ačkoli výkon není hlavním tématem této knihy, nováček v oblasti Forthu by měl být ujištěn, že jeho výhody nejsou čistě filozofické. Celkově Forth předčí všechny ostatní vysokoúrovňové jazyky v rychlosti, schopnostech a kompaktnosti.

Rychlost Přestože je Forth interpretační jazyk, provádí kompilovaný kód. Proto běží asi desetkrát rychleji než interpretativní BASIC. Forth je optimalizován pro provádění slov pomocí techniky známé jako "vláknový kód" [9], [10], [11]. Penále za modularizaci na velmi malé části kódu je relativně malé. Neprobíhá tak rychle jako kód assembleru, protože vnitřní interpret (který interpretuje seznam adres, z nichž se skládá každá definice dvojtečky) může v závislosti na procesoru spotřebovat až 50 % času běhu primitivních slov. Ve velkých aplikacích se však Forth velmi blíží rychlosti assembleru. Zde jsou tři důvody: Za prvé a především je Forth jednoduchý. Použití zásobníku dat v jazyce Forth výrazně snižuje výkonnostní náklady na předávání argumentů ze slova do slova. Ve většině jazyků je předávání argumentů mezi moduly jedním z hlavních důvodů, proč použití podprogramů brzdí výkon. Za druhé, jazyk Forth umožňuje definovat slova buď ve vysokoúrovňovém, nebo ve strojovém jazyce. V obou případech není potřeba žádná speciální volací sekvence. Můžete napsat novou definici ve vysoké úrovni a po ověření, že je správná, ji přepsat do assembleru, aniž byste měnili kód, který ji používá. V typické aplikaci bude možná 20 % kódu běžet 80 % času. Pouze nejčastěji používané, časově kritické rutiny je třeba strojově kódovat. Samotný systém Forth je z velké části implementován v definicích strojového kódu, takže budete mít jen málo slov aplikace, která je třeba kódovat v assembleru. Za třetí, aplikace Forthu bývají lépe navržené než aplikace napsané výhradně v assembleru. Programátoři ve Forthu využívají možnosti prototypování jazyka a vyzkoušejí několik algoritmů, než se rozhodnou pro ten, který nejlépe vyhovuje jejich potřebám. Protože jazyk Forth podporuje změny, lze jej také nazvat jazykem optimalizace. Forth nezaručuje rychlé aplikace. Poskytuje však programátorům tvůrčí prostředí, ve kterém mohou navrhovat rychlé aplikace.

Schopnosti Forth umí vše, co umí jakýkoli jiný jazyk - obvykle snadněji.

32

Filozofie jazyka Forth

Nejlepší návrhy shora dolů myší a mladíků.

Na nízkém konci obsahují téměř všechny systémy Forth assemblery. Ty podporují operátory řídicí struktury pro zápis podmínek a cyklů pomocí technik strukturovaného programování. Obvykle umožňují psát přerušení - v případě potřeby můžete dokonce psát kód přerušení ve vysoké úrovni. Některé systémy Forth jsou multitaskové, což vám umožňuje přidat libovolný počet úloh na popředí nebo na pozadí. Forth lze napsat tak, aby běžel nad libovolným operačním systémem, jako je RT11, CP/M nebo MS-DOS - nebo, pro ty, kteří to preferují, lze Forth napsat jako samostatný operační systém včetně vlastních terminálových a diskových ovladačů. Pomocí křížového kompilátoru nebo cílového kompilátoru jazyka Forth můžete použít jazyk Forth k vytvoření nových systémů Forth pro stejný počítač nebo pro různé počítače. Protože je Forth napsán v jazyce Forth, máte jinak nemyslitelnou možnost přepsat operační systém podle potřeb vaší aplikace. Nebo můžete přenést zjednodušené verze aplikací do vestavných systémů.

Velikost Jsou zde dvě hlediska: velikost kořenového systému Forth a velikost zkompilovaných aplikací Forth. Jádro Forthu je velmi flexibilní. Ve vestavěné aplikaci se část jazyka Forth, kterou potřebujete ke spuštění aplikace, může vejít do pouhého 1K. V plnohodnotném vývojovém prostředí má víceúlohový systém Forth včetně interpretu, kompilátoru, assembleru, editoru, operačního systému a všech dalších podpůrných utilit v průměru 16K. To ponechává spoustu místa pro aplikace. (A některé Forthy na novějších procesorech zvládají 32bitové adresování, což umožňuje nepředstavitelně velké programy.) Stejně tak aplikace kompilované v jazyce Forth bývají velmi malé - obvykle menší než ekvivalentní programy v assembleru. Důvodem je opět kód s vlákny. Každý odkaz na dříve definované slovo, bez ohledu na jeho sílu, spotřebuje pouze dva bajty. Jedním z nejzajímavějších nových území pro jazyk Forth je výroba čipů Forth, jako je mikroprocesor Rockwell R65F11 založený na jazyku Forth [12]. Tento čip obsahuje nejen hardwarové funkce, ale také běhové části jazyka Forth a operační systém pro specializované aplikace. Pouze architektura a kompaktnost jazyka Forth umožňují použití mikroprocesorů založených na Forthu.

Shrnutí Jazyk Forth je často charakterizován jako netradiční, svou strukturou a filozofií zcela nepodobný žádnému jinému populárnímu jazyku. Naopak, Forth obsahuje mnoho principů, kterými se dnes pyšní většina současných jazyků. Strukturovaný návrh, modularita a skrývání informací patří k módním slovům dneška.

34

Filozofie jazyka Forth

Některé novější jazyky se duchu Forthu přibližují ještě více. Například jazyk C umožňuje programátorovi definovat nové funkce buď v jazyce C, nebo v assembleru, stejně jako Forth. A stejně jako v případě Forthu je většina jazyka C definována pomocí funkcí. Forth však rozšiřuje koncepty modularity a skrývání informací dále než kterýkoli jiný současný jazyk. Forth dokonce skrývá způsob, jakým jsou volána slova, a způsob, jakým jsou předávány lokální argumenty. Výsledný kód se stává koncentrovanou souhrou slov, nejčistším vyjádřením abstraktního myšlení. Výsledkem je, že programátoři jazyka Forth mají tendenci být produktivnější a psát sevřenější, efektivnější a lépe udržovatelný kód. Forth nemusí být dokonalým jazykem. Věřím však, že konečný jazyk, pokud je něco takového možné, se bude Forthu podobat více než kterýkoli jiný současný jazyk.

Literatura [1] O. J. Dahl, E. W. Dijkstra a C. A. R. Hoare, Structured Programming, London, Academic Press, 1972. [2] Niklaus Wirth, "Program Development by Stepwise Refinement," Communications of ACM, 14, č. 4 (1971), 221-27. [3] W. P. Stevens, G. J. Myers a L. L. Constantine, "Structured Design," IBM Systems Journal, Vol. 13, No. 2, 1974. [4] David L. Parnas, "On the Criteria To Be Used in Decomposing Systems into Modules", Communications of the ACM, prosinec 1972. [5] Barbara H. Liskov a Stephen N. Zilles, "Specification Techniques for Data Abstractions," IEEE Transactions on Software Engineering, březen 1975. [6] David L. Parnas, "Designing Software for Ease of Extension and Contraction", IEEE Transactions on Software Engineering, březen 1979. [7] Dewey Val Shorre, "Adding Modules to Forth," 1980 FORML Proceedings, str. 71. [8] Mark Bernstein, "Programování v laboratoři", nepublikovaný článek, 1983. [9] James R. Bell, "Threaded Code," Communications of ACM, roč. 16, č. 6, s. 370-72. [10] Robert B. K. DeWar, "Indirect Threaded Code," Communications of ACM, Vol. 18, No. 6, 331. [11] Peter M. Kogge, "An Architectural Trail to Threaded-Code Systems," Computer, březen 1982. [12] Randy Dumse, "The R65F11 Forth Chip," Forth Dimensions, Vol. 5, No. 2, str. 25.

Odkazy:

35

DVA

Analýza

Každý, kdo vám tvrdí, že existuje nějaký určitý počet fází vývojového cyklu softwaru, je blázen. Nicméně ...

Devět fází programovacího cyklu Jak jsme viděli, Forth v sobě spojuje aspekty návrhu s aspekty implementace a údržby. V důsledku toho má pojem "typický vývojový cyklus" stejný smysl jako "typický šum". Jakýkoli přístup je však lepší než žádný a skutečně se některé přístupy osvědčily lépe než jiné. Zde je vývojový cyklus, který představuje "průměr" nejúspěšnějších přístupů používaných v softwarových projektech: Analýza 1. Zjistěte požadavky a omezení 2. Zjistěte, co je třeba udělat. Vytvoření koncepčního modelu řešení 3. Odhad nákladů/harmonogramu/výkonnostního inženýrství 4. Předběžný návrh 5. Podrobný návrh 6. Využití implementace 7. Optimalizace 8. Validace a ladění 9. Údržba V této knize se budeme zabývat prvními šesti fázemi cyklu se zaměřením na analýzu, návrh a implementaci. V projektu Forth se tyto fáze vyskytují na několika úrovních. Podíváme-li se na projekt z nejširší perspektivy, může každá z těchto fází trvat měsíc i více. Jeden krok následuje za druhým jako roční období.

38

Analýza

Stejné fáze však programátoři Forthu uplatňují i směrem k definování jednotlivých slov. Cyklus se pak opakuje v řádu minut. Vývoj aplikace s tímto rychlým opakováním programovacího cyklu je znám jako použití "iterativního přístupu".

Iterativní přístup Iterativní přístup výstižně vysvětlil Kim Harris [1]. Začíná popisem vědecké metody: ... nikdy nekončící cyklus objevování a zdokonalování. Nejprve studuje přirozený systém a shromažďuje pozorování o jeho chování. Poté se pozorování modelují, aby se vytvořila teorie o přírodním systému. Poté se na model aplikují analytické nástroje, které vytvářejí předpovědi o chování skutečného systému. Pro porovnání skutečného chování s předpovězeným chováním jsou navrženy experimenty. Přirozený systém je znovu zkoumán a model je revidován. Cílem metody je vytvořit model, který přesně předpovídá veškeré pozorovatelné chování přírodního systému.

Harris pak aplikuje vědeckou metodu na cyklus vývoje softwaru, který je znázorněn na obrázku 2.1: 1. Vědecká metoda. Problém se analyzuje, aby se určilo, jaké funkce jsou v řešení potřebné. 2. Přijímají se rozhodnutí o tom, jak těchto funkcí dosáhnout s dostupnými zdroji. 3. Napíše se program, který se pokusí návrh realizovat. Obrázek 2.1: Iterativní přístup k cyklu vývoje softwaru, z knihy "The Forth Philosophy" od Kima Harrise, Dr. Dobb's Journal.

Iterativní přístup

39

4. Program se testuje, aby se zjistilo, zda byly funkce implementovány správně. Pan Harris k tomu dodává: Vývoj softwaru ve Forthu se nejprve snaží najít co nejjednodušší řešení daného problému. Toho se dosahuje tak, že se vybrané části problému implementují samostatně a ignoruje se co nejvíce omezení. Poté se zavede jedno nebo několik málo omezení a program se upraví.

Vynikajícím dokladem modelu vývoje/testování návrhu je evoluce. Od prvoků přes pulce až po lidi se každý druh na této cestě skládal z funkčních, živých bytostí. Stvořitel se nezdá být designérem shora dolů. Tip 2.1

Začněte jednoduše. Rozjeďte to. Naučte se, co se snažíte dělat. Složitost přidávejte postupně, podle potřeby, aby odpovídala požadavkům a omezením. Nebojte se začít znovu od nuly.

Hodnota plánování V devíti fázích na začátku této kapitoly jsme uvedli pět kroků před "implementací". Přesto jsme v první kapitole viděli, že přílišná snaha o plánování je obtížná a zbytečná. Je zřejmé, že nelze realizovat významný softwarový projekt - bez ohledu na jazyk - bez určitého stupně plánování. Jaká míra je přesně vhodná? Nejeden programátor jazyka Forth vyjádřil velkou úctu k pečlivému přístupu Davea Johnsona k plánování. Johnson je vedoucím ve společnosti Moore Products Co. ve Springhouse v Pensylvánii. Firma se specializuje na průmyslové přístroje a aplikace pro řízení procesů. Dave používá jazyk Forth od roku 1978. Popisuje svůj přístup: V porovnání s mnoha jinými, kteří používají jazyk Forth, předpokládám, že k němu přistupujeme formálněji. Naučil jsem se to však tvrdým způsobem. Nedostatek disciplíny v prvních letech se mi vymstil. Při vymýšlení nových produktů používáme dva nástroje: funkční specifikaci a specifikaci návrhu. Naše oddělení prodeje a aplikací přichází s funkční specifikací prostřednictvím kontaktu se zákazníky. Jakmile se dohodneme, co budeme dělat, funkční specifikace se předá našemu oddělení. V tomto okamžiku zpracujeme návrh a přijdeme se specifikací návrhu.

40

Analýza

Až do tohoto bodu se náš přístup neliší od programování v jakémkoli jazyce. Ve Forthu však postupujeme při návrhu poněkud odlišně. Ve Forthu nemusíte návrh propracovat z 95 %, než můžete začít kódovat, ale spíše z 60 %, než se dostanete k iteračnímu procesu. Typickým projektem je přidání funkčního vylepšení do některého z našich produktů. Například máme inteligentní terminál s diskovými jednotkami a potřebujeme určité protokoly pro komunikaci s jiným zařízením. Projekt, jehož cílem je navrhnout protokoly, vymyslet displeje, zajistit rozhraní pro obsluhu atd. může trvat několik měsíců. Funkční specifikace trvá měsíc; specifikace návrhu trvá měsíc; kódování trvá tři měsíce; integrace a testování trvá další měsíc. To je typický cyklus. Jeden projekt trval téměř dva roky, ale šest nebo sedm měsíců je přiměřených. Když jsme s jazykem Forth před pěti lety začínali, nebylo to tak. Když jsem dostal funkční specifikaci, prostě jsem začal kódovat. Používal jsem křížení postupu shora dolů a zdola nahoru, obecně jsem definoval strukturu, a jak jsem potřeboval, tak i některé nižší úrovně, a pak jsem se vrátil s další strukturou. Důvodem tohoto přístupu byl obrovský tlak na to, abych něco ukázal vedení. Nakonec jsme nikdy nenapsali, co děláme. O tři roky později jsme se vraceli a snažili se kód upravit, aniž bychom k němu měli jakoukoli dokumentaci. Forth se stal nevýhodou, protože nám umožnil jít do toho příliš brzy. Bylo zábavné nechat blikat světla a hučet diskové jednotky. Ale neprošli jsme hloubkovou prací na návrhu. Jak už jsem řekl, naše "svobodomyslnost" se nám vrátila. Nyní máme pro nové programátory zavedený požadavek: důkladnou specifikaci návrhu, která podrobně definuje všechna vysokoúrovňová slova jazyka Forth - úlohy, které bude váš projekt dělat. Už žádné čtení několika stránek funkční specifikace, odpovědi na ni, čtení několika dalších, odpovědi na ni atd. Žádný živý programátor nemá rád dokumentování. Tím, že si návrh zajistíme dopředu, jsme schopni se po několika letech ohlédnout a vzpomenout si, co jsme dělali. Měl bych zmínit, že během fáze návrhu se provádí určité množství kódování, aby se otestovaly určité nápady. Tento kód však nemusí být součástí hotového produktu. Jde o to, abyste si zmapovali svůj návrh.

Johnson nám radí, abychom před zahájením kódování dokončili specifikaci návrhu, s výjimkou potřebných předběžných testů. Další rozhovor tento bod podporuje a přidává několik dalších důvodů. John Teleska je od roku 1976 nezávislým softwarovým konzultantem, který se specializuje na zakázkové aplikace pro akademické výzkumné prostředí. Baví ho poskytovat výzkumné nástroje "na samé hranici toho, co technologie dokáže". Teleska pracuje v Rochesteru ve státě New York: Proces vývoje softwaru vidím jako dvoufázový. V první se ujišťuji, že rozumím, v čem spočívá problém. Druhou je implementace, včetně ladění, ověřování atd.

Hodnota plánování

41

Mým cílem v první fázi je provozní specifikace. Začínám s popisem problému, který se postupem času stává provozní specifikací. Mé chápání problému metamorfuje v řešení. Čím lepší je porozumění, tím úplnější je řešení. Hledám uzavření; pocit, že už nemám žádné další otázky, které nejsou v tisku zodpovězeny. Zjistil jsem, že u každého projektu věnuji více času první fázi, k počátečnímu zděšení mnoha mých klientů. Limitujícím faktorem je, nakolik dokážu klienta přesvědčit, že je nutné tento čas věnovat předem. Zákazníci obvykle neznají specifikace práce, kterou chtějí provést. A nemají kapitál - nebo se tak necítí - na to, aby ho utratili za dobré specifikace. Součástí mé práce je přesvědčit je, že je to bude stát více času a peněz. Část první fáze se věnuje studiím proveditelnosti. Psaní specifikace odhaluje nejistoty. Snažím se, aby nejistoty byly co nejneurčitější. Například mohou chtít odebrat 200 000 vzorků za sekundu s určitou přesností. Nejprve musím zjistit, zda je to vůbec možné s vybavením, které mají. V tomto případě musím otestovat jeho proveditelnost napsáním záplaty kódu. Dalším důvodem pro specifikaci je, abych se kryl. V případě, že aplikace bude fungovat podle specifikace, ale nebude plně vyhovovat zákazníkovi, nese za to odpovědnost zákazník. Pokud bude zákazník chtít víc, budeme muset znovu jednat. Ale já vidím jako odpovědnost konstruktéra udělat vše, co je nutné k vytvoření funkční specifikace, která bude plnit úkol ke spokojenosti zákazníka. Myslím, že existují konzultanti, kteří se podvolí tlaku klienta a omezí čas, který stráví nad specifikací, ze strachu, že přijdou o zakázku. V takových situacích ale nakonec není spokojený nikdo.

K rozhovoru s Teleskou se za chvíli vrátíme.

Omezení plánování Zkušenost nás naučila, že než začneme kódovat, musíme si zmapovat, kam směřujeme. Plánování má však určitá omezení. Následující rozhovory přinášejí různé pohledy na hodnotu plánování. Přestože Teleska dává přednost dobře naplánovanému projektu, naznačuje, že volba mezi přístupem shora dolů a zdola nahoru může záviset na situaci: U dvou nedávných projektů, které zahrnovaly mnoho práce na technickém rozhraní, jsem celou věc dělal zdola nahoru. Mlel jsem v hromadě datových listů a technických popisů malých zákoutí operačního systému, kterým jsem se zabýval. Většinu času jsem se cítil ztracený a říkal jsem si, proč jsem tu práci vůbec vzal. Pak jsem konečně dosáhl jakéhosi kritického množství a začal dávat dohromady malé programy, které prováděly malé věci. Pokračoval jsem zdola nahoru, dokud jsem neodpovídal cílové aplikaci.

42

Analýza

Můj smysl shora dolů byl tímto postupem zděšen. Ale viděl jsem, že jsem tímto procesem úspěšně prošel příliš mnohokrát, než abych ho z pedagogických důvodů shazoval. A vždycky je tu ta obtížná fáze, do které jako by žádné lineární myšlení neproniklo. Zdá se, že programování je mnohem intuitivnější, než si v této branži říkáme, že by mělo být. Myslím, že pokud aplikace vyvolává tento pocit ztracenosti, postupuju zdola nahoru. Pokud je aplikace na známém území, pak pravděpodobně použiji tradičnější přístup podle knihy.

A tady je další pohled: V době, kdy jsem s ním vedl rozhovor, Michael Starling ze společnosti Union Carbide dokončoval dvě aplikace zahrnující uživatelsky konfigurovatelné systémy automatizace laboratoří a automatizace řízení procesů. Pro systém pilotního závodu navrhl Starling hardware i software podle známých požadavků; u systému laboratorní automatizace definoval požadavky také sám. Jeho úsilí bylo mimořádně úspěšné. U jednoho projektu stál nový systém obvykle jen 20 % nákladů oproti ekvivalentnímu systému a jeho instalace a konfigurace vyžadovala dny namísto měsíců. Zeptal jsem se ho, jaké techniky projektového řízení používá. U obou těchto projektů bylo zapotřebí mnoho návrhů. Tradičními analytickými metodami jsem se však neřídil. Použil jsem však tyto kroky: Nejprve jsem jasně definoval hranice problému. Za druhé jsem určil, jaké musí být menší funkční části, softwarové subsystémy. Zatřetí jsem udělal jednotlivé části, spojil je dohromady a systém běžel. Poté jsem se zeptal uživatelů: "Splňuje to vaše požadavky?". Někdy nesplňovalo, a to způsobem, který uživatelé ani tvůrci specifikace nemohli předpokládat. Návrháři si například neuvědomili, že původní specifikace nevytvoří příjemné, na člověka orientované grafické zobrazení. Po práci s interaktivní grafikou v první verzi uživatelé používali libovolná měřítka a vymýšleli podivná zobrazení. Takže i po návrhu základního algoritmu vykreslování jsme si uvědomili, že potřebujeme automatické škálování. Vrátili jsme se k analýze toho, jak lidé vykreslují data, a napsali jsme funkci první úrovně vykreslování, která vyhodnocuje údaje x a y a to, kolik se jich vejde do grafu. Poté jsme si uvědomili, že ne všechna pořízená data budou pro experimentátory zajímavá. Proto jsme přidali možnost zvětšení. Výsledkem tohoto iterativního přístupu byl čistší a lépe promyšlený kód. Stanovili jsme základní sadu cílů a vytvořili jsme minimální systém podle uživatelů

Omezení plánování

43

známých požadavků. Pak jsme klikali na zkušenosti programátorů, abychom jej vylepšili a zjistili, co uživatelé zapomněli, že potřebují, když generovali specifikace. Uživatelé většinu nových nápadů nevymysleli. To dělali programátoři, kteří tyto nápady od uživatelů odráželi. Definování problému bylo obousměrné. V některých případech dostali věci, o kterých nevěděli, že je mohou na tak malém počítači udělat, jako je aplikace digitálních filtrů a zpracování signálu na data. Jednou z věcí, které tento přístup ve Forthu umožňují, je to, že primitiva jsou snadno testovatelná. Abyste se naučili, jak toho využít, je třeba mít s jazykem Forth určité zkušenosti. Lidé z tradičního prostředí chtějí napsat deset stránek kódu u svého stolu, pak si sednout, napsat ho a očekávat, že bude fungovat. Abych shrnul svůj přístup: Snažím se od uživatelů zjistit, co potřebují, ale zároveň uznávám jejich neúplnost. Pak je při implementaci nechávám zapojené do návrhu, protože mají odborné znalosti o dané aplikaci. Když vidí výsledek, mají dobrý pocit, protože vědí, že se na něm podílely jejich nápady. Iterativní přístup klade nejvyšší důraz na vytvoření dobrého řešení skutečného problému. Nemusí vždy přinést nejpředvídatelnější náklady na software. Cesta k řešení může záviset na vašich prioritách. Nezapomeňte: Vyberte si libovolné dva!

Jak poznamenává Starling, nevíte úplně, co děláte, dokud to jednou neuděláte. Z vlastní zkušenosti vím, že nejlepší způsob, jak napsat aplikaci, je napsat ji dvakrát. První verzi zahoďte a přičtěte ji ke zkušenostem. Peter Kogge je vedoucím technickým pracovníkem v divizi federálních systémů IBM v Oswegu ve státě New York: Jednou z klíčových výhod jazyka Forth je, že mi umožňuje velmi rychle vytvořit prototyp aplikace bez všech zvonků a píšťalek a často se značnými omezeními, ale dostatečně na to, abych si mohl vyzkoušet "lidské rozhraní" pomocí zkušebního provozu. Když vytvářím takový prototyp, dělám to s pevným omezením, že v konečném programu nepoužiji ani řádek kódu z prototypu. Toto vynucené "předělání" téměř vždy vede k mnohem jednodušším a elegantnějším finálním programům, a to i tehdy, když jsou tyto programy napsány v něčem jiném než ve Forthu.

44

Analýza

Naše závěry? V prostředí Forthu je plánování nezbytné. Mělo by však být krátké. Testování a prototypování jsou nejlepší způsoby, jak zjistit, co je skutečně potřeba. Jedno upozornění pro projektové manažery: Pokud dohlížíte na zkušené programátory ve Forthu, nemusíte se obávat, že by plánováním trávili příliš mnoho času. Následující tip má tedy dvě verze: Tip Pro nováčky ve Forthu (s "tradičním" vzděláním): Fázi analýzy omezte na minimum.

2.2

Závisláci na Forthu (bez "tradičního" zázemí): Odkládejte kódování tak dlouho, dokud to vydržíte.

Nebo, jak jsme poznamenali v první kapitole: Tip Plánujte změny (návrhem komponent, které lze měnit).

2.3

Nebo jednoduše: "Vezměte si na starost, abyste se mohli změnit: Tip Prototypujte.

2.4

Fáze analýzy Ve zbývající části této kapitoly se budeme zabývat fází analýzy. Analýza je organizovaný způsob pochopení a zdokumentování toho, co má program dělat. U jednoduchého programu, který si napíšete za méně než hodinu, může fáze analýzy trvat asi 250 mikrosekund. Na druhém pólu jsou některé projekty, jejichž sestavení zabere mnoho člověkoroků. U takového projektu je fáze analýzy rozhodující pro úspěch celého projektu. Naznačili jsme tři části fáze analýzy: 1. Zjištění požadavků a omezení 2. Vytvoření koncepčního modelu řešení 3. Odhad nákladů, harmonogramu a výkonu Popišme si stručně jednotlivé části:

Fáze analýzy

45

Zjištění požadavků Prvním krokem je určení toho, co má aplikace dělat. Zákazník nebo ten, kdo chce systém, by měl dodat "specifikaci požadavků". Jedná se o skromný dokument, který uvádí minimální schopnosti hotového produktu. Analytik může také dále zkoumat požadavky tím, že provede rozhovory a rozešle uživatelům dotazníky.

Zjištění omezení Dalším krokem je odhalení všech omezujících faktorů. Jak důležitá je rychlost? Kolik paměti je k dispozici? Jak brzy ji budete potřebovat? Bez ohledu na to, jak sofistikované budou naše technologie, programátoři budou vždy narážet na omezení. Kapacita systému se časem nevysvětlitelně zmenšuje. Diskové jednotky s dvojnásobnou hustotou, které byly kdysi odpovědí na mé modlitby o úložiště, už nevyhovují. Oboustranné disky s dvojnásobnou hustotou, které si pořídím příště, mi budou připadat jako obrovská hranice - na nějakou dobu. Slyšel jsem, jak si lidé s desetimegabajtovými pevnými disky stěžují na pocit stísněnosti. Kdykoli je něčeho nedostatek - a ten bude vždycky - je třeba dělat kompromisy. Nejlepší je využít fázi analýzy k předvídání většiny omezení a rozhodnout se, které kompromisy udělat. Na druhou stranu byste neměli uvažovat o jiných typech omezení během analýzy, ale měli byste je naopak zavádět postupně během implementace, tak jako se míchá mouka do omáčky. Mezi typy omezení, která je třeba zvážit během analýzy, patří ta, která mohou ovlivnit celkový přístup. Typ, který je třeba odložit, zahrnuje ta, která lze řešit iterativním zpřesňováním plánovaného návrhu softwaru. Jak jsme slyšeli v dřívějších rozhovorech, zjištění hardwarových omezení často vyžaduje napsání testovacího kódu a vyzkoušení. Zjištění omezení zákazníka je obvykle otázkou dotazu u zákazníka nebo písemného průzkumu. "Jak rychle potřebujete to a to, na stupnici od jedné do deseti?" atd.

Sestavení koncepčního modelu řešení Koncepční model je imaginární řešení problému. Je to pohled na to, jak se zdá, že systém funguje. Je odpovědí na všechny požadavky a omezení. Jestliže definice požadavků zní: "Něco, na co se postavíte, abyste mohli natírat strop", pak popis konceptuálního modelu zní: "Zařízení, které je volně stojící (abyste mohli natírat střed místnosti), s několika schůdky rozmístěnými ve vhodných intervalech (abyste mohli vylézt nahoru a slézt dolů) a které má poblíž horní části malou poličku (abyste na ni mohli umístit plechovku s barvou)."

46

Analýza

Zpřesnění koncepčního modelu tak, aby splňoval požadavky a omezení.

Konceptuální model však není tak docela návrhem. Návrh začíná popisovat, jak systém skutečně funguje. V návrhu by se začal objevovat obraz stupňovitého žebříku. Forth tento rozdíl trochu stírá, protože všechny definice jsou zapsány v konceptuálních termínech a používají lexikony komponent nižší úrovně. Ve skutečnosti budeme později v této kapitole používat "pseudokód" jazyka Forth k popisu konceptuálních modelových řešení. Přesto je užitečné toto rozlišení provést. Konceptuální model je flexibilnější než návrh. Je snazší vměstnat požadavky a omezení do modelu než do návrhu. Tip 2.5

Snažte se vytvořit pevný koncepční model před zahájením návrhu.

Analýza spočívá v rozšíření definice požadavků do koncepčního modelu. Tato technika zahrnuje obousměrnou komunikaci se zákazníkem při postupných pokusech o popis modelu. Stejně jako k celému vývojovému cyklu je i k fázi analýzy nejlépe přistupovat iterativně. Každý nový požadavek bude mít tendenci něco v mentálním modelu navrhnout. Vaším úkolem je žonglovat se všemi požadavky a omezeními, dokud se vám nepodaří utkat model, který bude vyhovovat. Obrázek 2.2 znázorňuje iterativní přístup k fázi analýzy. Poslední krok je jedním z nejdůležitějších: ukázat zdokumentovaný model zákazníkovi. Použijte jakékoli komunikační prostředky - diagramy, tabulky nebo kreslené obrázky - k tomu, abyste zákazníkovi zprostředkovali své porozumění a získali potřebnou zpětnou vazbu. I kdybyste tuto smyčku absolvovali stokrát, stojí to za to. Obrázek 2.2: Iterativní přístup k analýze.

48

Analýza

V následujících třech částech se budeme zabývat třemi technikami definování a dokumentování koncepčního modelu: 1. Definování rozhraní 2. Definování pravidel 3. Definování datových struktur.

Definování rozhraní Tip Nejprve a především by měl konceptuální model popsat rozhraní systému.

2.6

Telesa a systémy: "Specifikace" se v podstatě zabývá tím, CO. Ve své nejhlavnější podobě popisuje, jak bude systém vypadat pro uživatele - mohli byste ji nazvat uživatelskou příručkou. Zjistil jsem, že píšu více poznámek k interakci s člověkem - jak to bude vypadat navenek - než k části, která vykonává práci. Zahrnu například celý výpis chybových akcí, abych ukázal, co se stane, když dojde k určité chybě. Kupodivu je to část, která stejně zabere nejvíce času na implementaci. V současné době pracuji na polovodičovém časovači průmyslové pračky. V tomto případě není uživatelské rozhraní tak složité. Co je složité, je rozhraní k pračce, u kterého musím být závislý na zákazníkovi a dokumentaci, kterou mi může poskytnout. Významným rozhraním je cokoli, co je rukama a nohama výrobku. V této rané fázi nerozlišuji mezi hardwarem a softwarem. Při implementaci se mohou zaměňovat. Proces návrhu hardwaru a proces návrhu softwaru jsou analogické. Způsob, jakým navrhuji hardware, spočívá v tom, že k němu přistupuji jako k černé skříňce. Na předním panelu jsou vstupy a výstupy. Stejně můžete postupovat i u softwaru. Používám libovolné techniky, diagramy atd. k tomu, abych zákazníkovi ukázal, jak vypadají vstupy a výstupy, a to na základě jeho popisu toho, co má výrobek dělat. Souběžně si však ve své mysli představuji, jak to bude realizováno. Vyhodnocuji, zda to dokážu udělat efektivně. Takže pro mě to není černá skříňka, ale šedá skříňka. Návrhář musí být schopen vidět dovnitř černých skříněk. Když navrhuji systém, který má různé moduly, snažím se, aby vazby byly co nejracionálnější a co nejmenší. Ale vždycky je to plus mínus, protože děláte kompromisy s ideálem. Pro samotný dokument používám DFD [diagramy toku dat, o kterých si povíme později] a jakýkoli jiný druh znázornění, který mohu klientovi ukázat. Ukazuji jim tolik diagramů, kolik jen mohu, abych jim objasnil své chápání. Obvykle je nepoužívám

Definování rozhraní

49

používám, jakmile dojde na implementaci. Próza musí být úplná i bez odkazů na diagramy.

Tip 2.7

V rámci definování rozhraní se včas rozhodněte pro ošetření chyb a výjimek.

Je pravda, že při kódování pro sebe se programátor často může nejprve soustředit na to, aby kód běžel správně za normálních podmínek, a o obsluhu chyb se starat později. Když však pracuje pro někoho jiného, měl by se na ošetření chyb zaměřit předem. Tuto oblast začínající programátoři často přehlížejí. Důvodem, proč je tak důležité rozhodnout se o ošetření chyb již v této fázi, je velká rozdílnost způsobů ošetření chyb. Chyba může být např: - ignorována - provedena tak, aby byl nastaven příznak označující, že došlo k chybě, zatímco zpracování pokračuje - provedeno okamžité zastavení aplikace - navrženo tak, aby byly zahájeny postupy k odstranění problému a program běžel dál. Pokud není míra požadované složitosti zpracování chyb stanovena včas, vzniká prostor pro vážnou komunikační mezeru. Je zřejmé, že volba nese obrovský dopad na návrh a implementaci aplikace. Tip 2.8

Konceptuální model vyvíjejte tak, že si představíte, jak data procházejí jednotlivými částmi modelu a jak na ně působí.

Disciplína zvaná strukturovaná analýza [2] nabízí některé techniky popisu rozhraní způsobem, kterému klienti snadno porozumí. Jedna z těchto technik se nazývá "diagram toku dat" (DFD), který zmínil Teleska. Diagram toku dat, jako je ten na obrázku 2.3, zdůrazňuje, co se děje s položkami dat při jejich průchodu systémem. Kruhy představují "transformace", funkce, které působí na informace. Šipky představují vstupy a výstupy transformací. Diagram znázorňuje zastavený okamžik systému v akci. Ignoruje inicializaci, smyčkové struktury a další detaily programování, které se týkají času. Uvádějí se tři výhody používání DFD:

50

Analýza

Obrázek 2.3: Diagram toku dat.

Za prvé, hovoří k zákazníkovi jednoduchými a přímými slovy. Pokud zákazník souhlasí s obsahem vašeho diagramu toku dat, víte, že problému rozumíte. Za druhé vám umožňují přemýšlet v termínech logického "co", aniž byste se nechali unést procedurálním "jak", což je v souladu s filozofií skrývání informací, o které jsme hovořili v minulé kapitole. Za třetí, zaměřují vaši pozornost na rozhraní systému a mezi moduly. Programátoři Forthu však DFD používají jen zřídkakdy, s výjimkou zákazníků. Forth vás vybízí k přemýšlení v termínech konceptuálního modelu a implicitní použití datového zásobníku ve Forthu činí předávání dat mezi moduly tak jednoduchým, že to lze obvykle považovat za samozřejmost. Je to proto, že Forth se při správném použití blíží funkcionálnímu jazyku. Pro každého, kdo se s jazykem Forth seznámí za pár dní, mají jednoduché definice přinejmenším stejný význam jako diagramy: : Požadavek ( množství část# -- ) ON-HAND? IF TRANSFER ELSE REORDER THEN ; : REORDER AUTHORIZATION? IF P.O. THEN ; : P.O. BOOKKEEPING COPY RECEIVING COPY VENDOR MAIL-COPY ;

Definice rozhraní

51

Toto je pseudokód jazyka Forth. Nebylo vynaloženo žádné úsilí na určení toho, jaké hodnoty jsou skutečně předávány na zásobníku, protože to je implementační detail. Komentář zásobníku pro REQUEST je použit pouze k označení dvou položek dat potřebných k zahájení procesu. (Kdybych tuto aplikaci navrhoval já, navrhl bych, aby uživatelské rozhraní tvořilo slovo NEED, které má tuto syntaxi: NEED 50 AXLES NEED převede množství na číselnou hodnotu na zásobníku, převede řetězec AXLES na číslo dílu, rovněž na zásobníku, a pak zavolá REQUEST. Takový příkaz by měl být definován pouze na nejvzdálenější úrovni). Johnson ze společnosti Moore Products Co. má několik slov o pseudokódu jazyka Forth: IBM používá přísně dokumentovaný jazyk PDL (program design language). My zde PDL používáme také, i když jej nazýváme FDL, tedy Forth design language. Asi se vyplatí mít všechny tyto standardy, ale jakmile se s jazykem Forth seznámíte, může být Forth sám o sobě návrhovým jazykem. Jen musíte vynechat takzvaná "šumová" slova: C@, DUP, OVER atd. a ukázat pouze základní tok. Většina lidí, kteří se Forthu věnují, to pravděpodobně dělá neformálně. My to děláme záměrně.

Během jednoho z našich rozhovorů jsem se Moora zeptal, zda používá nějaké diagramy k plánování koncepčního modelu, nebo zda programuje přímo ve Forthu? Odpověděl: Konceptuální model je Forth. Během let jsem se naučil takto přemýšlet.

Může se tak naučit myslet každý? Mám nespravedlivou výhodu. Kodifikoval jsem svůj styl programování a ostatní lidé ho převzali. Překvapilo mě, že se to stalo. A cítím se v krásné výhodě, protože je to můj styl, který se ostatní učí napodobovat. Mohou se naučit myslet jako já? Dovedu si představit, že ano. Je to jen otázka cviku, a já mám cviku víc.

Definování pravidel Většina vašeho úsilí při definování problému se soustředí na popis rozhraní. Některé aplikace budou vyžadovat, abyste definovali také sadu pravidel aplikace. Veškeré programování zahrnuje pravidla. Obvykle jsou tato pravidla tak jednoduchá, že téměř nezáleží na tom, jak je vyjádříte: "Pokud někdo stiskne tlačítko, zazvoní na zvonek." V tomto případě se jedná o pravidlo, které je tak složité. Některé aplikace však zahrnují pravidla tak složitá, že je nelze vyjádřit několika anglickými větami. K pochopení a zdokumentování těchto složitějších pravidel se může hodit několik formálních technik. Zde je příklad. Naše požadavky vyžadují systém pro výpočet poplatků za dálkové telefonní hovory. Zde je vysvětlení struktury sazeb zákazníka. (To jsem si vymyslel; netuším, jak telefonní společnost skutečně vypočítává své sazby, kromě toho, že je předražuje.)

52

Analýza

Všechny poplatky se počítají po minutách podle vzdálenosti ve stovkách kilometrů plus paušální poplatek. Paušální poplatek za hovory s přímou volbou ve všední dny mezi 8. a 17. hodinou činí 0,30 za první minutu a 0,20 za každou další minutu; kromě toho se každá minuta účtuje 0,12 za 100 mil. Paušální poplatek za přímé volání během pracovních dnů mezi 17:00 a 23:00 hodinou činí 0,22 za první minutu a 0,15 za každou další minutu; minutová sazba za vzdálenost činí 0,10 za 100 mil. Paušální poplatek za přímé volání v pozdních hodinách ve všední dny mezi 23. hodinou nebo kdykoli v sobotu, v neděli nebo o svátcích činí 0,12 za první minutu a 0,09 za každou další minutu; minutová sazba za vzdálenost činí 0,06 za 100 mil. Pokud hovor vyžaduje asistenci operátora, zvyšuje se paušální poplatek o 0,90 bez ohledu na hodinu.

Tento popis je napsán starou dobrou angličtinou a je to docela výmluvné. Je těžké se v něm orientovat a stejně jako půda zavalená nahromaděnými věcmi může skrývat i několik chyb. Při vytváření koncepčního modelu tohoto systému musíme strukturu sazby popsat jednoznačným a užitečným způsobem. Prvním krokem k vyčištění nepořádku je vyřazení nepodstatných informací - tedy uplatnění pravidel omezené redundance. Toto tvrzení můžeme značně vylepšit tím, že ho rozdělíme na dvě tvrzení. Nejprve je tu pravidlo o denní době: Hovory ve všední dny mezi 8. a 17. hodinou jsou zpoplatněny "plnou" sazbou. Hovory ve všední dny mezi 17. a 23. hodinou jsou zpoplatněny "nižší" sazbou. Hovory uskutečněné ve všední dny mezi 23. hodinou nebo kdykoli v sobotu, neděli nebo o svátcích jsou účtovány "nejnižší" sazbou.

Dále je zde samotná struktura sazeb, která by měla být popsána v podobě "sazby za první minutu", "sazby za další minutu", "sazby za vzdálenost" a "sazby za asistenci operátora". Tip Faktor ovoce. (Nepleťte si jablka s pomeranči.)

2.9

Tyto prozaické výroky jsou však stále obtížně čitelné. Systémoví analytici používají ke zjednodušení těchto výroků několik technik: strukturovanou angličtinu, rozhodovací stromy a rozhodovací tabulky. Prozkoumejme každou z těchto technik a zhodnoťme jejich užitečnost v prostředí jazyka Forth.

Strukturovaná angličtina Strukturovaná angličtina je jakýsi strukturovaný pseudokód, ve kterém by náš příkaz sazby zněl asi takto: IF plná sazba IF přímá volba IF první minuta .30 + .12/100mil.

Strukturovaná angličtina

53

ELSE ( add'l- minute) .20 + .12/100miles ENDIF ELSE ( operator ) IF first-minute 1.20 + .12/100miles ELSE ( add'l- minute) .20 + .12/100miles ENDIF ENDIF ELSE ( not-full-rate) IF lower-rate IF direct-dial IF first-minute .22 + .10/100miles ELSE ( add'l- minute) .15 + .10/100miles END IF ELSE ( operator) IF first-minute 1. 12 + .10/100mil ELSE ( přídavná minuta) .15 + .10/100mil ENDIF ENDIF ELSE ( nejnižší sazba) IF přímá volba IF první minuta .12 + .06/100mil ELSE ( přídavná minuta) .09 + .O6/100mil ENDIF ELSE ( operátor) IF první minuta 1,02 + .O6/100mil ELSE ( přídavná minuta) .09 + .06/100mil ENDIF ENDIF ENDIF ENDIF ENDIF

Tohle je prostě nešikovné. Hůře se to čte, hůře udržuje a nejhůře píše. A při tom všem je to v době implementace bezcenné. Už se mi o tom ani nechce mluvit.

54

Analýza

Obrázek 2.4: Příklad rozhodovacího stromu.

Rozhodovací strom Obrázek 2.4 znázorňuje pravidla telefonní sazby pomocí rozhodovacího stromu. Rozhodovací strom je nejjednodušší ze všech metod, jak "postupovat dolů" a určit výsledek určitých podmínek. Z tohoto důvodu může být nejlepším znázorněním, které lze zákazníkovi ukázat. Bohužel je obtížné rozhodovací strom "sledovat", aby bylo možné určit, které podmínky vedou k určitým výsledkům. Tato obtížnost brání vidět způsoby, jak problém zjednodušit. Strom zastírá skutečnost, že další minuty stojí stejně, ať už obsluha pomáhá, nebo ne. Pro strom není možné vidět fakta.

Rozhodovací tabulka Rozhodovací tabulka, popsaná dále, poskytuje programátorovi a případně i zákazníkovi nejpoužitelnější grafické znázornění složených pravidel. Obrázek 2.5 ukazuje naše pravidla struktury sazby ve formě rozhodovací tabulky. Na obrázku 2.5 jsou tři dimenze: sleva ze sazby, zda zasahuje operátor a počáteční minuta vs. další minuta. Kreslení problémů s více než dvěma dimenzemi je poněkud složitější. Jak vidíte, tyto další dimenze lze na papíře znázornit jako poddimenze v rámci vnější dimenze. Všechny podmínky dílčích dimenzí

Rozhodovací strom

55

Obrázek 2.5: Rozhodovací tabulka.

se objevují v každé podmínce vnější dimenze. V softwaru lze snadno pracovat s libovolným počtem dimenzí, jak uvidíme. Všechny techniky, které jsme popsali, vás nutí analyzovat, které podmínky se vztahují ke kterým dimenzím. Při faktorizaci těchto dimenzí platí dvě pravidla: Za prvé, všechny prvky každé dimenze se musí vzájemně vylučovat. Do stejné dimenze nedáte "první minuta" a "přímá volba", protože se vzájemně nevylučují. Za druhé, v rámci každé dimenze musí být zohledněny všechny možnosti. Pokud by existovala další sazba pro hovory uskutečněné mezi 2:00 a 2:05, musela by se tabulka rozšířit. Naše rozhodovací tabulky však mají i další výhody samy o sobě. Rozhodovací tabulka se nejen dobře čte klientovi, ale ve skutečnosti přináší implementátorovi několik výhod: Přenositelnost do skutečného kódu. To platí zejména ve Forthu, kde se rozhodovací tabulky dají snadno implementovat ve formě velmi podobné výkresu. Možnost sledovat logiku směrem nahoru. Najít podmínku a zjistit, jaké faktory ji vyvolaly. Přehlednější grafické znázornění. Rozhodovací tabulky slouží jako lepší nástroj pro pochopení jak pro implementátora, tak pro analytika. Na rozdíl od rozhodovacích stromů tyto rozhodovací tabulky seskupují výsledky graficky smysluplným způsobem. Vizualizace myšlenek pomáhá při pochopení problémů, zejména těch, které jsou příliš složité na to, aby je bylo možné vnímat lineárním způsobem. Například obrázek 2.5 jasně ukazuje, že poplatek za další minuty nezávisí na tom, zda operátor asistoval, nebo ne. S tímto novým pochopením můžeme nakreslit zjednodušenou tabulku, jak je znázorněno na obrázku 2.6.

56

Analýza

Obrázek 2.6: Zjednodušená rozhodovací tabulka.

Je snadné se do svých analytických nástrojů tak zamilovat, že zapomeneme na problém. Analytik musí udělat víc než jen provést všechny možnosti problému na n-tém stupni, jak jsem viděl doporučovat autory knih o strukturované analýze. Tento přístup pouze zvyšuje množství dostupných detailů. Řešitel se musí také snažit problém zjednodušit. Tip Problému neporozumíte, dokud ho nedokážete zjednodušit.

2.10

Pokud je cílem analýzy nejen porozumění, ale i zjednodušení, pak nás možná čeká ještě hodně práce. Naše revidovaná rozhodovací tabulka (obrázek 2.6) ukazuje, že poplatek za kilometr závisí pouze na tom, zda je sazba plná, nižší nebo nejnižší. Jinými slovy, podléhá pouze jednomu ze tří rozměrů uvedených v tabulce. Co se stane, když tuto tabulku rozdělíme na dvě tabulky, jak je uvedeno na obrázku 2.7? Nyní získáme odpověď kombinací vyhledávání v tabulce a výpočtu. Vzorec pro minutový poplatek lze vyjádřit jako pseudodefinici: : PER-MINUTE-CHARGE ( -- per-minute-charge) CONNECT-CHARGE MILEAGE-CHARGE + ; Písmeno "+" se nyní v definici objevuje jednou, nikoli devětkrát v tabulce. Pokud princip výpočtu posuneme o krok dále, všimneme si (nebo si to zapamatujeme z původního zadání úlohy), že asistence operátora pouze přidává k celkovému poplatku jednorázový poplatek ve výši 0,90 EUR. V tomto smyslu není náboj operátora funkcí žádného ze tří rozměrů. Je vhodnější jej vyjádřit jako "logický výpočet"; to znamená funkci, která kombinuje logiku s aritmetikou:

Rozhodovací tabulka

57

Obrázek 2.7: Úseková rozhodovací tabulka.

: ?ASSISTANCE ( přímý-náklad -- celkový-náklad) OPERÁTOR? IF .90 + THEN ; (Nezapomeňte však, že tento poplatek se vztahuje pouze na první minutu.) Zůstává nám tedy zjednodušená tabulka na obrázku 2.8 a zvýšená závislost na vyjadřování výpočtů. Nyní se již někam dostáváme. Vraťme se k naší definici PER-MINUTE-CHARGE: : PER-MINUTE-CHARGE ( -- per-minute-charge) CONNECT-CHARGE MILEAGE-CHARGE + ; Obrázek 2.8: Zobrazená rozhodovací tabulka bez zapojení operátorů.

58

Analýza

Upřesněme si pravidla pro poplatek za připojení a pro poplatek za ujeté kilometry. Poplatek za připojení závisí na tom, zda se jedná o první nebo další minutu. Protože existují dva druhy minutových poplatků, bude asi nejjednodušší přepsat PER-MINUTE-CHARGE jako dvě různá slova. Předpokládejme, že vytvoříme komponentu, která bude z tabulky načítat příslušné sazby. Slovo 1MINUTA získá sazbu za první minutu; +MINUTY získá sazbu za každou další minutu. Obě tato slova budou záviset na denní době, která určí, zda se použijí plné, nižší nebo nejnižší sazby. Nyní můžeme definovat dvojici slov, která nahradí PER-MINUTE-CHARGE: : PRVNÍ ( -- poplatek) 1MINUTA ?POMOCNÁ MÍLE-CHARGE + ; : ZA DOPLNĚK ( -- poplatek) +MINUTY MÍLE-CHARGE + ; Jaké je pravidlo pro účtování kilometrů? Velmi jednoduché. Je to sazba (za sto mil) krát počet mil (ve stovkách). Předpokládejme, že můžeme definovat slovo MILEAGE-RATE, které z tabulky načte sazbu za ujeté kilometry: : MILEAGE-CHARGE ( -- charge) #MILES @ MILEAGE-RATE * ; Konečně, pokud známe celkový počet minut pro volání, můžeme nyní vypočítat celkový poplatek za přímou volbu: : CELKEM ( -- celkový poplatek) PRVNÍ ( #minut) 1PER-ADDITIONAL * + ;

( ( ( (

sazba za první minutu) další minuty) krát sazba) sečteno)

Pravidla pro tento konkrétní problém jsme vyjádřili kombinací jednoduchých tabulek a logických výpočtů. (Několik závěrečných poznámek k tomuto příkladu: Napsali jsme něco, co se velmi blíží běžící aplikaci Forth. Je to však pouze pseudokód. Vyhnuli jsme se manipulaci se zásobníkem tím, že jsme předpokládali, že hodnoty budou nějakým způsobem na zásobníku tam, kde je to uvedeno v komentářích. Také jsme použili názvy s pomlčkami, protože by mohly být pro zákazníka čitelnější. Ve skutečném kódu se dává přednost krátkým názvům - viz pátá kapitola). Hotový kód tohoto příkladu odhalíme v osmé kapitole.

Definování datových struktur Po definování rozhraní a někdy i pravidel bude občas potřeba definovat také určité datové struktury. Nemáme zde na mysli

Definování datových struktur

59

implementaci datových struktur, ale spíše na popis jejich koncepčního modelu. Pokud například automatizujete knihovní index, bude se rozhodující část vaší analýzy týkat vývoje logické datové struktury. Budete muset rozhodnout, jaké informace budou uchovávány pro každou knihu: název, autor, předmět atd. Tyto "atributy" budou tvořit "entitu" (množinu souvisejících záznamů) nazvanou KNIHY. Pak budete muset určit, jaké další datové struktury budou zapotřebí, aby uživatelé mohli v KNIHÁCH efektivně vyhledávat. Určitá omezení ovlivní i koncepční model datové struktury. V příkladu s knihovním indexem musíte vědět nejen to, jaké informace uživatelé potřebují, ale také jak dlouho jsou ochotni čekat, než je získají. Uživatelé mohou například požadovat seznamy témat podle roku vydání - řekněme vše o dámském prádle mezi lety 1900 a 1910. Pokud očekávají, že tyto informace získají lusknutím prstu, budete muset indexovat podle let a podle témat. Pokud mohou den počkat, můžete nechat počítač prohledat všechny knihy v knihovně.

Dosažení jednoduchosti Tip 2.11

Zachovejte jednoduchost.

Zatímco děláte tyto zásadní první kroky k pochopení problému, mějte na paměti staré rčení: Pokud jsou k dispozici dvě řešení problému, správné je to jednodušší.

To platí zejména při návrhu softwaru. Jednodušší řešení je často obtížnější objevit, ale jakmile je nalezeno, je: - jednodušší na pochopení - jednodušší na implementaci - jednodušší na ověření a ladění - jednodušší na údržbu - kompaktnější - efektivnější - zábavnější Jedním z nejpřesvědčivějších zastánců jednoduchosti je Moore:

60

Analýza

Jsou-li dána dvě adekvátní řešení, je správné to jednodušší.

Je třeba mít cit pro velikost problému. Kolik kódu by mělo být potřeba k implementaci dané věci? Jeden blok? Tři? Myslím, že je to velmi užitečný návrhový nástroj. Chcete mít vnitřní pocit, zda jde o triviální problém, nebo o velký problém, kolik času a úsilí byste na něj měli vynaložit. Až budete hotovi, ohlédněte se zpět a řekněte si: "Přišel jsem s řešením, které je rozumné?". Pokud vaše řešení zaplní šest obrazovek, může se zdát, že jste použili kladivo na zabití komára. Váš mentální obraz není úměrný významu problému. Viděl jsem programy pro jadernou fyziku se stovkami tisíc řádků jazyka FORTRAN. Ať už ten kód dělá cokoli, neopravňuje to ke stovkám tisíc řádků kódu. Jeho autoři pravděpodobně problém příliš zobecnili. Řešili velký problém, jehož skutečné potřeby jsou podmnožinou. Porušili zásadu, že řešení by mělo odpovídat problému.

Tip 2.12

Obecnost obvykle zahrnuje složitost. Nezobecňujte své řešení více, než bude potřeba; místo toho ho udržujte proměnlivé.

Moore pokračuje: Pokud je dán problém, můžete nakódovat jeho řešení. Poté, co jste to udělali a zjistili jste, že je to určité nepříjemné, můžete se vrátit a problém změnit a skončit s jednodušším řešením. Existuje třída optimalizace zařízení - minimalizace počtu hradel v obvodu - kde využíváte situace "nevadí". Ty nastávají buď proto, že daný případ v praxi nenastane, nebo proto, že je vám to opravdu jedno. Specifikace však často píší lidé, kteří nemají pro programování žádné pochopení. Návrhář možná pečlivě specifikoval všechny případy, ale vám, programátorům, neřekl, které případy jsou opravdu důležité. Pokud máte možnost se k němu vrátit, pohádat se s ním a využít "don't cares", můžete přijít s jednodušším řešením. Vezměte si strojírenskou aplikaci, například 75tunový lis na kovový prášek, který lisuje věci. Místo dříve používaného hydraulického ovládání chtějí instalovat počítač pro ovládání ventilů. Jakou specifikaci dostanete od inženýra? S největší pravděpodobností byly snímače umístěny kvůli pohodlí z elektromechanického hlediska. Nyní by mohly být umístěny jinde, ale inženýr na to zapomněl. Pokud budete požadovat vysvětlení, můžete se přiblížit reálnému světu a vzdálit se od jejich modelu světa. Dalším příkladem je algoritmus PID (proporcionální integrace a diferenciace) pro serva. Máte jeden člen, který integruje, druhý člen, který diferencuje, a třetí člen, který vyhlazuje. Ty kombinujete s 30 % integrace, 10 % diferenciace nebo jakkoli jinak. Ale je to jen digitální filtr. V analogových dobách bývalo výhodné vyčlenit určité členy digitálního filtru.

62

Analýza

filtru a říci: "Toto je integrátor a toto je diferenciátor. Tohle udělám kondenzátorem a tohle udělám induktorem." Tohle se dá udělat jenom tak. Autoři specifikací opět vymodelují analogové řešení, které modelovalo elektromechanické řešení, a jsou několik modelů vzdáleni od reality. Ve skutečnosti lze vše nahradit dvěma nebo třemi koeficienty v digitálním filtru a získat tak mnohem čistší, jednodušší a účinnější řešení.

Tip Vraťte se k tomu, jaký byl problém předtím, než se ho zákazník pokusil vyřešit. Využijte "nestará se".

2.13

Moore pokračuje: Někdy nejsou možnosti zjednodušení hned zřejmé. Je tu problém zvětšování digitalizovaného grafického zobrazení, například v systémech CAD. Máte na obrazovce obrázek a chcete si přiblížit jeho část, abyste viděli detaily. Kdysi jsem to implementoval tak, že jste přesunuli kurzor na místo zájmu, pak jste stiskli tlačítko a zvětšovalo se, dokud jste neměli okno požadované velikosti. Tak jsem to dělal vždycky. Dokud jsem si neuvědomil, že je to hloupost. Nikdy jsem nepotřeboval zoomovat s tak jemným rozlišením. Takže místo toho, abych kurzor posouval po pixelech, přeskakuji kurzor po jednotkách, řekněme po deseti. A místo abych zvětšoval velikost rámečku, skáču po jeho velikosti. Nemáte možnost volby velikosti. Zvětšujete o čtyřnásobek. Mezilehlé velikosti nejsou zajímavé. Můžete to udělat tolikrát, kolikrát chcete. Tím, že věci poměrně brutálně kvantifikujete, si usnadníte práci, budete lépe reagovat a zjednodušíte si práci.

Tip Chcete-li zjednodušit, kvantizujte.

2.14

Moore uzavírá: "Kvantifikujte: Chce to aroganci, abyste se vrátil a řekl: "Tohle jste opravdu nemyslel vážně." Nebo: "Vadilo by vám, kdybych tuto stránku smazal a nahradil ji tímto výrazem?". Rozčilují se. Chtějí, abyste udělali to, co vám řekli. LaFarr Stuart zaujal tento postoj, když předělával Forth [3]. Vstupní vyrovnávací paměť se mu nelíbila, a tak implementoval Forth bez ní a zjistil, že vstupní vyrovnávací paměť vlastně nepotřebuje. Pokud se vám podaří problém vylepšit, je to skvělá situace, do které se můžete dostat. Je mnohem zábavnější svět předělávat než ho implementovat.

Dosažení jednoduchosti

63

Příliš zobecněné řešení.

Efektivní programátoři se učí být taktní a formulovat své přístupy neohrožujícím způsobem: "Jaké důsledky by mělo nahrazení tohohle tímhle?" atd. Dalším způsobem, jak problém zjednodušit, je tento: Tip Chcete-li zjednodušit, vyvarujte se problémů s uživatelem.

2.15

Předpokládejme, že navrhujete část textového procesoru, který na obrazovce zobrazuje adresář uložených dokumentů, každý na jednom řádku. Plánujete, že uživatel bude moci přesunout kurzor vedle názvu libovolného dokumentu a poté zadat jednopísmenný příkaz označující zvolenou akci: "p" pro tisk, "e" pro editaci atd. Zpočátku se zdá být v pořádku nechat uživatele pohybovat kurzorem kdekoli na obrazovce. To znamená, že ta místa, kde se již text objevuje, musí být chráněna před přepsáním. To předpokládá koncept "chráněných polí" a speciální zacházení. Jednodušší přístup omezuje kurzor na určitá pole, případně používá reverzní video, aby uživatel viděl velikost povoleného pole. Jiný příklad nastane, když aplikace vyzve uživatele k zadání číselné hodnoty. Často se setkáte s takovými aplikacemi, které nekontrolují vstup, dokud nestisknete tlačítko "return", načež systém reaguje chybovou zprávou, například "neplatné číslo". Stejně snadné - pravděpodobně jednodušší - je kontrolovat každou klávesu při jejím zadávání a jednoduše nedovolit, aby se objevily jiné než číselné znaky. Tip Pro zjednodušení využijte to, co je k dispozici.

2.16

Michael LaManna, programátor Forthu z Long Islandu ve státě New York, komentuje: Vždy se snažím navrhovat aplikaci na nejvýkonnějším procesoru, který se mi dostane do rukou. Mám-li na výběr mezi vývojem na systému založeném na 68000 a na systému založeném na 6809, zvolím systém založený na 68000. Procesor je sám o sobě tak výkonný, že se postará o spoustu detailů, které bych jinak musel řešit sám. Pokud se budu muset později vrátit a přepsat části aplikace pro jednodušší procesor, nevadí. Alespoň nebudu ztrácet čas.

Jedno upozornění: Pokud používáte existující komponentu ke zjednodušení prototypu, nenechte komponentu ovlivnit váš návrh. Nechcete, aby návrh závisel na vnitřnostech komponenty.

Dosažení jednoduchosti

65

Sestavování rozpočtu a plánování Dalším důležitým aspektem fáze analýzy je stanovení ceny. Tento proces je opět mnohem obtížnější, než by se mohlo zdát. Pokud neznáte problém, dokud ho nevyřešíte, jak můžete vědět, jak dlouho bude trvat jeho vyřešení? Pečlivé plánování je nezbytné, protože věci vždy trvají déle, než očekáváte. Mám na to teorii založenou na zákonech pravděpodobnosti: Tip 2.17

Průměrná doba pro vytvoření "dvouhodinového" dodatku k aplikaci je přibližně 12 hodin.

Představte si následující scénář: Jste uprostřed psaní rozsáhlé aplikace, když vás najednou napadne přidat nějakou relativně jednoduchou funkci. Myslíte si, že to zabere asi dvě hodiny, a tak to bez dalšího plánování prostě uděláte. Uvažujte: To jsou dvě hodiny času na kódování. Čas návrhu nepočítáte, protože jste potřebu - a návrh - vnímali v záblesku geniality během práce na aplikaci. Odhadujete tedy dvě hodiny. Zvažte však následující možnosti: 1. Vaše implementace má chybu. Po dvou hodinách nefunguje. Takže strávíte další dvě hodiny překódováním. (Celkem 4.) 2. NEBO jste si před implementací uvědomili, že váš původní návrh nebude fungovat. Strávíte dvě hodiny přepracováváním návrhu. Tyto dvě hodiny se počítají. Plus další dvě hodiny kódování. (Celkem 4.) 3. NEBO jste implementovali první návrh dříve, než jste si uvědomili, že by návrh nefungoval. Takže znovu navrhnete (další dvě hodiny) a znovu implementujete (další dvě hodiny). (Celkem 6.) 4. NEBO implementujete první návrh, nakódujete ho, najdete chybu, přepíšete kód, najdete chybu v návrhu, přepracujete návrh, překódujete, najdete chybu v novém kódu, znovu překódujete. (Celkem 10.) Vidíte, jak se to nabaluje? 5. Nyní musíte novou funkci zdokumentovat. K výše uvedenému si připočtěte dvě hodiny. (Celkem 12.) 6. Poté, co jste strávili 2 až 12 hodin instalací a laděním své nové funkce, najednou zjistíte, že prvek Y vaší aplikace vybuchuje. A co je nejhorší, nemáte tušení proč. Strávíte dvě hodiny čtením výpisů paměti a snažíte se zjistit příčinu. Jakmile se vám to podaří, strávíte dalších 12 hodin přepracováváním prvku Y. (Celkem 26.) Pak musíte zdokumentovat změnu syntaxe, kterou jste v prvku Y provedli. (Celkem 27.)

66

Analýza

Konvenční moudrost ctí složitost.

To je celkem více než tři člověkodny. Kdyby vás všechny tyto nezdary potkaly najednou, zavolali byste muže v malých bílých pláštích. Takhle zle je to samozřejmě málokdy, ale pravděpodobnost, že jakýkoli projekt bude tak snadný, jak si myslíte, rozhodně není. Jak můžete zvýšit své šance na správné posouzení časových požadavků? Na toto téma bylo napsáno mnoho krásných knih, zejména Mýtický měsíc člověka od Fredericka P. Brookse, Jr. [4]. K tomuto souboru poznatků nemám příliš co dodat, kromě několika osobních postřehů. 1. Neodhadujte celkový počet. Rozdělte problém na co nejmenší části a pak odhadněte čas pro každou část. Součet dílků je vždy větší, než kolik byste odhadli, že bude celkový součet. (Celek se jeví menší než součet částí.) 2. Vždy se snažte zjistit, zda je to správně. Při rozepisování jednotlivých částí oddělte ty, kterým rozumíte natolik dobře, abyste je mohli odhadnout, od těch, kterým nerozumíte. U druhé kategorie uveďte zákazníkovi rozmezí. 3. Trocha psychologie: vždy dejte zákazníkovi na výběr. Klienti mají rádi možnosti. Pokud řeknete: "Tohle vás bude stát 6 000 dolarů," klient pravděpodobně odpoví: "Opravdu bych rád utratil 4 000 dolarů." Pokud se klient rozhodne, že bude chtít utratit více, bude to pro něj velmi obtížné. To vás staví do pozice, kdy buď nabídku přijmete, nebo zůstanete bez práce. Pokud však řeknete: "Máte na výběr: za 4 000 dolarů to nechám projít obručí; za 6 000 dolarů to nechám proskočit obručí. Za 8 000 dolarů ho donutím tančit skrz obruč, mávat vlajkami, házet konfety a zpívat "Roll Out the Barrel". Většina zákazníků se rozhodne pro proskakování obručí. Tip 2.18

Všechno trvá déle, než si myslíte, včetně přemýšlení.

Přezkoumání koncepčního modelu Poslední políčko na našem iteračním analytickém kole je označeno jako "Ukázat model zákazníkovi". S nástroji, které jsme popsali v této kapitole, by tato práce měla být snadná. Při dokumentování specifikace požadavků nezapomeňte, že specifikace jsou jako sněhuláci. Nyní mohou být zmrzlé, ale když se rozžhaví, posunou se, sklouznou a roztají. Ať už zvolíte diagramy toku dat nebo rovnou pseudokód jazyka Forth, připravte se na velké tání tím, že nezapomenete použít koncepty omezené redundance. Ukažte zdokumentovaný koncepční model zákazníkovi. Když je zákazník konečně spokojen, jste připraveni na další velký krok: návrh!

68

Analýza

Odkazy [1] Kim Harris, "The Forth Philosophy", Dr. Dobb's Journal, Vol. 6, Iss. 9, č. 59 (září 81), s. 6-11. [2] Victor Weinberg, Structured Analysis (Strukturovaná analýza), Englewood Cliffs, N.J.: PrenticeHall, Inc., 1980. [3] LaFarr Stuart, "LaFORTH", sborník FORML 1980, str. 78. [4] Frederick P. Brooks, Jr, The Mythical Man-Month, Reading, Massachusetts, Addison-Wesley, 1975.

Odkazy:

69

TŘI

Předběžný návrh/rozklad

Za předpokladu, že máte určitou představu o tom, čeho by měl váš program dosáhnout, je čas začít s návrhem. První fáze, předběžný návrh, se zaměřuje na zmenšení vašeho hornatého problému na zvládnutelné krtince. V této kapitole probereme dva způsoby dekompozice vaší aplikace Forth.

Dekompozice podle komponent Stalo se vám někdy něco podobného? Už tři měsíce plánujete víkendovou dovolenou na horách. Sestavovali jste seznamy, co si vzít s sebou, a snili jste o sjezdovkách. Mezitím se rozhodujete, co si vezmete na sebe na svatbu své sestřenice příští sobotu. Jsou to neformální typy a ty to nechceš přehánět s oblečením. Přesto je svatba jako svatba. Možná by sis měl stejně půjčit smoking. Při všem tom plánování si teprve ve čtvrtek uvědomíš, že se obě události shodují. Pro takové chvíle máš připravené výrazy. Jak je možné, že u tak inteligentního člověka, jako jsi ty, dojde k takovému mentálnímu selhání? Lidská mysl zřejmě skutečně vytváří vazby mezi vzpomínkami. Nové myšlenky se nějakým způsobem přidávají k již existujícím cestám souvisejících myšlenek. Obrázek 3.1: Půdy myšlenek, které ještě nejsou propojeny

72

Předběžný návrh/dekompozice

V právě popsaném neštěstí nedošlo až do čtvrtka k žádnému spojení mezi dvěma samostatně propojenými myšlenkovými pooly. Ke konfliktu pravděpodobně došlo, když se nějaký nový vstup (něco tak triviálního, jako bylo vyslechnutí sobotní zprávy o počasí) propojil do obou myšlenkových poolů. Mezi oběma skupinami se objevil blesk uvědomění, po němž neúprosně následovala hromová panika. Byl vynalezen jednoduchý nástroj, jak takovým katastrofám předejít. Jmenuje se kalendář. Kdybyste si oba plány zaznamenali do stejného kalendáře, viděli byste naplánovanou druhou událost, což váš mozek při vší své složité velkoleposti nedokázal. Tip Chcete-li vidět vztah mezi dvěma věcmi, dejte je blízko k sobě. Chcete-li si tento vztah připomenout, mějte je pohromadě.

3.1

Tyto truismy platí pro návrh softwaru, zejména pro fázi předběžného návrhu. V této fázi návrhář tradičně rozčleňuje rozsáhlou aplikaci na menší, programátorské moduly. V první kapitole jsme zjistili, že aplikace lze vhodně rozložit na komponenty. Tip Cílem předběžného návrhu je určit, jaké komponenty jsou nutné k naplnění požadavků.

3.2

Můžete mít například aplikaci, ve které musí události probíhat podle nějakého předem stanoveného plánu. Pro řízení rozvrhu můžete nejprve navrhnout několik slov, která budou tvořit "lexikon pro tvorbu rozvrhu". Pomocí těchto slov budete moci popsat pořadí událostí, které musí v aplikaci nastat. V rámci jedné komponenty tak budete nejen sdílet informace, ale také řešit případné konflikty. Špatným přístupem by bylo nechat každý funkční modul "vědět" věci o svém plánu, které by mohly potenciálně kolidovat s plánem jiného modulu. Jak můžete při návrhu komponenty vědět, jaké příkazy budou potřebovat komponenty, které ji používají? Je třeba přiznat, že se jedná o problém typu "slepice vs. vejce". Ale programátoři Forthu ho řeší stejně jako slepice a vejce: iterativně. Pokud je komponenta dobře navržena, na úplnosti nezáleží. Ve skutečnosti stačí, aby komponenta stačila pro návrh aktuální iterace. Žádná komponenta by neměla být považována za "uzavřenou knihu", dokud není aplikace dokončena - což v případě udržovaných aplikací není nikdy. Jako příklad si představte, že váš produkt potřebuje "komunikovat" s jinými stroji ve vnějším světě prostřednictvím univerzálního I/O čipu, který je součástí vašeho systému. Tento konkrétní čip má "řídicí registr" a "datový registr". V

Rozklad podle složek

73

špatně navržené aplikaci by části kódu v celém programu přistupovaly ke komunikačnímu čipu prostým vyvoláním instrukce OUT, která by vložila příslušný příkazový bajt do příkazového registru. Tím se celá aplikace stává zbytečně závislou na tomto konkrétním čipu - což je velmi riskantní. Místo toho by programátoři jazyka Forth napsali komponentu, která by ovládala vstupně-výstupní čip. Tyto příkazy by měly logická jména a vhodné rozhraní (obvykle zásobník jazyka Forth), které by umožnilo jejich použití zbytkem aplikace. Pro každou iteraci návrhu vašeho produktu byste implementovali pouze příkazy, které jsou zatím potřebné - ne všechny platné kódy, které by bylo možné poslat do "řídicího registru". Pokud byste později v průběhu projektového cyklu zjistili, že potřebujete další příkaz, například příkaz pro změnu přenosové rychlosti, nový příkaz by byl přidán do lexikonu I/O čipu, nikoli do kódu potřebného pro nastavení přenosové rychlosti. Za provedení této změny nehrozí žádné sankce kromě několika minut (maximálně), které zabere úprava a překompilování. Tip 3.3

V rámci každé komponenty implementujte pouze příkazy potřebné pro aktuální iteraci. (Nevylučujte však budoucí doplnění.)

Co se děje uvnitř komponenty, je do značné míry její vlastní záležitost. Není nutně špatným stylem, aby definice uvnitř komponenty sdílely nadbytečné informace. Například záznam v určité datové struktuře má čtrnáct bajtů. Jedna definice v komponentě posune ukazatel o 14 bajtů, aby ukazoval na další záznam; jiná definice tento ukazatel o 14 bajtů sníží. Dokud toto číslo 14 zůstane "tajemstvím" komponenty a nebude použito jinde, nemusíte ho definovat jako konstantní. Stačí použít číslo 14 v obou definicích: : +Na druhou stranu, pokud bude hodnota potřebná mimo komponentu nebo pokud se v rámci komponenty používá několikrát a je velká pravděpodobnost, že se bude měnit, je lepší ji skrýt za jméno: 14 CONSTANT /RECORD : +RECORD /RECORD RECORD# +!! ; : -RECORD /RECORD NEGATE RECORD# +! ; (Název /RECORD podle konvence znamená "bajty na záznam".)

Příklad: Pojďme aplikovat rozklad podle komponent na skutečný problém. Bylo by hezké navrhnout velkou aplikaci přímo zde ve třetí kapitole, ale bohužel to neuděláme.

74

Předběžný návrh/rozklad

máme prostor a kromě toho bychom se dostali na vedlejší kolej ve snaze pochopit aplikaci. Místo toho si vezmeme komponentu z velké aplikace, která již byla dekomponována. Tuto komponentu navrhneme tak, že ji dále rozložíme na dílčí komponenty. Představme si, že musíme vytvořit malý editor, který umožní uživatelům měnit obsah vstupních polí na obrazovce terminálu. Obrazovka může vypadat například takto: Jméno člena

Justine Čas

Editor bude uživatelům poskytovat tři režimy pro změnu obsahu vstupního pole: Přepsat. Zadáním běžných znaků se přepíší všechny znaky, které tam byly předtím. Odstranění. Stisknutím kombinace kláves "Ctrl D" se smaže znak pod kurzorem a zbývající znaky se posunou doleva. Vložení. Stisknutím kombinace kláves "Ctrl I" se editor přepne do režimu "Vložení", kdy se následným psaním běžných znaků vloží na pozici kurzoru a zbývající znaky se posunou doprava. V rámci konceptuálního modelu bychom měli uvažovat také o ošetření chyb nebo výjimek; například jaká je hranice pole, co se stane v režimu vkládání, když se znaky rozsypou vpravo atd. To je veškerá specifikace, kterou nyní máme k dispozici. Zbytek je na nás. Pokusme se určit, jaké komponenty budeme potřebovat. Za prvé, editor bude reagovat na klávesy, které jsou napsány na klávesnici. Proto budeme potřebovat interpret kláves - nějakou rutinu, která čeká na stisky kláves a přiřazuje je k seznamu možných operací. Interpret kláves je jedna komponenta a její lexikon se bude skládat z jediného slova. Protože toto slovo bude umožňovat editaci pole, nazvěme ho EDIT. Operace vyvolané interpretem kláves budou tvořit druhý lexikon. Definice v tomto lexikonu budou provádět různé požadované funkce. Jedno slovo se může jmenovat DELETE, jiné INSERT atd. Protože každý z těchto příkazů bude vyvolán interpretem, každý z nich bude zpracovávat jeden stisk klávesy. Pod těmito příkazy by měla ležet třetí složka, sada slov, která implementují upravovanou datovou strukturu. Nakonec budeme potřebovat komponentu pro zobrazení pole na obrazovce videa. Pro zjednodušení počítejme s vytvořením pouze jednoho slova, REDISPLAY, které po každém stisknutí klávesy znovu zobrazí celé pole. : EDITOR

BEGIN

KEY

REVISE

REDISPLAY ... UNTIL ;

Příklad: Drobný editor

75

Obrázek 3.2: Zobecněná dekompozice problému Tiny Editor.

Tento přístup odděluje revizi vyrovnávací paměti od aktualizace zobrazení. Prozatím se zaměříme pouze na revizi vyrovnávací paměti. Podívejme se na každou komponentu zvlášť a pokusme se určit, jaká slova bude každá z nich potřebovat. Můžeme začít úvahou o událostech, které musí nastat v rámci tří nejdůležitějších editačních funkcí: přepisování, mazání a vkládání. Na zadní stranu starého menu pizzy bychom mohli nakreslit něco podobného (zpracování výjimek nebudeme v této diskusi věnovat velkou pozornost): Přepsat: Uložit nový znak do ukazatele na bajt podle ukazatele. Posunout ukazatel (pokud není na konci pole).

76

F U N K C I O N A L I T Y ˆ F U N K C I O N A L I T Y ˆ T I O N A L I T Y ˆ F U N K C I O N A L I T Y ˆ

Vymazání: V případě, že se jedná o výmaz, je třeba vymazat: Zkopírujte doleva o jedno místo řetězec začínající o jedno místo vpravo od ukazatele. Na poslední místo řádku uložte "prázdné místo".

F U N K C I O N Á L N Í A L I T Y ˆ F U N K C I O N Á L N Í A L I T Y ˆ F U N K C I O N Á L N Í A L I T Y ˆ

Vložení: Zkopírujte o jedno místo doprava řetězec začínající u ukazatele. Uložte nový znak do bajtu, na který ukazuje ukazatel. Posuňte ukazatel dopředu (pokud není na konci pole).

F F F F

Předběžný návrh/rozklad

U U U U

N N N N

T ˆ T ˆ C ˆ C

I T T T ˆ

O I I I

N O O O

A N N N

L A A A

I L L L

T I I I

Y T Y T Y T Y T Y

Právě jsme vyvinuli algoritmy pro daný problém. Naším dalším krokem je prozkoumat tyto tři základní postupy a hledat užitečná "jména" - tedy postupy nebo prvky, které mohou buď: Zjistíme, že všechny tři procedury používají něco, čemu se říká "ukazatel". Potřebujeme dvě procedury: 1. pro získání ukazatele (pokud je ukazatel sám o sobě relativní, provede tato funkce nějaký výpočet). 2. pro posunutí ukazatele Počkejte, tři procedury: 3. pro posunutí ukazatele dozadu, protože budeme chtít "kurzorové klávesy", které budou posunovat kurzor dopředu a dozadu, aniž by došlo ke změnám v editaci. Všechny tyto tři operátory budou odkazovat na fyzický ukazatel někde v paměti. Kde je uložen a jak (relativně nebo absolutně), by mělo být skryto v rámci této komponenty. Pokusme se tyto algoritmy přepsat do kódu: : : : : : : :

KEY# ( vrací hodnotu naposledy stisknuté klávesy ) ... ; POSITION ( vrací adresu znaku, na který ukazuje) ; FORWARD ( posunutí ukazatele vpřed, zastavení na poslední pozici) ; BACKWARD ( dekrementace ukazatele, zastavení na první pozici) ; OVERWRITE KEY# POSITION C! VPŘED ; VLOŽIT SNÍMEK> PŘEPSAT ; SMAZAT SNÍMEK< PRÁZDNÝ KONEC ;

Pro kopírování textu doleva a doprava jsme museli za pochodu vymyslet dva nové názvy SLIDE< a SLIDE> (vyslovuje se "slide-backwards", respektive "slideforwards"). Obě jistě budou používat POSITION, ale musí se také spoléhat na prvek, jehož zvažování jsme odložili: na způsob, jak "poznat" délku pole. Tímto aspektem se můžeme zabývat, až se dostaneme k psaní třetí komponenty. Podívejte se však na to, co jsme již zjistili: "Insert" můžeme popsat jednoduše jako "SLIDE> OVERWRITE". Jinými slovy, "Insert" ve skutečnosti používá "Overwrite", i když se zdá, že existují na stejné úrovni (alespoň pro strukturovaného programátora). Namísto hlubší sondy do třetí komponenty vyložme, co víme o první komponentě, tedy o klíčovém interpretu. Nejprve musíme vyřešit problém "vkládacího režimu". Ukázalo se, že "insert" není jen tak něco

Příklad: "Vložení" je v podstatě "vložení": Drobný editor

77

co se stane po stisknutí určité klávesy, jako je tomu u mazání. Místo toho se jedná o jiný způsob interpretace některých možných stisků kláves. Například v režimu "přepsání" se obyčejný znak uloží na aktuální pozici kurzoru; ale v režimu "vložení" se musí zbytek řádku nejprve posunout doprava. A také klávesa backspace funguje jinak, když je editor v režimu vkládání. Protože existují dva režimy, "vkládání" a "nevkládání", musí interpret kláves přiřadit klávesám dvě možné sady pojmenovaných postupů. Interpret kláves můžeme zapsat jako rozhodovací tabulku (o implementaci se budeme starat později): klávesa Ctrl-D Ctrl-I backspace levá šipka pravá šipka návrat libovolná tisknutelná

Nevkládání DELETE INSERT-ON BACKWARD BACKWARD FORWARD ESCAPE OVERWRITE

Vkládání INSERT-OFF INSERT-OFF INSERT< INSERT-OFF INSERT-OFF INSERT-OFF INSERT-OFF INSERT

Do levého sloupce jsme umístili možné typy kláves, do prostředního sloupce to, co dělají normálně, a do pravého sloupce to, co dělají v "režimu vkládání". Abychom implementovali, co se stane, když v režimu vkládání stiskneme klávesu "backspace", přidáme novou proceduru: : INSERT<

BACKWARD

SLIDE< ;

(posuneme kurzor dozadu na vrchol posledního napsaného znaku a pak vše posuneme doprava doleva, čímž zakryjeme chybu). Tato tabulka se jeví jako nejlogičtější vyjádření problému na současné úrovni. Implementaci si necháme na později (osmá kapitola). Nyní si ukážeme obrovskou hodnotu tohoto přístupu z hlediska udržovatelnosti. Hodíme si klacík pod nohy - zásadní změnu plánů!

Údržba aplikace založené na komponentách Jak dobře si náš návrh povede tváří v tvář změnám? Představte si následující scénář: Původně jsme předpokládali, že můžeme obnovit zobrazení videa jednoduše tak, že při každém stisknutí klávesy znovu napíšeme pole. Dokonce jsme tento kód implementovali na našem osobním počítači s videem mapovaným v paměti, které obnoví celý řádek během jednoho snímacího cyklu. Nyní však náš zákazník chce, aby aplikace běžela v telefonní síti, přičemž všechny vstupy a výstupy se provádějí nepříliš rychlou přenosovou rychlostí. Protože některá naše vstupní pole jsou téměř stejně široká jako

78

Předběžný návrh/dekompozice

videoobrazovky, třeba 65 znaků, trvá obnovení celého řádku při každém stisku klávesy příliš dlouho. Musíme změnit aplikaci tak, abychom obnovovali pouze tu část pole, která se skutečně mění. V položkách "vložit" a "odstranit" by to znamenalo text napravo od kurzoru. V případě "přepsat" by to znamenalo změnit pouze jediný přepisovaný znak. Tato změna je významná. Funkce obnovení videa, kterou jsme bezstarostně odsunuli do interpretu kláves, nyní musí záviset na tom, které editační funkce se vyskytují. Jak jsme zjistili, nejdůležitější jména potřebná k implementaci interpretu kláves jsou: Žádný z jejich popisů se nezmiňuje o procesu obnovení videa, protože se původně předpokládalo, že k němu dojde později. Věci však nejsou tak špatné, jak se zdá. Když se na to podíváme nyní, proces OVERWRITE by mohl snadno obsahovat příkaz pro zadání nového znaku v místě, kde se nachází kurzor terminálu. A příkazy SLIDE< a SLIDE> by mohly obsahovat příkazy pro zadání všeho napravo od příkazu POSITION a včetně tohoto příkazu, a pak resetovat kurzor terminálu na jeho aktuální pozici. Zde jsou naše upravené názvy procedur. Právě přidané příkazy jsou vyznačeny tučným písmem: : PŘEPSAT KLÁVESU# POZICE C! KEY# EMIT FORWARD ; : RETYPE ( napište od aktuální pozice na konec pole a resetujte kurzor) ; : INSERT SLIDE> RETYPE OVERWRITE ; : DELETE SLIDE< BLANK-END RETYPE ; Protože jsou to jediné tři funkce, které mění paměť, jsou to jediné tři funkce, které potřebují obnovit obrazovku. Tato myšlenka je rozhodující. Abychom zajistili správnost programu, musíme být schopni taková tvrzení učinit. Toto tvrzení je vlastní povaze problému. Všimněte si, že dodatečný problém obnovení videa přidává další "ukazatel": aktuální pozici kurzoru na obrazovce. Rozklad podle komponent nás však podnítil k tomu, abychom proces OVERWRITE vnímali jako změnu jak datového pole, tak jeho videozobrazení; podobně je tomu i u SLIDE< a SLIDE>. Z tohoto důvodu se nyní zdá přirozené udržovat pouze jeden skutečný ukazatel - relativní, z něhož můžeme vypočítat buď adresu dat v paměti, nebo číslo sloupce na obrazovce.

Udržování aplikace založené na komponentách

79

Protože povaha ukazatele je zcela skryta v rámci tří procesů POSITION, FORWARD a BACKWARD, můžeme se s tímto přístupem snadno vyrovnat, i když to nebyl náš první přístup. Tato změna se zde mohla zdát dostatečně jednoduchá - dokonce zřejmá. Pokud ano, je to proto, že tato technika zajišťuje flexibilní návrh. Kdybychom použili tradiční přístup - kdybychom navrhovali podle struktury nebo podle transformace dat prostřednictvím sekvenčních procesů -, náš křehký návrh by se touto změnou rozbil. Abychom toto tvrzení dokázali, museli bychom začít znovu od nuly.

Návrh a údržba tradiční aplikace Předstírejme, že jsme dosud nestudovali problém Drobného editoru a máme opět minimální sadu specifikací. Začneme také s naším původním předpokladem, že můžeme obnovovat zobrazení tím, že po každém stisku klávesy znovu napíšeme celé pole. Podle diktátu návrhu shora dolů zaujměme co nejširší úhel pohledu a prozkoumejme problém. Obrázek 3.3 znázorňuje program v jeho nejjednodušší podobě. Zde jsme si uvědomili, že editor je vlastně smyčka, která neustále přijímá stisky kláves a provádí nějakou editační funkci, dokud uživatel nestiskne klávesu return. Uvnitř smyčky máme tři moduly: získání znaku z klávesnice, editaci dat a nakonec obnovení zobrazení tak, aby odpovídalo datům. Je zřejmé, že většina práce bude probíhat uvnitř "Zpracování stisku klávesy". Při použití pojmu postupného zpřesňování ukazuje obrázek 3.4 problém editoru překreslený s rozšířeným "Process a Keystroke". Zjistíme, že než dospějeme k této konfiguraci, je třeba několika pokusů. Návrh této úrovně nás nutí Obrázek 3.3: Tradiční přístup: pohled shora.

80

Předběžný návrh/dekompozice

Obrázek 3.4: Struktura pro "Zpracování stisku klávesy".

uvažovat o mnoha věcech najednou, které jsme v předchozím pokusu odložili na později. Například musíme určit všechny klávesy, které by mohly být stisknuty. Ještě významnější je, že musíme zvážit problém "režimu vkládání". Toto zjištění nás nutí vymyslet příznak nazvaný INSERT-MODE, který se přepíná klávesou "Ctrl I". Používá se v rámci několika strukturních řádků k určení způsobu zpracování daného typu klávesy. Druhý příznak, nazvaný ESCAPE, zřejmě poskytuje pěkný strukturovaný způsob, jak uniknout ze smyčky editoru, pokud uživatel stiskne klávesu Return, zatímco není v režimu vkládání. Po dokončení schématu nás trápí vícenásobné testy pro režim vkládání. Mohli bychom testovat režim Vložení jen jednou, na začátku? Podle této představy nakreslíme ještě jeden diagram (obrázek 3.5).

Návrh a údržba tradiční aplikace

81

Obrázek 3.5: Další struktura pro "Zpracování stisku klávesy".

Jak vidíte, dopadá to ještě nešikovněji než první obrázek. Nyní testujeme každou klávesu dvakrát. Je však zajímavé, jak jsou obě struktury naprosto odlišné, a přesto funkčně ekvivalentní. Je to dost na to, aby se člověk zamyslel nad tím, zda je struktura ovládání pro tento problém strašně důležitá. Poté, co jsme se rozhodli pro první strukturu, jsme konečně dospěli k nejdůležitějším modulům - těm, které vykonávají práci při přepisování, vkládání a mazání. Podívejte se ještě jednou na naše rozšíření "Zpracovat znak" na obrázku 3.4. Uvažujme pouze jednu ze sedmi možných cest provedení, tu, která nastane, pokud je stisknut tisknutelný znak. Na obrázku 3.6(a) vidíme původní konstrukční cestu pro tisknutelný znak. Jakmile zjistíme algoritmy pro přepisování a vkládání znaků, mohli bychom ji zpřesnit, jak ukazuje obrázek 3.6(b). Ale podívejte se na tu trapnost

82

Předběžný návrh/rozklad

Obrázek 3.6: Stejný úsek, "vylepšený" a "optimalizovaný".

redundance kódu (zakroužkované části). Většina schopných strukturovaných programátorů by rozpoznala, že tato redundance je zbytečná, a změnila by strukturu podle obrázku 3.6 c). Zatím to není špatné, že?

Změna plánu Dobrá, všichni se teď chovejte překvapeně. Právě jsme se dozvěděli, že tato aplikace nepoběží na displeji s paměťovým mapováním. Co tato změna udělá s naší konstrukční strukturou? No, zaprvé to zničí "Obnovení displeje" jako samostatný modul. Funkce modulu "Obnovit displej" je nyní rozptýlena mezi různými strukturálními řádky uvnitř modulu "Zpracovat stisk klávesy". Struktura celé naší aplikace se změnila. Je snadné pochopit, jak jsme mohli strávit týdny návrhem shora dolů, abychom zjistili, že jsme štěkali na špatný strom. Co se stane, když se pokusíme program změnit? Podívejme se znovu na cestu pro libovolný tisknutelný znak.

Změna plánu

83

Obrázek 3.7: Přidání obnovení.

Obrázek 3.7 (a) ukazuje, co se stane s naším návrhem prvního průchodu, když přidáme obnovení. Část (b) ukazuje náš "optimalizovaný" návrh s rozšířenými moduly obnovení. Všimněte si, že nyní testujeme příznak Insert dvakrát v rámci tohoto jediného ramene vnější smyčky. Co je však horší, v tomto návrhu je chyba. Dokážete ji najít? V obou případech, přepisování i vkládání, je ukazatel inkrementován před obnovením. V případě přepisu zobrazujeme nový znak na špatné pozici. V případě vložení vypisujeme zbytek řádku, ale ne nový znak. Připouštíme, že tento problém lze snadno odstranit. Stačí, když moduly obnovení přesuneme nahoru před "Ukazatel přírůstku". Jde o to, že Jak jsme to mohli přehlédnout? Tím, že jsme se začali zabývat strukturou toku řízení, povrchním prvkem návrhu programu.

84

Předběžný návrh/dekompozice

Naproti tomu v našem návrhu pomocí komponent správné řešení vypadlo přirozeně, protože jsme "použili" komponentu refresh uvnitř komponenty editing. Také jsme použili OVERWRITE uvnitř INSERT. Rozložením naší aplikace na komponenty, které se navzájem používají, jsme dosáhli nejen elegance, ale i přímější cesty ke správnosti.

Komponenta rozhraní V terminologii informatiky má rozhraní mezi moduly dva aspekty. Za prvé je to způsob, jakým ostatní moduly modul volají; to je řídicí rozhraní. Za druhé je to způsob, jakým ostatní moduly předávají a přijímají data do modulu a z modulu; to je datové rozhraní. Vzhledem ke slovníkové struktuře jazyka Forth se o řízení nejedná. Definice se vyvolávají tím, že jsou pojmenovány. Když v této části používáme termín "rozhraní", máme na mysli data. Pokud jde o datová rozhraní mezi moduly, tradiční moudrost říká pouze to, že "rozhraní by měla být pečlivě navržena s minimální složitostí". Důvodem této opatrnosti je samozřejmě to, že každý modul musí implementovat svůj vlastní konec rozhraní (obrázek 3.8). To znamená přítomnost nadbytečného kódu. Jak jsme viděli, redundantní kód přináší přinejmenším dva problémy: objemný kód a špatnou udržovatelnost. Změna rozhraní jednoho modulu ovlivní rozhraní modulu opačného. Obrázek 3.8: Tradiční pohled na rozhraní jako na křižovatku.

Dobrý návrh rozhraní toho však obsahuje více. Dovolte mi představit prvek návrhu, který nazývám "komponenta rozhraní". Účelem komponenty rozhraní je implementovat a skrývat informace o datovém rozhraní mezi dvěma nebo více jinými komponentami (obrázek 3.9).

Komponenta rozhraní

85

Obrázek 3.9: Použití komponenty rozhraní.

Tip 3.4

Datové struktury i příkazy zapojené do komunikace dat mezi moduly by měly být lokalizovány v komponentě rozhraní.

Uvedu příklad z vlastní nedávné zkušenosti. Jedním z mých koníčků je psaní textových formátovačů/editorů. (Napsal jsem dva, včetně toho, na kterém píšu tuto knihu). V mém posledním návrhu obsahuje část formátovače dvě komponenty. První komponenta čte zdrojový dokument a rozhoduje o tom, kde se provedou zalomení řádků a stránek atd. Ale místo toho, aby text odesílala přímo do terminálu nebo na tiskárnu, ukládá po řádcích do "řádkové vyrovnávací paměti". Stejně tak místo odesílání příkazů pro ovládání tiskárny - tučné písmo, podtržení atd. - v průběhu formátování textu odkládá tyto příkazy až do doby, kdy je text skutečně odeslán. Pro odložení řídicích příkazů mám druhou vyrovnávací paměť nazvanou "atributová vyrovnávací paměť". Odpovídá bajt po bajtu řádkovému bufferu s tím rozdílem, že každý bajt obsahuje sadu příznaků, které udávají, zda má být příslušný znak podtržený, tučně zvýrazněný nebo jiný. Druhá komponenta zobrazuje nebo tiskne obsah řádkového bufferu. Komponenta ví, zda přenáší na terminál, nebo na tiskárnu, a vypíše text podle atributů uvedených v atributovém bufferu. Máme zde dvě dobře definované komponenty - řádkový formátovač a výstupní komponentu - každá z nich přebírá část funkce formátovače jako celku. Datové rozhraní mezi těmito dvěma komponentami je poměrně složité. Rozhraní se skládá ze dvou vyrovnávacích pamětí, proměnné, která udává aktuální počet políček.

86

Předběžný návrh/dekompozice

platných znaků, a konečně "znalosti" toho, co všechny tyto vzory atributů znamenají. Ve Forthu jsem tyto prvky definoval společně v jediné obrazovce. Vyrovnávací paměti jsou definovány pomocí CREATE, počet je obyčejná PROMĚNNÁ a vzory atributů jsou definovány jako KONSTANTY, např: 1 CONSTANT UNDERNESS ( bitová maska pro podtržení) 2 CONSTANT BOLDNESS ( bitová maska pro tučné písmo) Formátovací komponenta používá výrazy jako UNDERNESS SET-FLAG pro nastavení bitů v bufferu atributů. Výstupní komponenta používá fráze jako UNDERNESS AND ke čtení atributového bufferu.

Chyba návrhu Při návrhu komponenty rozhraní byste si měli položit otázku: "Jaká je množina struktur a příkazů, které musí komunikující komponenty sdílet?". Je důležité určit, které prvky patří do rozhraní a které by měly zůstat v rámci jedné komponenty. Při psaní svého textového formátovače jsem si na tuto otázku nedokázal plně odpovědět a zjistil jsem, že mám chybu. Problém byl následující: Povolím použití různých šířek písma: zhuštěné, s dvojitou šířkou atd. To znamená nejen posílat tiskárně různé signály, ale také měnit počet povolených znaků na řádek. Pro formátovač udržuji proměnnou nazvanou WALL. WALL označuje pravý okraj: bod, za který už nelze nastavit žádný další text. Změna na jinou šířku písma znamená úměrnou změnu hodnoty WALL. (Ve skutečnosti se to ukazuje jako chyba sama o sobě. Měl bych používat jemnější měrnou jednotku, jejíž počet zůstává pro řádek konstantní. Změna šířky písma by znamenala změnu počtu jednotek na znak. Ale zpět k dané chybě. . . ) Bohužel jsem také uvnitř výstupní komponenty používal WALL, abych určil, kolik znaků se má zobrazit. Moje úvaha byla taková, že tato hodnota se bude měnit v závislosti na tom, jakou šířku písma používám. V 99 % případů jsem měl pravdu. Jednoho dne jsem však zjistil, že za určitých podmínek se řádek zhuštěného textu nějak zkracuje. Posledních pár slov prostě chybělo. Ukázalo se, že příčinou bylo to, že se WALL měnil dříve, než ho výstupní komponenta stihla použít. Původně jsem neviděl nic špatného na tom, že jsem výstupní komponentu nechal bleskově používat i WALL formátovače. Nyní jsem si uvědomil, že formátovač musí výstupní komponentě ponechat samostatnou proměnnou, která udává, kolik platných znaků je v bufferech. To by umožnilo, aby všechny následné příkazy písma mohly volně měnit WALL. Důležité bylo, že oba buffery, atributové příkazy a nová proměnná byly jedinými prvky, které mohly být sdíleny mezi oběma moduly. Sáhnout do jednoho z modulů z druhého znamená potíže.

Chyba v návrhu

87

Poučení z tohoto příběhu je, že musíme rozlišovat mezi datovými strukturami, které jsou platně používány pouze v rámci jedné komponenty, a těmi, které mohou být sdíleny více komponentami. S tím souvisí i další bod: Tip 3.5

Veškerá data, která mají být sdílena komponentami, vyjadřujte v objektivních jednotkách.

Např: - Modul A měří teplotu v troubě. - Modul B řídí hořák. - Modul C zajišťuje, aby se dveře zamkly, pokud je trouba příliš horká. Informace globálního zájmu je teplota trouby, vyjádřená objektivně ve stupních. Modul A sice může obdržet hodnotu představující napětí ze snímače tepla, ale než ji předloží zbytku aplikace, měl by ji převést na stupně.

Dekompozice podle sekvenční složitosti Probírali jsme jeden způsob dekompozice: podle komponent. Druhý způsob je podle sekvenční složitosti. Jedním z pravidel jazyka Forth je, že slovo musí být již definováno, aby mohlo být vyvoláno nebo aby se na něj dalo odkazovat. Obvykle pořadí, ve kterém jsou slova definována, odpovídá pořadí rostoucích schopností, které slova musí mít. Tato posloupnost vede k přirozené organizaci výpisu zdrojů. Výkonné příkazy se jednoduše přidávají nad základní aplikaci (obrázek 3.10a). Podobně jako v učebnici jsou elementární věci na prvním místě. Nováček v projektu by si mohl přečíst elementární části kódu a teprve potom přejít k pokročilým věcem. V mnoha rozsáhlých aplikacích je však nejlepší implementovat dodatečné schopnosti jako vylepšení některé soukromé, kořenové funkce v elementární části aplikace (obrázek 3.10b). Tím, že uživatel může změnit schopnost kořenové funkce, může změnit schopnost všech příkazů, které tuto funkci používají. Vrátíme-li se pro příklad k textovému procesoru, poměrně primitivní rutinou je ta, která spouští novou stránku. Používá ji slovo, které začíná nový řádek; když nám dojdou řádky, musíme začít novou stránku. Slovo, které začíná nový řádek, zase používá rutina, která formátuje slova na řádku; když se další slovo nevejde na aktuální řádek, vyvoláme NEWLINE. Tato hierarchie "použití" vyžaduje, abychom NEWPAGE definovali na začátku aplikace. Problém? Jedna z pokročilých komponent obsahuje rutinu, která musí být vyvolána NEWPAGE. Konkrétně, pokud se v ní objeví obrázek nebo tabulka.

88

Předběžný návrh/rozklad

Obrázek 3.10: Dva způsoby přidání pokročilých funkcí.

uprostřed textu, ale v okamžiku formátování se nevejde na to, co na stránce zbývá, formátovač odloží obrázek na další stránku a zároveň pokračuje s textem. Tato funkce vyžaduje, aby se nějakým způsobem "dostala dovnitř" NEWPAGE, takže při dalším spuštění NEWPAGE zformátuje odložený obrázek na začátek nové stránky: : NEWPAGE ... ( ukončit stránku se zápatím) ( začít novou stránku se záhlavím) ... ?HOLDOVER ... ; Jak může NEWPAGE vyvolat ?HOLDOVER, když ?HOLDOVER je definováno až mnohem později?

Rozklad podle sekvenční složitosti

89

Teoreticky je sice možné uspořádat výpis tak, aby pokročilá schopnost byla definována před kořenovou funkcí, ale takový přístup je špatnou zprávou ze dvou důvodů. Zaprvé se zničí přirozená organizace (podle stupně schopnosti). Za druhé, pokročilé procedury často používají kód, který je definován uprostřed elementárních schopností. Pokud pokročilé rutiny přesunete na začátek aplikace, budete muset přesunout také všechny rutiny, které používají, nebo duplikovat kód. Velmi nepřehledné. Výpis můžete uspořádat podle stupně složitosti pomocí techniky zvané "vektorování". Můžete umožnit, aby kořenová funkce volala (ukazovala na) kteroukoli z různých rutin, které byly definovány za samotnou kořenovou funkcí. V našem příkladu je třeba na začátku vytvořit pouze název rutiny ?HOLDOVER; její definici lze uvést později. Sedmá kapitola se zabývá tématem vektorování ve Forthu.

Hranice myšlení na úrovni Většina z nás se provinila tím, že příliš zdůrazňuje rozdíl mezi "vysokou úrovní" a "nízkou úrovní". Tento pojem je libovolný. Omezuje naši schopnost jasně uvažovat o softwarových problémech. "Úrovňové" myšlení v tradičním smyslu zkresluje naše úsilí třemi způsoby: 1. Naznačuje, že pořadí vývoje by se mělo řídit hierarchickou strukturou 2. Naznačuje, že úrovně by měly být od sebe odděleny, což zakazuje výhody opakované použitelnosti. 3. Způsob, jakým se úrovně vyvíjejí. Podporuje syntaktické rozdíly mezi úrovněmi (např. assembler vs. "vysokoúrovňové" jazyky) a přesvědčení, že povaha programování se nějak mění, když se vzdalujeme od strojového kódu. Podívejme se na každý z těchto mylných názorů postupně.

Kde začít? Zeptal jsem se Moora, jak by postupoval při vývoji konkrétní aplikace, hry pro děti. Jakmile by dítě stisklo číslice na numerické klávesnici od nuly do devíti, na obrazovce by se objevil stejný počet velkých políček. Moore: Nezačínám nahoře a nepracuji dolů. Vzhledem k přesně tomuto problému bych napsal slovo, které nakreslí políčko. Začal bych dole a skončil bych u slova GO, které by monitorovalo klávesnici.

Jak moc je to intuitivní?

90

Předběžný návrh/dekompozice

Možná do jisté míry ano. Vím, kam jdu, takže tam nemusím začínat. Ale také je zábavnější kreslit krabice než programovat na klávesnici. Udělám to, co je nejzábavnější, abych se dostal do problému. Pokud budu muset později všechny ty detaily uklízet, je to cena, kterou za to zaplatím.

Jste zastáncem přístupu "zábava dolů"? Vzhledem k tomu, že to děláte ve svobodném duchu, tak ano. Kdybychom předváděli zákazníkovi za dva dny, udělal bych to jinak. Začal bych tím nejviditelnějším, ne tím nejzábavnějším. Ale pořád ne v té hierarchické posloupnosti, shora dolů. Vycházím z bezprostřednějších úvah, jako je udělat dojem na zákazníka, přimět ho, aby něco fungovalo, nebo ukázat ostatním lidem, jak to bude fungovat, aby je to zaujalo. Pokud definujete úroveň jako "vnoření", pak ano, je to dobrý způsob, jak problém rozložit. Ale pojem "úroveň" jsem nikdy nepovažoval za užitečný. Dalším aspektem úrovní jsou jazyky, metajazyky, metajazyky. Snažit se rozdělit si vlasy na tom, na které úrovni se nacházíte - na úrovni assembleru, na první integrační úrovni, na poslední integrační úrovni - to je prostě únavné a nepomáhá to. Moje úrovně se beznadějně pletou.

Při navrhování podle komponent je méně důležité, kde začnete. Můžete například začít s klíčovým interpretem. Jeho cílem je přijímat stisky kláves a převádět je na čísla a tato čísla předávat interně vyvolanému slovu. Pokud nahradíte slovo Forth . ("tečka", které vypisuje číslo ze zásobníku), pak můžeme interpret kláves implementovat, testovat a ladit, aniž bychom používali rutiny, které mají něco společného s kreslením čtverečků. Na druhou stranu, pokud by aplikace vyžadovala hardwarovou podporu (například grafický balík), kterou bychom neměli po ruce, mohli bychom ji nahradit něčím dostupným, například zobrazením hvězdičky, jen abychom se dostali do problému. Přemýšlet v termínech lexikonů je jako malovat obrovskou nástěnnou malbu, která se rozprostírá na několika plátnech. Pracujete na všech plátnech najednou, nejprve načrtnete klíčové prvky návrhu a pak tu a tam přidáte barevné skvrny. ... dokud není celá stěna hotová. Tip Při rozhodování, kde začít navrhovat, se zaměřte na:

3.6

- oblasti, kde je zapotřebí nejvíce kreativity (oblasti, kde je změna nejpravděpodobnější) - oblasti, které poskytují nejuspokojivější zpětnou vazbu (rozproudí šťávu) - oblasti, ve kterých zvolený přístup výrazně ovlivní ostatní oblasti nebo které rozhodnou o tom, zda se uvedený problém vůbec podaří vyřešit - věci, které byste měli ukázat zákazníkovi, pro vzájemné pochopení - věci, které můžete ukázat investorům, pokud je to nutné pro pronájem.

Kde začít?

91

Žádná segregace bez zastoupení Druhým způsobem, jak mohou úrovně narušit optimální řešení, je podpora segregace úrovní. Pro tuto nebezpečnou filozofii je typická populární konstrukce návrhu zvaná "objekt".∗ Objekt je část kódu, kterou lze vyvolat jediným jménem, ale která může vykonávat více než jednu funkci. Chcete-li vybrat konkrétní funkci, musíte objekt vyvolat a předat mu parametr nebo skupinu parametrů. Parametry si můžete představit tak, že představují řadu tlačítek, která můžete stisknout, aby objekt provedl to, co chcete. Výhodou návrhu aplikace z hlediska objektů je, že podobně jako komponenta objekt skrývá informace před zbytkem aplikace, což usnadňuje revizi. Je zde však několik problémů. Za prvé, objekt musí obsahovat složitou rozhodovací strukturu, která určuje, jakou funkci má vykonávat. Tím se zvětšuje velikost objektu a snižuje výkon. Naproti tomu lexikon poskytuje všechny použitelné funkce podle názvu, abyste je mohli přímo vyvolat. Za druhé, objekt je obvykle navržen tak, aby stál samostatně. Nemůže využívat nástroje poskytované podpůrnými komponentami. V důsledku toho má tendenci v sobě duplikovat kód, který se objeví jinde v aplikaci. U některých objektů je dokonce nutné analyzovat text, aby bylo možné interpretovat jejich parametry. Každý z nich může dokonce používat vlastní syntaxi. Nestydaté plýtvání časem a energií! A konečně, protože je objekt konstruován tak, aby rozpoznal konečnou množinu možností, je obtížné provádět doplnění řady tlačítek, když je potřeba nová funkce. Nástroje uvnitř objektu nebyly navrženy pro opakované použití. Myšlenka úrovní prostupuje konstrukcí osobního počítače IBM. Kromě samotného procesoru (samozřejmě s vlastní sadou strojových instrukcí) existují tyto softwarové úrovně: - sada nástrojů napsaných v assembleru a vypálených do paměti ROM systému - diskový operační systém, který tyto nástroje vyvolává - vybraný vysokoúrovňový jazyk, který vyvolává operační systém a nástroje - a konečně jakákoli aplikace používající tento jazyk. Nástroje ROM poskytují rutiny závislé na hardwaru: ty, které obsluhují obrazovku, diskové jednotky a klávesnici. Vyvoláváte je umístěním ∗ Poznámka redakce: Viz však rekapitulaci v Předmluvě z roku 1994 na straně ix a klauzuli v Předmluvě z roku 2004 na straně v. Představte si něco jako "objekty" COM systému Windows nebo CORBA. Skutečné objektově orientované programování, jak má svůj původ ve Smalltalku, neskrývá informace před programátorem. Přidání "zakódované" metody do "hlavního objektu vejce" není žádný problém. Smalltalk pracuje tak, že přidává metody do známých tříd, nemusíte je ani podtřídit. Do objektu a jeho zdrojového kódu se můžete podívat, kdykoli se vám zachce. A dispečink metod řízený tabulkami může být docela efektivní. Bernd Paysan

92

Předběžný návrh/dekompozice

"Žádné kódování?"

řídicího kódu v určitém registru a generování příslušného softwarového přerušení. Například softwarové přerušení 10H způsobí vstup do video rutin. Těchto rutin je 16. Do registru AH načtete číslo požadované video rutiny. Bohužel ve všech 16 rutinách není žádná, která by zobrazovala textový řetězec. K tomu musíte opakovat proces načítání registrů a generování softwarového přerušení, které zase musí rozhodnout, kterou rutinu chcete, a udělat několik dalších věcí, které nepotřebujete - pro každý jednotlivý znak. Zkuste si napsat textový editor, ve kterém může být nutné při každém stisku klávesy obnovit celou obrazovku. Pomalé jako pošta! Rychlost nemůžete zvýšit, protože v rámci video rutin nemůžete znovu použít žádnou informaci kromě té, která je poskytnuta navenek. Deklarovaným důvodem je "izolace" programátora od adres zařízení a dalších detailů hardwaru. Ty by se koneckonců mohly při budoucích upgradech změnit. Jediný způsob, jak na tomto stroji efektivně implementovat video I/O, je přesunout řetězce přímo do videopaměti. To můžete udělat snadno, protože referenční příručka uvádí adresu, na které videopaměť začíná. Tím se však poruší záměr konstruktérů systému. Váš kód již nemusí přežít revizi hardwaru. Tím, že segregace údajně "chrání" programátora před detaily, zmařila účel skrývání informací. Komponenty naproti tomu nejsou segregované moduly, ale spíše kumulativní doplňky slovníku. Lexikon videa by přinejmenším uváděl název pro adresu videopaměti. Ne že by bylo něco špatného na konceptu funkčního rozhraní bitového přepínače mezi komponentami, když je to nutné. Problém je v tom, že tato video komponenta byla neúplně navržena. Na druhou stranu, kdyby byl systém plně integrovaný - operační systém a ovladače napsané ve Forthu - nemusela by být video komponenta navržena tak, aby vyhovovala všem potřebám. Programátor aplikace by mohl ovladač buď přepsat, nebo napsat jeho rozšíření s využitím dostupných nástrojů z lexikonu videa. Tip 3.7

Nepohřbívejte své nástroje.

Věž blábolů Posledním klamem, kterého se dopouští levelové myšlení, je představa, že programovací jazyky by se měly kvalitativně lišit tím více, čím "výš" jdete. Máme tendenci mluvit o vysokoúrovňovém kódu jako o něčem vzácném a o nízkoúrovňovém kódu jako o něčem špinavém a profánním. Do jisté míry mají tyto rozdíly svou platnost, ale je to jen důsledek určitých arbitrárních architektonických omezení, která všichni přijímáme jako normu.

94

Předběžný návrh/dekompozice

Zvykli jsme si na assemblery se stručnou mnemotechnikou a nepřirozenými syntaktickými pravidly, protože jsou "nízkoúrovňové". Koncepce komponent se vzpouzí proti polaritě vysoká úroveň vs. nízká úroveň. Všechen kód by měl vypadat a působit stejně. Komponenta je jednoduše sada příkazů, které společně transformují datové struktury a algoritmy do užitečných funkcí. Tyto funkce lze používat bez znalosti struktur a/nebo algoritmů v nich obsažených. Vzdálenost těchto struktur od skutečného strojového kódu je irelevantní. Kód napsaný pro přepínání bitů ve výstupním portu by teoreticky neměl vypadat o nic hrozivěji než kód pro formátování sestavy. I strojový kód by měl být čitelný. Skutečný motor založený na Forthu by se těšil syntaxi a slovníku totožnému a kontinuálnímu se slovníkem "vysoké úrovně", který známe dnes.

Shrnutí V této kapitole jsme se seznámili se dvěma způsoby, jak lze aplikace dekomponovat: na komponenty a podle sekvenční složitosti. Zvláštní pozornost je třeba věnovat těm komponentám, které slouží jako rozhraní mezi jinými komponentami. Pokud jste nyní provedli předběžný návrh správně, leží vám váš problém u nohou v hromadě zvládnutelných kousků. Každý kousek představuje problém, který je třeba vyřešit. Uchopte svůj oblíbený kousek a přejděte k další kapitole.

K dalšímu zamyšlení (odpovědi najdete v příloze D.) 1. Vymyslete si, co je třeba udělat. Níže jsou uvedeny dva přístupy k definici interpretu klávesnice editoru. Kterému byste dali přednost? Proč? (a) ( Definice kláves editoru ) HEX 72 CONSTANT UPCURSOR 80 CONSTANT DOWNCURSOR 77 CONSTANT RIGHTCURSOR 75 CONSTANT LEFTCURSOR 82 CONSTANT INSERTKEY 83 CONSTANT DELETEKEY DECIMAL ( Interpret kláves ) : EDITOR BEGIN MORE WHILE KEY CASE UPCURSOR CURSOR-UP DOWNCURSOR CURSOR-DOWN

ENDOF ENDOF

Shrnutí

95

RIGHTCURSOR LEFTCURSOR INSERTKEY DELETEKEY ENDCASE REPEAT

OF OF OF OF ;

CURSOR> CURSOR< INSERTING DELETE

(b) ( Interpret kláves) : EDITOR BEGIN MORE WHILE KEY 72 OF CURSOR-UP 80 OF CURSOR-DOWN 77 OF CURSOR> 75 OF CURSOR< 82 OF INSERTING 83 OF DELETE ENDCASE REPEAT ;

ENDOF ENDOF ENDOF ENDOF ENDOF

CASE ENDOF ENDOF ENDOF ENDOF ENDOF ENDOF ENDOF ENDOF

2. Tento problém je cvičením v oblasti skrývání informací. Předpokládejme, že máme oblast paměti mimo slovník jazyka Forth, kterou chceme alokovat pro datové struktury (z jakéhokoli důvodu). Oblast paměti začíná na adrese HEX C000. Chceme definovat řadu polí, která budou v této paměti umístěna. Mohli bychom to udělat takto: HEX C000 KONSTANTNÍ PRVNÍ POLE ( 8 bajtů) C008 KONSTANTNÍ DRUHÉ POLE ( 6 bajtů) C00C KONSTANTNÍ TŘETÍ POLE ( 100 bajtů) Každé výše definované jméno pole vrátí počáteční adresu příslušného pole. Všimněte si však, že jsme museli vypočítat správnou počáteční adresu pro každé pole na základě toho, kolik bajtů jsme již alokovali. Pokusíme se to zautomatizovat tím, že budeme udržovat "alokační ukazatel", který se nazývá >RAM a ukazuje, kde je další volný bajt. Nejprve nastavíme ukazatel na začátek prostoru RAM: PROMĚNNÁ >RAM C000 >RAM ! Nyní můžeme definovat jednotlivá pole takto: x >RAM @ KONSTANTNÍ PRVNÍ POLE 8 >RAM +! >RAM @ KONSTANTNÍ DRUHÉ POLE 6 >RAM +! >RAM @ KONSTANTNÍ TŘETÍ POLE 100 >RAM +! Všimněte si, že po definování každého pole zvýšíme ukazatel o velikost nového pole, abychom ukázali, že jsme přidělili tolik paměti RAM navíc.

96

Předběžný návrh/dekompozice

Aby byl výše uvedený text čitelnější, mohli bychom přidat tyto dvě definice: : THERE ( -- adresa dalšího volného bajtu v paměti RAM) >RAM @ ; : RAM-ALLOT ( #bytů k alokaci -- ) >RAM +! ; Výše uvedené můžeme nyní ekvivalentně přepsat jako: THERE CONSTANT FIRST-ARRAY 8 RAM-ALLOT THERE CONSTANT SECOND-ARRAY 6 RAM-ALLOT THERE CONSTANT THIRD-ARRAY 100 RAM-ALLOT (Pokročilý programátor Forthu by pravděpodobně tyto operace spojil do jediného definičního slova, ale celé toto téma se netýká toho, k čemu jsem se dostal.) Nakonec předpokládejme, že máme 20 takových definic polí roztroušených po celé aplikaci. Nyní problém: nějak se změní architektura našeho systému a my se rozhodneme, že musíme tuto paměť alokovat tak, aby končila na HEX adrese EFFF. Jinými slovy, musíme začít na konci a alokovat pole pozpátku. Stále však chceme, aby každé jméno pole vracelo svou počáteční adresu. Za tímto účelem musíme nyní napsat: F000 >RAM ! ( EFFF, poslední bajt plus jedna) : THERE ( -- adresa dalšího volného bajtu v RAM) >RAM @ ; : RAM-ALLOT ( #bytů k alokaci) NEGATE >RAM +! ; 8 RAM-ALLOT THERE CONSTANT FIRST-ARRAY 6 RAM-ALLOT THERE CONSTANT SECOND-ARRAY 100 RAM-ALLOT THERE CONSTANT THIRD-ARRAY Tentokrát RAM-ALLOT snižuje ukazatel. To nevadí, do definice RAM-ALLOT lze snadno přidat NEGATE. Naše současná starost spočívá v tom, že pokaždé, když definujeme pole, musíme RAM-ALLOT provést před jeho definováním, nikoliv až po něm. V našem kódu je třeba najít a opravit dvacet míst. Slova THERE a RAM-ALLOT jsou sice hezká a přívětivá, ale nepodařilo se jim skrýt, jak je oblast alokována. Kdyby se jim to podařilo, nezáleželo by na tom, v jakém pořadí je vyvoláme. Konečně naše otázka: Co jsme mohli udělat s THERE a RAM-ALLOT, abychom minimalizovali dopad této změny návrhu? (Opět, odpověď, kterou hledám, nemá nic společného s definováním slov.)

K dalšímu zamyšlení

97

ČTYŘI

Podrobný návrh/řešení problému

Triviální: Dokážu si představit, jak to udělat. Jen nevím, jak dlouho to bude trvat. Netriviální: Nemám ponětí, jak to udělat! -Filozofie fungování vyvinutá ve skupině pro návrh laboratorní automatizace a přístrojového vybavení, katedra chemie, Virginia Polytechnic Institute and State University.

Jakmile jste se rozhodli pro komponenty vaší aplikace, dalším krokem je tyto komponenty navrhnout. V této kapitole použijeme techniky řešení problémů při podrobném návrhu aplikace Forth. To je čas pro čistou invenci, část, která je pro mnohé z nás nejzábavnější. Je zvláštním uspokojením jít na kobereček s netriviálním problémem a vyjít z něj jako vítěz. V angličtině je obtížné oddělit myšlenku od slov, kterými se tato myšlenka vyjadřuje. Při psaní aplikace v jazyce Forth je obtížné oddělit fázi detailního návrhu od implementace, protože máme tendenci navrhovat ve Forthu. Z tohoto důvodu se v této kapitole trochu předběhneme a budeme nejen prezentovat problém, ale také navrhovat jeho řešení, a to až po kódovanou implementaci.

Techniky řešení problémů I neofyt může řešit programátorské problémy, aniž by se vědomě věnoval technikám řešení problémů. Jaký má tedy smysl studovat techniky řešení problémů? Urychlit tento proces. Přemýšlením o způsobech řešení problémů, kromě problémů samotných, obohacujeme svou podvědomou zásobárnu technik. G. Polya napsal několik knih o řešení problémů, zejména matematických. Nejdostupnější z nich je Jak je řešit [1]. Přestože řešení matematického problému není zcela stejné jako řešení softwarového problému, najdete v ní několik cenných podnětů. Následující série tipů shrnuje několik technik doporučených vědou o řešení problémů:

100 Podrobný návrh/řešení problémů

Tip Určete si svůj cíl.

4.1

Zjistěte, čeho se snažíte dosáhnout. Jak jsme viděli ve druhé kapitole, tento krok lze dále upřesnit: Určete datová rozhraní: Zjistěte, jaká data budou potřebná k dosažení cíle, a ujistěte se, že tato data jsou k dispozici (vstupní). Zjistěte, jaká data má funkce produkovat (výstup). Pro jedinou definici to znamená napsat komentář stack-effect. Určete pravidla; zkontrolujte všechna fakta, která znáte. Ve druhé kapitole jsme popsali sazby pro výpočet nákladů na telefonní hovor spolu s pravidly pro jejich použití. Tip Představte si problém jako celek.

4.2

Ve fázi analýzy jsme problém rozdělili na části, abychom si ujasnili, jak jednotlivé části chápeme. Nyní vstupujeme do fáze syntézy. Musíme si problém představit jako celek. Snažte se v mysli uchovat co nejvíce informací o problému. Používejte slova, věty, obrázky a tabulky nebo jakýkoli druh grafického znázornění dat a/nebo pravidel, které vám pomohou vidět maximum informací na první pohled. Naplňte svou mysl k prasknutí požadavky na problém, který potřebujete vyřešit, podobně jako byste si mohli naplnit plíce vzduchem. Nyní tento mentální obraz zadržte, jako byste zadržovali dech. Stane se jedna ze dvou věcí: Možná v záblesku vhledu uvidíte řešení. Skvělé! Vydechněte úlevou a přejděte rovnou k realizaci. Nebo ... . , problém je příliš složitý nebo neznámý na to, aby se dal vyřešit tak snadno. V takovém případě budete muset obrátit pozornost k analogiím a dílčím řešením. Při tom je důležité, abyste se již najednou soustředili na požadavky problému a vryli si je na mentální sítnici. Tip Vypracujte si plán.

4.3

Pokud řešení nepřišlo na první pohled, dalším krokem je stanovení postupu, který použijete k jeho vyřešení. Stanovte si směr postupu a vyhněte se pasti bezcílného tápání. Následující tipy naznačují několik přístupů, které můžete zvážit.

Techniky řešení problémů 101

Tip 4.4

Přemýšlejte o analogickém problému.

Připadá vám tento problém povědomý? Psali jste již někdy podobnou definici? Zjistěte, které části problému jsou vám povědomé a v čem by se tento problém mohl lišit. Zkuste si vzpomenout, jak jste ho řešili dříve nebo jak jste řešili něco podobného. Tip 4.5

Pracujte dopředu.

Obvyklý, samozřejmý způsob, jak se na problém vrhnout, je začít známým a postupovat k neznámému. Při rozhodování, na kterého koně vsadit, byste začali jejich nedávnou historií, jejich současným zdravotním stavem a podobně, použili byste váhy těchto různých faktorů a dospěli byste k favoritovi. Tip 4.6

Pracujte zpětně.

Složitější problémy představují mnoho možných způsobů, jak postupovat s příchozími daty. Jak poznáte, která cesta vás přiblíží k řešení? Nevíte. Tuto třídu problémů nejlépe vyřešíte tak, že budete pracovat zpětně (obrázek 4.1). Obrázek 4.1: Problém, který se snáze řeší pozpátku než dopředu.

Tip 4.7

Věřte.

Nezbytnou složkou úspěšné práce pozpátku je víra. Ilustrujeme to na známém matematickém problému. Předpokládejme, že máme dvě nádoby. Nádoby nemají žádné dělení, ale do jedné se vejde devět galonů a do druhé devět galonů.

102 Podrobný návrh/řešení problémů

Obrázek 4.2: Dvě nádoby.

Druhá nádoba má objem čtyři galony. Naším úkolem je odměřit přesně šest galonů vody z blízkého potoka do jedné z nádob (obrázek 4.2). Před dalším čtením si zkuste tuto úlohu vyřešit sami. Jak můžeme z "devíti" a "čtyř" získat "šest"? Můžeme začít pracovat dopředu tak, že v duchu přeneseme vodu z jedné nádoby do druhé. Například když naplníme velkou nádobu dvakrát z malé nádoby, získáme osm galonů. Pokud naplníme devítilitrovou nádobu až po okraj a pak vypustíme tolik vody, abychom naplnili čtyřgalonovou nádobu, budeme mít ve velké nádobě přesně pět galonů. Tyto nápady jsou zajímavé, ale šest galonů jsme díky nim nezískali. A není jasné, jak se k šesti galonům dostaneme. Zkusme pracovat obráceně. Předpokládáme, že jsme naměřili šest galonů vody a ta se nachází ve velké nádobě (do malé se nevejde!). Jak jsme ji tam nyní dostali? Jaký byl stav našich nádob o krok dříve? Existují pouze dvě možnosti (obrázek 4.3): 1. Čtyřgalonová nádoba byla plná a my jsme ji právě přidali do velké nádoby. To znamená, že ve velké nádobě jsme již měli dva galony. Nebo . . 2. Devítigalonová nádoba byla plná a my jsme právě odlili tři galony do malé nádoby. Která možnost je správná? Zkusme hádat. První volba vyžaduje měření dvou galonů, druhá volba vyžaduje měření tří galonů. Při našem počátečním hraní jsme nikdy neviděli jednotku jako dva. Viděli jsme však rozdíl jedné a jedna ze čtyř je tři. Zvolíme tedy variantu b. Nyní přichází na řadu skutečný trik. Musíme se bez pochybností přesvědčit, že jsme dospěli k popsané situaci. Právě jsme odlili tři galony do malé nádoby. Pozastavíme veškerou nedůvěru a soustředíme se na to, jak jsme to udělali.

Techniky řešení problémů 103

Obrázek 4.3: Dosažení konečného výsledku.

Jak můžeme odlít tři galony do malé nádoby? Když už byl v malé nádobě jeden galon! Najednou jsme za vodou. Jednoduchá otázka nyní zní: Jak dostaneme jeden galon do malé nádoby? Museli jsme začít s plnou devítigalonovou nádobou, dvakrát odlít čtyři galony a nechat jeden galon. Pak jsme ten jeden galon přelili do malé nádoby. Naším posledním krokem by mělo být ověření naší logiky opětovným spuštěním úlohy dopředu. Zde je další výhoda práce pozpátku: Pokud je problém neřešitelný, zpětný postup vám pomůže rychle dokázat, že nemá řešení. Tip 4.8

Rozpoznejte pomocný problém.

Než problém vyřešíme, máme jen mlhavou představu o tom, jaké kroky - nebo dokonce kolik kroků - mohou být zapotřebí. Když se s problémem seznámíme blíže, začneme si uvědomovat, že náš problém obsahuje jeden nebo více

104 Podrobný návrh/řešení problému

Záměr na složitý problém.

dílčích problémů, které se zdají být nějakým způsobem odlišné od hlavního náčrtu navrhovaného postupu. V právě řešeném problému jsme rozpoznali dva podproblémy: naplnění malé nádoby jedním galonem a následné naplnění velké nádoby šesti galony. Rozpoznání těchto menších problémů, někdy nazývaných "pomocné problémy", je důležitou technikou řešení problémů. Díky identifikaci podproblému můžeme předpokládat, že má jednoduché řešení. Aniž bychom se zastavili a zjišťovali, jaké by toto řešení mohlo být, pokračujeme v řešení našeho hlavního problému. (Jazyk Forth je pro tuto techniku ideální, jak uvidíme.) Tip 4.9

Odstupte od problému.

Je snadné se tak emocionálně upnout k jednomu konkrétnímu řešení, že zapomeneme mít otevřenou mysl. V literatuře o řešení problémů se často používá příklad devíti teček. Zarazil mě, a tak ho předám dál. Máme devět teček uspořádaných tak, jak je znázorněno na obrázku 4.4. Úkolem je nakreslit rovné čáry, které se dotýkají všech devíti teček nebo jimi procházejí, aniž by se pero zvedlo z papíru. Omezení spočívá v tom, že se všech devíti bodů musíte dotknout pouze čtyřmi čarami. Obrázek 4.4: Úloha s devíti body.

Můžete sedět hodnou chvíli a neuděláte nic lepšího než téměř správný obrázek 4.5. Pokud se budete opravdu hodně soustředit, můžete nakonec dojít k závěru, že úloha je chyták - nemá řešení. Pokud si ale sednete a zeptáte se sami sebe: "Neošidím se o užitečnou taktiku tím, že jsem úzkoprsý? Nepředpokládám nějaká omezení, která nejsou v problému uvedena? Jaká omezení by to mohla být?"

pak byste mohli uvažovat o prodloužení některých čar za obvod devíti bodů.

106 Podrobný návrh/řešení problému

Obrázek 4.5: Ne zcela správně.

Tip Používejte myšlení celým mozkem.

4.10

Když vás problém zarazí a zdá se, že se nikam nedostanete, uvolněte se, přestaňte se jím zabývat, možná na něj dokonce na chvíli zapomeňte. Kreativní lidé si vždycky všímali, že jejich nejlepší nápady jako by přicházely zčistajasna, v posteli nebo ve sprše. Mnohé knihy o řešení problémů doporučují spoléhat se na podvědomí při řešení opravdu obtížných problémů. Současné teorie o fungování mozku zkoumají rozdíly mezi racionálním, vědomým myšlením (které se opírá o manipulaci se symboly) a podvědomým myšlením (které dává do souvislosti vjemy s dříve uloženými informacemi, rekombinuje a propojuje znalosti novými a užitečnými způsoby). Leslie Hart [2] vysvětluje obtížnost řešení rozsáhlého problému pomocí logiky: Na tu jednu malou funkci mozku, kterou lze na určitou dobu uvést do zóny pozornosti, je kladena obrovská zátěž. Výkon je možný, podobně jako cirkusové číslo, ale zdá se, že je rozumnější. . využít všechny zdroje naší slavné neokortexu. . multimiliardovou kapacitu mozku. . . . Pracovní aspekt spočívá v tom, že mozku poskytujeme surové vstupy, jako je pozorování, čtení, sběr dat a přehled toho, čeho dosáhli jiní. Jakmile se do něj dostanou [podvědomé] postupy, přebírají je současně, automaticky, mimo zónu pozornosti. . . . Zdá se to být zřejmé . . že během intervalu probíhá vyhledávání, i když ne nutně nepřetržitě, podobně jako ve velkém počítači. Odvážil bych se odhadnout, že hledání se rozvětvuje, začíná a končí, dostává se do slepých uliček a začíná znovu, a nakonec sestaví odpověď, která je vyhodnocena a pak se objeví ve vědomé pozornosti - často v překvapivě plném detailu.

Tip Vyhodnoťte své řešení. Hledejte další řešení.

4.11

Možná jste našli jeden způsob, jak stáhnout kočku z kůže. Mohou existovat i jiné způsoby a některé z nich mohou být lepší.

Techniky řešení problémů 107

Neinvestujte příliš mnoho úsilí do prvního řešení, aniž byste se zeptali na druhý názor.

Rozhovor s vynálezcem softwaru Donald A. Burgess, majitel a prezident společnosti Scientek Instrumentation, Inc: Mám několik technik, které se mi v průběhu let osvědčily při navrhování čehokoli, abych si zachoval flexibilitu. Moje první pravidlo zní: "Nic není nemožné." Vždycky jsem si říkal, že je to nemožné. Mé druhé pravidlo zní: "Nezapomeňte, že cílem je vydělat peníze." Nejprve si problém prozkoumejte a na papír si načrtněte dva nebo tři přístupy. Pak vyzkoušejte ten nejatraktivnější, abyste zjistili, zda funguje. Proveďte ho. Pak se záměrně vraťte úplně na začátek a začněte znovu. Začít znovu má dvě hodnoty. Zaprvé vám poskytne nový přístup. Buď se vrátíte ke způsobu, kterým jste začali, nebo se způsob, kterým jste začali, přikloní k novému způsobu. Za druhé, nový přístup může ukázat nejrůznější silné možnosti. Nyní máte k dispozici měřítko. Můžete se podívat na oba přístupy a porovnat výhody obou. Jste v lepší pozici pro posouzení. Zaseknutí pochází z přílišné snahy řídit se jediným přístupem. Nezapomeňte si říct: "Chci, aby tento drtič kumštu byl jiný. Odmítněme tradiční design jako nezajímavý. Zkusme nějaké bláznivé nápady." Nejlepší je začít si kreslit obrázky. Já kreslím mužíčky. Díky tomu to nevypadá jako "data" a nenarušuje to můj proces přemýšlení. Lidská mysl výjimečně dobře pracuje s analogiemi. Uvádění věcí do souvislostí vás chrání před tím, abyste se zasekli v mezích jakéhokoli jazyka, dokonce i Forthu. Když se chci soustředit, kreslím si na malé kousky papíru. Když chci přemýšlet v širokých obrysech, abych zachytil celkový tok, kreslím na velké kusy papíru. To jsou některé z bláznivých triků, které používám, abych nezůstal stát na místě. Když programuji ve Forthu, strávím den jen sněním, překopáváním nápadů. Obvykle než začnu psát, načrtnu si je v obecné rovině. Žádný kód, jen řeči. Poznámky pro sebe. Pak začnu nejprve s posledním řádkem kódu. Popíšu, co bych chtěl udělat, co nejblíže angličtině. Pak pomocí editoru posunu tuto definici směrem ke spodní části obrazovky a začnu kódovat vnitřní slova. Pak si uvědomím, že je to mizerný způsob. Možná rozdělím horní slovo na dvě a jedno z nich přenesu do dřívějšího bloku, abych ho mohl použít dříve. Spustím hardware, pokud ho mám; jinak ho nasimuluju. Forth vyžaduje sebekázeň. Musíte přestat manipulovat s klávesnicí. Forth je tak ochotný dělat, co mu řeknu, že mu řeknu, aby dělal různé absurdní věci, které nemají nic společného s tím, kam se snažím dojít. V takových chvílích musím od klávesnice odejít.

108 Podrobný návrh/řešení problémů

"Nejenže spím. Používám svůj neokortex."

Forth vám umožňuje hrát si. To je v pořádku, je pravděpodobné, že vás něco napadne. Pokud se ovšem budete bránit tomu, aby se vám hraní stalo zvykem. Vaše hlava je na vymýšlení věcí mnohem lepší než počítač.

Podrobný návrh Nyní jsme v bodě vývojového cyklu, kdy jsme se rozhodli, že potřebujeme komponentu (nebo konkrétní slovo). Tato komponenta se bude skládat z řady slov, z nichž některá (ta, která tvoří lexikon) budou používána jinými komponentami a některá (interní slova) budou používána pouze v rámci této komponenty. Vytvořte tolik slov, kolik je potřeba, abyste dodrželi následující tip: Tip 4.12

Každá definice by měla plnit jednoduchý, dobře definovaný úkol.

Zde jsou kroky, které se obecně týkají návrhu komponenty: 1. Na základě požadovaných funkcí rozhodněte o názvech a syntaxi vnějších definic (definujte rozhraní). 2. Zpřesněte konceptuální model popisem algoritmu (algoritmů) a datové struktury (datových struktur). 3. Rozpoznejte pomocné definice. 4. Určete, jaké pomocné definice a techniky jsou již k dispozici. 5. Popište algoritmus pomocí pseudokódu. 6. Implementujte jej zpětným postupem od existujících definic ke vstupům. 7. Implementujte všechny chybějící pomocné definice. 8. Pokud lexikon obsahuje mnoho jmen se společnými silnými prvky, navrhněte a nakódujte společné prvky jako interní definice a poté implementujte externí definice. První dva kroky probereme podrobněji. Poté se budeme věnovat rozšířenému příkladu návrhu lexikonu.

Syntaxe jazyka Forth V této fázi vývojového cyklu se musíte rozhodnout, jak se budou slova v novém lexikonu používat v kontextu. Přitom mějte na paměti, jak bude lexikon používán následnými komponentami.

110 Podrobný návrh/řešení problémů

Tip Při návrhu komponenty je cílem vytvořit takový lexikon, aby byl váš pozdější kód čitelný a snadno udržovatelný.

4.13

Každá komponenta by měla být navržena s ohledem na komponenty, které ji používají. Syntaxi lexikonu musíte navrhnout tak, aby slova dávala smysl, když se objeví v kontextu. Skrytí vzájemně souvisejících informací v rámci komponenty zajistí udržovatelnost, jak jsme viděli. Zároveň dodržujte vlastní syntaxi jazyka Forth. Místo toho, abyste trvali na určité syntaxi, protože se vám zdá známá, můžete si ušetřit psaní spousty zbytečného kódu tím, že zvolíte syntaxi, kterou Forth podporuje bez zvláštního úsilí z vaší strany. Zde je několik základních pravidel přirozené syntaxe jazyka Forth: Tip Před jmény nechte stát čísla.

4.14

Slova, která vyžadují číselný argument, budou přirozeně očekávat, že toto číslo najdou na zásobníku. Syntakticky vzato by tedy číslo mělo předcházet jménu. Například syntaxe slova SPACES, které vyzařuje "n" mezer, je 20 SPACES Někdy toto pravidlo porušuje pořadí, které je naše ucho zvyklé slyšet. Například slovo + v jazyce Forth očekává, že mu budou předcházet oba argumenty, jako je tomu ve tvaru 3 4 + Toto uspořádání, v němž hodnoty předcházejí operátorům, se nazývá "postfix". Forth ve své velkorysosti nebude trvat na postfixovém zápisu. Mohli byste předefinovat + tak, aby ve vstupním proudu očekávalo jedno číslo, například takto: 3 + 4 definováním takto: : +

BL WORD

NUMBER DROP

+ ;

(kde WORD je standard 79/83, vracející adresu, a NUMBER vrací hodnotu dvojnásobné délky jako v 83 Standard Uncontrolled Reference Words). V pořádku. Ale nemohli byste tuto definici použít uvnitř jiných definic dvojtečky nebo jí předat argumenty, čímž byste zmařili jednu z hlavních výhod jazyka Forth. Slova typu "podstatné jméno" často předávají své adresy (nebo jakýkoli typ ukazatele) jako argument zásobníku slovům typu "sloveso". Syntaxe podobná jazyku Forth

Syntaxe jazyka Forth 111

"noun" "verb" se obecně ukáže jako nejsnáze implementovatelná díky zásobníku. V některých případech zní toto pořadí slov nepřirozeně. Předpokládejme například, že máme soubor s názvem INVENTORY. Jednou z věcí, kterou s tímto souborem můžeme udělat, je SHOW, tedy formátování informací do pěkných sloupců. Pokud INVENTORY předá ukazatel na SHOW, který na něj působí, syntaxe se změní na INVENTORY SHOW Pokud vaše specifikace vyžaduje anglické pořadí slov, Forth nabízí způsoby, jak toho dosáhnout. Většina z nich však zahrnuje nové úrovně složitosti. Někdy je nejlepší zvolit lepší název. Co třeba INVENTORY REPORT (z "ukazatele" jsme udělali přídavné jméno a z "aktéra" podstatné jméno.) Pokud požadavky trvají na syntaxi SHOW INVENTORY, máme několik možností. SHOW by mohlo nastavit příznak a INVENTORY by se chovalo podle příznaku. Takový přístup má určité nevýhody, zejména to, že INVENTORY musí být dostatečně "chytrá", aby znala všechny možné akce, které by na ni mohly být provedeny. (Těmito problémy se budeme zabývat v kapitolách sedm a osm.) Nebo by se SHOW mohl podívat dopředu na další slovo ve vstupním proudu. Tento přístup probereme v tipu "Vyhnout se očekávání" později v této kapitole. Nebo, což je doporučený přístup, SHOW může nastavit "proměnnou provedení", kterou pak INVENTORY provede. (O vektorovaném provádění budeme hovořit v sedmé kapitole.) Tip Nechte text následovat za jmény.

4.15

Pokud interpreter jazyka Forth najde textový řetězec, který není ani číslem, ani předdefinovaným slovem, přeruší práci s chybovým hlášením. Z tohoto důvodu musí nedefinovanému řetězci předcházet definované slovo. Příkladem je ." (tečková uvozovka), který předchází textu, který bude později vypsán. Dalším příkladem je CREATE (stejně jako všechna definiční slova), které předchází jménu, které je v daném okamžiku ještě nedefinované. Toto pravidlo platí i pro definovaná slova, na která se chcete odkazovat, ale která se neprovádějí obvyklým způsobem. Příkladem je FORGET, jako ve FORGET TASK Syntakticky musí FORGET předcházet TASK, aby se TASK nevykonalo.

Syntaxe jazyka Forth 113

Tip 4.16

Nechte definice spotřebovávat jejich argumenty.

Toto syntaktické pravidlo je spíše konvencí dobrého programování ve Forthu než jeho předností. Předpokládejme, že píšete slovo LAUNCH, které vyžaduje číslo odpalovací rampy a odpálí příslušnou raketu. Chcete, aby definice vypadala zhruba takto: : LAUNCH

( pad#)

LOAD

AIM

FIRE ;

Každá ze tří interních definic bude vyžadovat stejný argument, číslo startovací podložky. Někde budete potřebovat dvě DUP. Otázkou je kde? Pokud je vložíte dovnitř LOAD a AIM, pak je můžete ponechat mimo LAUNCH, jako ve výše uvedené definici. Pokud je necháte mimo LOAD a AIM, budete muset definovat: : LAUNCH

( pad#)

DUP LOAD

DUP AIM

FIRE ;

Podle konvence je vhodnější druhá verze, protože LOAD a AIM jsou čistší. Dělají to, co od nich očekáváte. Pokud budete muset definovat READY, můžete to udělat takto: : READY

( pad#)

DUP LOAD

( pad#)

LOAD

CÍL ;

a ne : READY

AIM

DROP ;

Tip 4.17

Používejte nulové relativní číslování.

Ze zvyku číslujeme věci začínající jedničkou: "první, druhý, třetí" atd. Matematické modely naproti tomu fungují přirozeněji, když začínají nulou. Vzhledem k tomu, že počítače jsou numerické procesory, software se lépe píše, když používáme nulové relativní číslování. Pro ilustraci předpokládejme, že máme tabulku osmibajtových záznamů. První záznam zabírá prvních osm bajtů tabulky. Abychom vypočítali jeho počáteční adresu, přidáme do TABLE "0". Pro výpočet počáteční adresy "druhého" záznamu přidáme do TABLE "8". Pro dosažení těchto výsledků lze snadno odvodit vzorec: První záznam začíná na adrese: Druhý záznam začíná na adrese: 0×8= 0: Třetí záznam začíná na adrese: 1 × 8 = 8: Snadno můžeme napsat slovo, které převede záznam# na adresu, kde tento záznam začíná:

114 Podrobný návrh/řešení problému

Obrázek 4.6: Tabulka 8bajtových záznamů.

: RECORD ( record# -- adr ) 8 * TABLE + ; Z počítačového hlediska je tedy smysluplné nazývat "první záznam" 0. záznam. Pokud vaše požadavky vyžadují, aby číslování začínalo jedničkou, je to v pořádku. V celém návrhu používejte nulové relativní číslování a pouze v "uživatelském lexikonu" (soubor slov, která bude používat koncový uživatel) zahrňte převod z nulového na jedničkové relativní číslování: : ITEM

( n -- adr)

1- RECORD ;

Tip Adresy nechte předcházet počty.

4.18

Opět se jedná o konvenci, nikoli o požadavek jazyka Forth, ale takové konvence jsou pro čitelný kód nezbytné. Příklady tohoto pravidla najdete ve slovech TYPE, ERASE a BLANK. Tip Nechte zdroje předcházet cílům.

4.19

Další konvence pro čitelnost. V některých systémech například věta 22 37 COPY zkopíruje obrazovku 22 na obrazovku 37. V některých systémech je tato věta napsána jako kopie. Syntaxe CMOVE zahrnuje jak tuto konvenci, tak předchozí konvenci: zdroj cíl počet CMOVE Tip Vyhněte se očekávání (ve vstupním proudu).

4.20

Obecně se snažte vyhnout vytváření slov, která předpokládají, že ve vstupním proudu budou další slova.

Syntaxe jazyka Forth 115

Předpokládejme, že váš počítač reprezentuje barvu modrou hodnotou 1 a světle modrou hodnotou 9. Chcete definovat dvě slova: BLUE vrátí 1; LIGHT může předcházet BLUE, aby vznikla hodnota 9. V jazyce Forth by bylo možné definovat slovo BLUE jako konstantu, takže by při svém provedení vždy vracelo hodnotu 1. 1 KONSTANTNÍ BLUE A pak definujte LIGHT tak, že vyhledá další slovo ve vstupním proudu, provede ho a "nebo" ho doplní číslem 8 (logika tohoto postupu se ukáže, až tento příklad navštívíme znovu, později v knize): : LIGHT ( předchází barva) ' EXECUTE 8 OR ;

( -- hodnota barvy)

(na obr. dopředu: : LIGHT [COMPILE] '

CFA EXECUTE

8 OR ;)

(Pro začátečníky: Apostrof v definici LIGHT je forthovské slovo zvané "tick". Tick je slovo pro vyhledávání ve slovníku; vezme jméno, vyhledá ho ve slovníku a vrátí adresu, kde se definice nachází. Při použití v této definici najde adresu slova následujícího za slovem LIGHT - například BLUE - a předá tuto adresu slovu EXECUTE, které provede BLUE a na zásobník vloží jedničku. Poté, co LIGHT "nasál" operaci BLUE, vloží nyní do jedničky osmičku, čímž vznikne devítka.) Tato definice bude fungovat, když bude vyvolána ve vstupním proudu, ale je nutné speciální ošetření, pokud chceme nechat LIGHT vyvolat v rámci definice dvojtečky, jako například: : EDITING

SVĚTLE MODRÝ RÁMEČEK ;

I ve vstupním proudu zde použití EXECUTE způsobí pád, pokud za LIGHT omylem následuje něco jiného než definované slovo. Pokud jste nuceni použít tuto konkrétní syntaxi, preferovanou technikou je nechat LIGHT nastavit příznak a nechat BLUE určit, zda byl tento příznak nastaven, jak uvidíme později. V některých případech bude žádoucí, dokonce nezbytné, podívat se do vstupního proudu dopředu. (Často se takto implementuje navrhované řešení TO [3].) Obecně se však vyhněte očekávání. Připravujete se tím o zklamání. Tip 4.21

Nechte příkazy, aby se prováděly samy.

Toto pravidlo je důsledkem pravidla "Vyhněte se očekávání". Je to jedna z filozofických zvláštností jazyka Forth, která spočívá v tom, že se slova nechají dělat svou práci sama. Svědkem je překladač jazyka Forth (funkce, která sestavuje definice dvojteček), který je karikován na obrázku 4.7. Má jen velmi málo pravidel:

116 Podrobný návrh/řešení problémů

Obrázek 4.7: Tradiční kompilátor vs. kompilátor jazyka Forth.

- Vyhledá další slovo ve vstupním proudu a vyhledá je ve slovníku. - Pokud je to obyčejné slovo, zkompilujte jeho adresu. - Pokud je to "okamžité" slovo, proveďte ho. - Pokud to není definované slovo, zkuste ho převést na číslo a zkompilovat jako literál. - Pokud to není číslo, přerušte kompilaci s chybovým hlášením. O kompilaci slov jako IF, ELSE, THEN atd. se nic neuvádí. Kompilátor dvojtečky o těchto slovech neví. Pouze rozpoznává určitá

Syntaxe jazyka Forth 117

slova jako "okamžitá" a provede je, přičemž je nechá dělat jejich vlastní práci. (Viz část Starting Forth, kapitola jedenáctá, "Jak ovládat překladač dvojtečky".) Překladač ani "nehledá" středník, aby věděl, kdy má kompilaci ukončit. Místo toho provede středník a nechá ho udělat práci při ukončování definice a vypnutí překladače. Tento přístup má dvě obrovské výhody. Zaprvé je překladač tak jednoduchý, že jej lze napsat v několika řádcích kódu. Zadruhé, počet slov pro kompilaci, která můžete kdykoli přidat, není nijak omezen - jednoduše je můžete přidat okamžitě. I dvojtečka kompilátoru Forth je tedy rozšiřitelná! Stejné pravidlo dodržuje i textový překladač jazyka Forth a adresní překladač jazyka Forth. Následující tip je v této kapitole asi nejdůležitější: Tip 4.22

Nepište si vlastní interpret/kompilátor, když můžete použít interpret/kompilátor jazyka Forth.

Jedna třída aplikací odpovídá na potřebu speciálního jazyka - samostatné sady příkazů pro provádění jedné konkrétní věci. Příkladem je assembler strojového kódu. Zde máte k dispozici velkou skupinu příkazů, mnemotechniky, kterými můžete popsat instrukce, které chcete sestavit. I v tomto případě se jazyk Forth radikálně odchyluje od hlavního proudu filozofie. Tradiční assemblery jsou účelové interprety - to znamená, že jsou to složité programy, které prohledávají výpis assembleru a hledají rozpoznané mnemotechnické příkazy jako ADD, SUB, JMP atd. a podle nich sestavují strojové instrukce. Asembler jazyka Forth je však pouze lexikon slov jazyka Forth, která sama o sobě skládají strojové instrukce. Příkladů účelového jazyka je mnohem více, každý z nich je specifický pro jednotlivé aplikace. Například: 1. Pokud vytváříte hru typu Adventure, budete chtít napsat jazyk, který vám umožní vytvářet a popisovat příšery a místnosti atd. Mohli byste vytvořit definiční slovo s názvem ROOM, které se bude používat takto: Pak vytvořte sadu slov pro popis atributů místnosti tak, že vytvoříte neviditelné datové struktury spojené s místností: Místnost: VYCHODNÍ DRAČÍ KŘESLO ZÁPADNÍ MOST OBSAHUJÍCÍ POTRUBÍ ZLATA atd. Příkazy tohoto jazyka pro tvorbu her mohou být jednoduše slova jazyka Forth, přičemž interpretem je jazyk Forth.

118 Podrobný návrh/řešení problémů

2. Pokud pracujete se zařízeními PAL (Programmable Array Logic), hodila by se vám forma zápisu, která vám umožní popsat chování výstupních pinů v logických termínech na základě stavů vstupních pinů. Programátor PAL napsal s úžasnou jednoduchostí v jazyce Forth Michael Stolowitz [4]. 3. Pokud musíte vytvořit řadu uživatelských nabídek, které budou řídit vaši aplikaci, možná budete chtít nejprve vyvinout jazyk pro sestavování nabídek. Slova tohoto nového jazyka umožňují programátorovi aplikace rychle naprogramovat potřebná menu - a přitom skrývají informace o tom, jak kreslit okraje, pohybovat kurzorem atd. Všechny tyto příklady lze nakódovat ve Forthu jako lexikony pomocí běžného interpretu Forthu, aniž by bylo nutné psát speciální účelový interpret nebo kompilátor. Moore: Jednoduché řešení je takové, které nezastírá problém nepodstatnými věcmi. Lze si představit, že něco v problému vyžaduje jedinečný interpret. Ale pokaždé, když vidíte jedinečný interpret, znamená to, že na problému je něco obzvlášť nešikovného. A to téměř nikdy není ten případ. Pokud si napíšete vlastní interpret, je interpret téměř jistě nejsložitější a nejpropracovanější částí celé aplikace. Přešli jste od řešení problému k psaní interpretu. Myslím, že programátoři rádi píší interprety. Rádi dělají tyto složité komplikované věci. Ale přijde čas, kdy svět bude muset přestat programovat klávesnice a převádět čísla do dvojkové soustavy a začít řešit problémy.

Algoritmy a datové struktury Ve druhé kapitole jsme se naučili, jak popsat požadavky na problém pomocí rozhraní a pravidel. V této části upřesníme konceptuální model jednotlivých komponent do podoby jasně definovaných algoritmů a datových struktur. Algoritmus je postup popsaný jako konečný počet pravidel pro splnění určitého úkolu. Pravidla musí být jednoznačná a musí být zaručeno jejich ukončení po konečném počtu aplikací. (Slovo je pojmenováno po perském matematikovi al-Khowarizmi z devátého století.) Algoritmus leží na půli cesty mezi nepřesnými direktivami lidské řeči, jako například "Seřaďte prosím tato písmena chronologicky", a přesnými direktivami počítačového jazyka, jako například "BEGIN 2DUP < IF . . . . " atd. Algoritmus pro chronologické řazení písmen by mohl vypadat takto: 1. Vezměte neuspořádaný dopis a poznamenejte si jeho datum. 2. Najděte složku korespondence pro daný měsíc a rok.

Algoritmy a datové struktury 119

3. Listujte dopisy ve složce, začněte od začátku, dokud nenajdete první dopis s pozdějším datem, než je váš aktuální dopis. 4. Vložte svůj aktuální dopis těsně před dopis datovaný později. (Pokud je složka prázdná, vložte pouze dopis.) Pro stejnou úlohu může existovat několik možných algoritmů. Výše uvedený algoritmus by fungoval dobře pro složky obsahující deset nebo méně dopisů, ale pro složky se stovkou dopisů se pravděpodobně uchýlíte k efektivnějšímu algoritmu, jako je tento: 1. (totéž) 2. (totéž) 3. Pokud datum spadá do první poloviny měsíce, otevřete složku do třetiny. Pokud je dopis, který tam najdete, datován později než váš aktuální dopis, hledejte dál, dokud nenajdete dopis se stejným datem nebo před datem vašeho aktuálního dopisu. Na tomto místě vložte svůj dopis. Pokud je nalezený dopis datován dříve než váš aktuální dopis, hledejte zpět. . . . . . Pochopili jste, o co jde. Tento druhý algoritmus je složitější než první. Při jeho provádění však bude potřeba v průměru méně kroků (protože nemusíte pokaždé hledat čistě od začátku složky), a proto jej lze provést rychleji. Datová struktura je uspořádání dat nebo míst pro data, uspořádané speciálně tak, aby odpovídalo danému problému. V posledním příkladu lze za datovou strukturu považovat kartotéku obsahující složky a složky obsahující jednotlivé dopisy. Nový konceptuální model zahrnuje kartotéky a složky (datové struktury) plus kroky pro provádění kartotéky (algoritmy).

Výpočty vs. datové struktury vs. logika Již dříve jsme uvedli, že nejlepší řešení problému je nejjednodušší adekvátní řešení; u každého problému bychom měli usilovat o co nejjednodušší přístup. Předpokládejme, že musíme napsat kód, který splní toto zadání: je-li vstupní argument 1, výstup je 10 je-li vstupní argument 2, výstup je 12 je-li vstupní argument 3, výstup je 14 Existují tři přístupy, které můžeme použít: Výpočet ( n)

1-

2*

10 +

120 Podrobný návrh/řešení problému

Struktura dat CREATE TABLE 10 C, ( n) 1- TABLE + C@

12 C,

14 C,

Logika ( n)

PŘÍPAD 1 Z 10 ENDOF 2 Z 12 ENDOF 3 Z 14 ENDOF

ENDCASE

V tomto problému je výpočet nejjednodušší. Za předpokladu, že je také adekvátní (rychlost není rozhodující), je výpočet nejlepší. Problém převodu úhlů na sinusy a kosinusy lze implementovat jednodušeji (alespoň z hlediska řádků kódu a velikosti objektu) výpočtem odpovědí než použitím datové struktury. Pro mnoho aplikací vyžadujících trigonometrii je však rychlejší vyhledat odpověď v tabulce uložené v paměti. V takovém případě je nejjednodušším adekvátním řešením použití datové struktury. Ve druhé kapitole jsme představili problém telefonní sazby. V tomto problému se sazby jevily jako libovolné, proto jsme navrhli datovou strukturu: Nejprve Min. Add'1 Mins.

Plná sazba .30 .12

Nižší sazba .22 .10

Nejnižší sazba .12 .06

Použití datové struktury bylo jednodušší než snaha vymyslet vzorec, podle kterého by se tyto hodnoty daly vypočítat. A vzorec by se později mohl ukázat jako chybný. V tomto případě je kód řízený tabulkou jednodušší na údržbu. Ve třetí kapitole jsme navrhli interpret kláves pro náš Drobný editor pomocí rozhodovací tabulky: Klávesa Ctrl-D Ctrl-I backspace atd.

Nevkládání DELETE INSERT-ON BACKWARD

Vkládání INSERT-vypnutí INSERT-vypnutí INSERT<

Stejného výsledku bychom mohli dosáhnout pomocí logiky: CASE CTRL-D OF 'VKLÁDÁNÍ @ IF INSERT-OFF ELSE DELETE THEN CTRL-I OF 'VKLÁDÁNÍ @ IF INSERT-OFF ELSE INSERT-ON THEN BACKSPACE OF 'VKLÁDÁNÍ @ IF INSERT< ELSE BACKWARD THEN ENDCASE

ENDOF ENDOF ENDOF

Výpočty vs. datové struktury vs. logika 121

ale logika je více matoucí. A použití logiky k vyjádření takového vícepodmínečného algoritmu se ještě více zamotá, pokud v původním návrhu nebyla použita tabulka. Použití logiky se stává účelným, když výsledek není vypočitatelný nebo když rozhodnutí není natolik složité, aby si vyžádalo rozhodovací tabulku. Osmá kapitola je věnována problematice minimalizace použití logiky v programech. Tip 4.23

Při výběru přístupu, který použijete k řešení problému, dávejte přednost v následujícím pořadí: 1. výpočet (kromě případů, kdy záleží na rychlosti) 2. datové struktury 3. logika

Jednou z příjemných vlastností modulárních jazyků, jako je Forth, je samozřejmě to, že skutečná implementace komponenty - ať už používá výpočet, datové struktury nebo logiku - nemusí být pro zbytek aplikace viditelná.

Řešení problému: Výpočet římských číslic V této části se pokusíme ukázat proces návrhu lexikonu. Spíše než v pouhé prezentaci problému a jeho řešení doufám, že tento problém společně rozlouskneme. (Své myšlenkové pochody jsem si zaznamenával, když jsem tento problém původně řešil). Uvidíte prvky dříve uvedených pokynů pro řešení problému, ale uvidíte také jejich aplikaci ve zdánlivě nahodilém pořadí - stejně jako by tomu bylo ve skutečnosti. Tady to je: Problém spočívá v napsání definice, která spotřebuje číslo na zásobníku a zobrazí ho jako římskou číslici. Tento problém s největší pravděpodobností představuje součást většího systému. V průběhu řešení tohoto problému pravděpodobně skončíme u definování několika slov, včetně datových struktur. Tento konkrétní lexikon však bude obsahovat pouze jedno jméno, ROMAN, a bude si brát svůj argument ze zásobníku. (Ostatní slova budou interní pro danou komponentu.) Když jsme se tedy rozhodli pro vnější syntaxi, můžeme nyní přistoupit k vymýšlení algoritmů a datových struktur. Budeme postupovat vědeckou metodou - budeme pozorovat realitu, modelovat řešení, testovat ho proti realitě, upravovat řešení atd. Začneme tím, že si připomeneme, co víme o římských číslicích. Ve skutečnosti si žádná formální pravidla o římských číslicích nepamatujeme. Pokud nám však zadáte číslo, můžeme z něj římskou číslici vytvořit. Víme, jak to udělat - ale zatím neumíme tento postup uvést jako algoritmus. Podívejme se tedy na prvních deset římských číslic:

122 Podrobný návrh/řešení problému

I II III IV V VI VII VIII IX X Provedeme několik pozorování. Zaprvé je tu myšlenka tahu, kdy číslo reprezentujeme tím, že uděláme tolik značek (3 = III). Na druhé straně se používají speciální symboly pro znázornění skupin (5 = V). Ve skutečnosti se zdá, že nemůžeme mít více než tři I za sebou, než použijeme větší symbol. Za druhé, kolem pětky existuje symetrie. Existuje symbol pro pět (V) a symbol pro deset (X). Vzorec I, II, III se opakuje i v druhé polovině, ale s předcházejícím V. Jeden menší než pět se píše IV a jeden menší než deset se píše IX. Zdá se, že uvedení "I" před symbolem větší hodnoty je jako říkat "oneless-than . . "To jsou jen mlhavé a nejasné postřehy. Ale to nevadí. Ještě nemáme celý obrázek. Prozkoumejme, co se děje nad deset: XI XII XIII XIV XV XVI XVII XVIII XIX XX Je to přesně ten samý vzorec jako předtím, jen s jedním "X" navíc. Takže i zde se opakuje cyklus desítky. Pokud se podíváme na dvacítky, jsou stejné, se dvěma "X"; třicítky se třemi "X". Ve skutečnosti je počet "X" stejný jako číslo ve sloupci desítek původního desetinného čísla. To se zdá být důležitý postřeh: naše desetinné číslo můžeme rozložit na desetinné číslice a s každou číslicí zacházet samostatně. Například číslo 37 můžeme zapsat jako XXX (třicet)

Řešení úlohy: Výpočet římských číslic 123

následované VII (sedm) Možná je to předčasné, ale už teď vidíme metodu, kterou nám Forth umožní rozložit číslo na desetinné číslice - pomocí modulo dělení deseti. Řekneme-li například 37 10 /MOD, dostaneme na zásobníku sedmičku a trojku (trojka - tedy kvocient - je nahoře.) Tato pozorování však vyvolávají otázku: A co pod desítkou, kde není místo pro desítku? Jedná se o zvláštní případ? No, pokud budeme uvažovat, že každé "X" představuje desítku, pak nepřítomnost "X" představuje nulu. Nejde tedy o zvláštní případ. Náš algoritmus funguje i pro čísla menší než deset. Pokračujme v našem pozorování a věnujme zvláštní pozornost cyklům deseti. Všimneme si, že čtyřicet je "XL". To je analogické tomu, jako by čtyřka byla "IV", jen posunutá o hodnotu deseti. Písmeno "X" před písmenem "L" říká "deset-méně než padesát". Podobně L LX LXX LXXX XC C

(50) (60) (70) (80) (90) (100)

je analogické k " " " " "

V VI VII VIII IX X

(5) (6) (7) (8) (9) (10)

Stejné zákonitosti zřejmě platí pro jakoukoli desetinnou číslici - mění se pouze samotné symboly. Každopádně je nyní jasné, že máme co do činění s v podstatě desítkovou soustavou. Kdybychom na to byli tlačeni, mohli bychom dokonce vytvořit model systému pro zobrazení římských číslic od 1 do 99 pomocí kombinace algoritmu a datové struktury.

Datová struktura Tabulka jedniček 0 1 I 2 II 3 III 4 IV 5 V 6 VI 7 VII 8 VIII 9 IX

124 Podrobný návrh/řešení problému

Desítková tabulka 0 1 X 2 XX 3 XXX 4 XL 5 L 6 LX 7 LXX 8 LXXX 9 XC

Algoritmus Vydělte n deseti. Kvocient je číslice sloupce desítek; zbytek je číslice sloupce jedniček. Vyhledejte číslici desítky v tabulce desítek a vypište odpovídající vzor symbolu. Vyhledejte číslici jedniček v tabulce jedniček a vypište odpovídající vzor symbolu. Například, je-li číslo 72, kvocient je 7, zbytek je 2. 7 v desítkové tabulce odpovídá "LXX", takže ji vytiskněte. 2 ve sloupci jedniček odpovídá "II", takže to vypište. Výsledek: LXXII Právě jsme sestavili model, který funguje pro čísla od jedné do 99. Jakékoli vyšší číslo by vyžadovalo také stovkovou tabulku spolu s počátečním dělením 100. Právě popsaný logický model by mohl být uspokojivý, pokud splňuje zadání. Ale nějak se nezdá, že bychom problém zcela vyřešili. Vyhnuli jsme se řešení, jak vytvořit základní vzor uložením všech možných kombinací do řady tabulek. Dříve v této kapitole jsme si všimli, že výpočet odpovědi, pokud je to možné, může být jednodušší než použití datové struktury. Protože se tato kapitola zabývá vymýšlením algoritmů, pojďme na to úplně od začátku. Hledejme obecný algoritmus pro výrobu libovolné číslice, který by používal pouze základní sadu symbolů. Naše datová struktura by měla obsahovat pouze toto množství informací: I V X L C D M Při výčtu symbolů jsme je také uspořádali způsobem, který se nám zdá správný. Všechny symboly v levém sloupci jsou násobky deseti, symboly v pravém sloupci jsou násobky pěti. Kromě toho mají symboly v každém řádku desetinásobek hodnoty symbolů přímo nad nimi. Další rozdíl, všechny symboly v prvním sloupci lze kombinovat v násobcích, jako "XXXIII". Nelze však mít násobky žádného ze symbolů v pravém sloupci, například VVV. Je toto pozorování užitečné? Kdo ví? Nazvěme symboly v levém sloupci JEDNOTLIVCI a v pravém sloupci ČTYŘLIVCI. ONERS představují hodnoty 1, 10, 100 a 1 000; to znamená hodnotu jedna na každém možném desetinném místě. Symboly FIVERS představují hodnoty 5, 50 a 500, tedy hodnotu pět na každém možném desetinném místě. Pomocí těchto výrazů namísto samotných symbolů bychom měli být schopni vyjádřit algoritmus pro výrobu libovolné číslice. (Od druhu symbolů jsme odečetli skutečné symboly.) Můžeme například uvést následující předběžný algoritmus: Pro libovolnou číslici vypište tolik ONER, kolik je potřeba k sečtení dané hodnoty.

Algoritmus 125

Pro 300 tedy dostaneme "CCC", pro 20 dostaneme "XX", pro jednu dostaneme "I". A pro 321 dostaneme "CCCXXI". Tento algoritmus funguje, dokud není číslice 4. Nyní budeme muset náš algoritmus rozšířit, aby pokryl tuto výjimku: Pokud je číslice 4, vytiskneme tolik ONER, kolik je potřeba k sečtení hodnoty, ale pokud je číslice 4, vytiskneme ONER a pak FIVER. Tedy 40 je "XL"; 4 je "IV".

Toto nové pravidlo funguje, dokud je číslice 5. Jak jsme si již dříve všimli, číslice pět a vyšší začínají symbolem FIVER. Naše pravidlo tedy opět rozšíříme: Pokud je číslice 5 a více, začínáme symbolem FIVER a od hodnoty odečteme pět, jinak neděláme nic. Poté vypište tolik JEDNOTEK, kolik je potřeba k sečtení hodnoty. Pokud je však číslice 4, vytiskněte pouze ONER a FIVER.

Toto pravidlo funguje, dokud číslice není 9. V takovém případě musíme vytisknout ONER předcházející a-co? A ONER od nejbližšího vyššího desetinného místa (další řádek níže). Říkejme tomu TENER. Náš kompletní model tedy zní: Pokud je číslice 5 nebo více, začneme číslicí FIVER a od hodnoty odečteme pět; v opačném případě neděláme nic. Poté vypište tolik JEDNOTEK, kolik je potřeba k doplnění hodnoty. Pokud je však číslice 4, vytiskněte pouze ONER a FIVER, nebo pokud je 9, vytiskněte pouze ONER a TENER.

Nyní máme k dispozici českou verzi našeho algoritmu. Ještě nám však zbývá několik kroků, než jej budeme moci spustit na našem počítači. Zejména musíme upřesnit výjimky. Nemůžeme prostě říci: Udělejte a, b a c. Ale v takovém a takovém případě udělejte něco jiného.

Protože počítač udělá a, b a c dříve, než se dozví něco lepšího. Místo toho musíme před tím, než uděláme něco jiného, zkontrolovat, zda se výjimky použijí. Tip 4.24

Při vymýšlení algoritmu uvažujte o výjimkách jako o posledních. Při psaní kódu zpracovávejte výjimky jako první.

To nám říká něco o obecné struktuře našeho slova vyrábějícího číslice. Bude muset začínat testem na výjimky 4/9. V obou těchto případech bude odpovídajícím způsobem reagovat. Pokud se neuplatní ani jedna z výjimek, bude postupovat podle "normálního" algoritmu. Pomocí pseudokódu tedy: : DIGIT ELSE

( n ) 4-OR-9? IF zvláštní případy normální případ THEN ;

126 Podrobný návrh/řešení problému

Zkušený programátor jazyka Forth by tento pseudokód ve skutečnosti nevypisoval, ale spíše by si vytvořil mentální představu struktury pro eliminaci zvláštních případů. Méně zkušenému programátorovi by mohlo pomoci zachytit strukturu ve schématu nebo v kódu, jak jsme to udělali zde. Ve Forthu se snažíme minimalizovat závislost na logice. V tomto případě však potřebujeme podmíněný IF, protože máme výjimku, kterou potřebujeme odstranit. Přesto jsme minimalizovali složitost řídicí struktury tím, že jsme v této definici omezili počet IF THEN na jeden. Ano, stále musíme rozlišovat mezi případem 4 a 9, ale tento strukturální rozměr jsme odložili na nižší úroveň definice - test pro 4 nebo 9 a kód "zvláštního případu". Naše struktura ve skutečnosti říká, že buď 4-výjimka, nebo 9-výjimka musí zakázat provedení normálního případu. Nestačí pouze testovat každou výjimku, jako v této verzi: : DIGIT

( n )

4-CASE? IF ONER FIVER 9-CASE? IF ONER TENER normální případ... ;

TEDY TEDY

protože normální případ není nikdy vyloučen. (Není možné umístit ELSE těsně před normální pád, protože ELSE se musí objevit mezi IF a THEN.) Pokud bychom trvali na samostatném zpracování výjimky 4 a výjimky 9, mohli bychom zařídit, aby každá výjimka předávala další příznak, který by označoval, že k výjimce došlo. Pokud je některý z těchto příznaků pravdivý, pak můžeme vyloučit normální případ: : DIGIT

( n )

4-CASE? DUP IF ONER FIVER THEN 9-CASE? DUP IF ONER TENER THEN OR NOT IF normal case THEN ;

Tento přístup však zbytečně komplikuje definici přidáváním nových řídicích struktur. Necháme to tak, jak to bylo. Nyní máme obecnou představu o struktuře naší hlavní definice. Uvedli jsme: "Pokud je číslice 5 nebo více, začněte s FIVER a odečtěte od hodnoty pět; jinak nedělejte nic. Poté vypište tolik JEDNOTEK, kolik je potřeba, aby se hodnota sečetla.". Přímý překlad těchto pravidel do jazyka Forth by vypadal takto: ( n)

DUP

4 > IF

FIVER 5 -

THEN

ONERS

To je technicky správně, ale pokud známe techniku modulového dělení, uvidíme, že se jedná o přirozenou situaci pro modulové dělení číslem 5. Pokud číslo vydělíme pěti, bude kvocient roven nule (nepravdivý), pokud je číslo menší než pět, a jedničce (pravdivý), pokud je mezi 5 a 9. V případě, že číslo vydělíme pěti, bude kvocient roven nule (nepravdivý). Můžeme jej použít jako logický příznak, který nám řekne, zda chceme mít na začátku pětku: ( n )

5 / IF FIVER THEN ...

Algoritmus 127

Kvocient / příznak se stane argumentem příkazu IF. Navíc zbytek dělení modulo 5 je vždy číslo mezi 0 a 4, což znamená, že (až na naši výjimku) můžeme zbytek použít přímo jako argument příkazu ONERS. Naši větu přepracujeme na ( n )

5 /MOD IF FIVER THEN

ONERS

Vrátíme-li se k oné výjimce, vidíme nyní, že můžeme testovat jak 4, tak 9 jediným testem - totiž zda je zbytek 4. To naznačuje, že můžeme nejprve provést náš 5 /MOD a pak testovat výjimku. Něco takového: : DIGIT ( n ) 5 /MOD OVER 4 = IF IF FIVER THEN ONERS

zvláštní případ POTÉ ;

ELSE

(Všimněte si, že jsme zbytek OVERovali, abychom ho mohli porovnat se 4, aniž bychom ho spotřebovali.) Ukazuje se tedy, že přece jen máme dvojnásobně vnořenou konstrukci IF THEN. Zdá se však, že je to opodstatněné, protože IF THEN zpracovává zvláštní případ. Druhý případ je tak krátká věta "IF FIVER THEN", že sotva stojí za to z ní udělat samostatnou definici. Přesto by to šlo. (Ale my to neuděláme.) Zaměřme se na kód pro zvláštní případ. Uvedeme jeho algoritmus: "Pokud je číslice čtyři, vypište ONER a FIVER. Pokud je číslice devět, vypište ONER a TENER." Můžeme předpokládat, že číslice bude jedna nebo druhá, jinak bychom tuto definici nikdy neprováděli. Otázkou je, jak zjistíme, která to je? Opět můžeme použít kvocient dělení pěti. Pokud je kvocient roven nule, číslice musela být čtyři, v opačném případě to byla devítka. Takže použijeme stejný trik a použijeme kvocient jako logický příznak. Napíšeme: : ALMOST ( kvocient ) IF ONER TENER ELSE

ONER FIVER

POTOM ;

Zpětně si všimneme, že v obou případech vypisujeme ONER. Definici můžeme zjednodušit na: : ALMOST ( kvocient ) ONER IF TENER ELSE FIVER THEN ; Předpokládali jsme, že máme na zásobníku kvocient, který chceme použít. Vraťme se k naší definici DIGIT a ujistěme se, že ji skutečně máme: : DIGIT ( n ) 5 /MOD OVER 4 = IF IF FIVER THEN ONERS

128 Podrobný návrh/řešení problému

ALMOST THEN ;

ELSE

Ukazuje se, že máme nejen kvocient, ale i zbytek pod ním. Obojí si ponecháváme na zásobníku v případě, že provedeme klauzuli ELSE. Slovo ALMOST však potřebuje pouze kvocient. Kvůli symetrii tedy musíme Zbytek ZRUŠIT takto: : DIGIT ( n ) 5 /MOD OVER 4 = IF IF FIVER THEN ONERS

ALMOST TEDY ;

DROP

ELSE

Zde máme kompletní, kódovanou definici pro vytvoření jedné číslice římské číslice. Kdybychom si to chtěli zoufale vyzkoušet, než napíšeme potřebné pomocné definice, mohli bychom velmi rychle definovat lexikon slov pro tisk jedné skupiny symbolů, řekněme řádku ONES: : : : :

ONER ." FIVER ." TENER ." ONERS ( # ?DUP IF

I" ; V" ; X" ; of oners -- ) 0 DO ONER LOOP

THEN ;

před načtením našich definic ALMOST a DIGIT. Ale nejsme tak zoufalí. Ne, toužíme přejít k problému definování slov ONER, PĚTKA a DESETKA tak, aby jejich symboly závisely na tom, jakou desetinnou číslici budeme formátovat. Vraťme se k tabulce symbolů, kterou jsme si nakreslili dříve:

desítky stovky tisíce

ONER I X C M

FIVERs V L D

Všimli jsme si, že potřebujeme také "TENER" - což je ONER v dalším řádku níže. Je to, jako by se tabulka měla ve skutečnosti napsat:

desítky stovky tisíce

ONERs I X C M

ČTYŘI V L D

TENERs X C M

Ale to se zdá být nadbytečné. Můžeme se tomu vyhnout? Možná kdybychom zkusili jiný model, třeba lineární tabulku, jako je tato:

Algoritmus 129

Obrázek 4.8: Mechanická reprezentace: přístup k datové struktuře.

jedničky desítky stovky tisíce

I V X L C D M

Nyní si můžeme představit, že název každého sloupce ("jedničky", "desítky" atd.) ukazuje na ONER daného sloupce. Odtud můžeme také získat PĚTKU každého sloupce tak, že sáhneme o jeden slot níže pod aktuální ONER, a DESÍTKU tak, že sáhneme o dva sloty níže. Je to jako stavět ruku třemi rukama. Můžeme ji připojit ke sloupci ONES, jako na obrázku 4.8a, nebo ji můžeme připojit ke sloupci TENS, jako na obrázku 4.8b, nebo k libovolné mocnině deseti. Zkušený programátor jazyka Forth si pravděpodobně nepředstaví paže, ruce nebo podobné věci. Ale musí existovat silná mentální představa - věc, kterou

130 Podrobný návrh/řešení problémů

myšlení pravého mozku - předtím, než dojde k pokusu o konstrukci modelu pomocí kódu. Začátečníkům, kteří se učí myslet tímto pravomozkovým způsobem, by mohl pomoci následující tip: Tip Pokud máte problémy s přemýšlením o koncepčním modelu, představte si ho - nebo si ho nakreslete - jako mechanické zařízení.

4.25

Naše tabulka je jednoduše pole znaků. Protože jeden znak vyžaduje pouze jeden bajt, udělejme z každého "slotu" jeden bajt. Tabulku nazveme ROMANS: CREATE ROMANS

( jedničky) ( desítky) ( stovky) ( tisíce)

ASCII ASCII ASCII ASCII ASCII

I X C M

C, C, C, C,

ASCII V ASCII L ASCII D

C, C, C,

Poznámka: Toto použití ASCII vyžaduje, aby ASCII bylo "STATE-dependent" (viz dodatek C). Pokud slovo ASCII není ve vašem systému definováno nebo pokud není závislé na stavu, použijte: C, 86 C, 67 C, 68 C, 77 C,

88 C,

76 C,

Konkrétní symbol můžeme z tabulky vybrat tak, že použijeme dva různé offsety najednou. Jeden rozměr představuje desetinné místo: jedničky, desítky, stovky atd. Tato dimenze je provedena jako "aktuální", to znamená, že její stav zůstává stejný, dokud ji nezměníme. Druhá dimenze představuje druh symbolu, který chceme - JEDNIČKA, PĚTKA, DESETKA - v aktuálním desetinném sloupci. Tato dimenze je vedlejší, to znamená, že pokaždé určíme, který symbol chceme. Začněme implementací dimenze "aktuální". Potřebujeme nějaký způsob, jak ukázat na aktuální desetinný sloupec. Vytvoříme proměnnou s názvem COLUMN# (vyslovuje se "číslo sloupce") a necháme ji obsahovat posun do tabulky: Nyní můžeme najít cestu k libovolné "pozici ramene" přičtením obsahu COLUMN# k počáteční adrese tabulky, která je dána ROMANEM: : COLUMN

( -- adr-of-column) ROMANS

COLUMN# @

+ ;

Algoritmus 131

Podívejme se, zda můžeme implementovat jedno ze slov pro zobrazení symbolu. Začneme slovem ONER. Věc, kterou chceme v ONER provést, je EMITOVAT znak. : ONER

EMIT ;

Když budeme pracovat zpětně, EMIT vyžaduje znak ASCII na zásobníku. Jak ho tam dostaneme? Pomocí C@. : ONER

C@ EMIT ;

C@ vyžaduje adresu slotu, který obsahuje požadovaný symbol. Jak tuto adresu získáme? ONER je první "ručička" na pohyblivém rameni - pozice, na kterou již ukazuje COLUMN. Adresa, kterou chceme, je tedy jednoduše adresa vrácená příkazem COLUMN: : ONER

COLUMN

C@ EMIT ;

Nyní napíšeme FIVER. Vypočítá stejnou adresu slotu, pak přidá jedničku, aby získal další slot, a teprve potom načte symbol a emituje jej: : FIVER

COLUMN 1+

C@ EMIT ;

COLUMN 2+

C@ EMIT ;

A TENER je: : TENER

Tyto tři definice jsou nadbytečné. Protože jediným rozdílem mezi nimi je náhodný posun, můžeme náhodný posun ze zbytku definic vyčlenit: : .SYMBOL

( offset)

COLUMN +

C@ EMIT ;

Nyní můžeme definovat: : ONER : FIVER : TENER

O .SYMBOL ; 1 .SYMBOL ; 2 .SYMBOL ;

Nyní nám zbývá jen rozložit naše úplné desetinné číslo na řadu desetinných číslic. Na základě pozorování, která jsme již provedli, by to mělo být snadné. Obrázek 4.9 ukazuje náš dokončený výpis. Voila! Od problému ke konceptuálnímu modelu a ke kódu. Poznámka: toto řešení není optimální. Tento svazek se optimalizační fází nezabývá. Ještě jedna myšlenka: V závislosti na tom, kdo tuto aplikaci používá, možná budeme chtít přidat kontrolu chyb. Faktem je, že nejvyšší symbol, který známe, je M; nejvyšší hodnota, kterou můžeme reprezentovat, je 3 999, neboli MMMCMXCIX.

132 Podrobný návrh/řešení problémů

ROMAN bychom mohli předefinovat následovně: : ROMAN ( n) DUP 3999 >

ABORT" Příliš velký"

ROMAN ;

Moore: Když to uděláte správně, máte určitý pocit správnosti. Možná je to právě tento pocit, který odlišuje Forth od jiných jazyků, kde nikdy nemáte pocit, že jste to udělali opravdu dobře. Ve Forthu je to reakce "Aha!". Máte chuť utéct a někomu to říct. Nikdo to ovšem neocení tak jako vy.

Shrnutí V této kapitole jsme se naučili vyvíjet jednu komponentu, přičemž jsme začali nejprve rozhodnutím o její syntaxi, pokračovali určením jejího algoritmu (algoritmů) a datové struktury (struktur) a skončili implementací ve Forthu. Touto kapitolou dokončíme naši diskusi o návrhu. Ve zbývající části knihy se budeme zabývat stylem a technikami programování.

Literatura [1] G. Polya, Jak to řešit: A New Aspect of Mathematical Method, (Princeton, New Jersey, Princeton University Press). [2] Leslie A. Hart, How the Brain Works, c 1975 Leslie A. Hart, (New York, Basic Books, Inc., 1975). [3] Evan Rosen, "High Speed, Low Memory Consumption Structures", 1982 FORML Conference Proceedings, str. 191. [4] Michael Stolowitz, "A Compiler for Programmable Logic in FORTH", 1982 FORML Conference Proceedings, str. 257.

Pro další přemýšlení Navrhněte komponenty a popište algoritmus(y) potřebný(é) k simulaci míchání balíčku karet. Váš algoritmus vytvoří pole čísel 0-51 uspořádaných v náhodném pořadí. Zvláštním omezením tohoto problému je samozřejmě to, že žádná karta se nesmí v poli objevit dvakrát. Můžete předpokládat, že máte generátor náhodných čísel s názvem CHOOSE. Jeho argumentem na zásobníku je "n"; vytváří náhodné číslo mezi nulou a n-1 včetně. (Viz Praktická nápověda, desátá kapitola, Začínáme ve Forthu.)

Shrnutí 133

Obrázek 4.9: Řešení římských číslic. 0 1 2 3 4 5 6 7 8 9

Obrazovka č. 20 \ Římské číslice CREATE ROMANS ( jedničky) ASCII I C, ( desítky) ASCII X C, ( stovky) ASCII C C, ( tisíce) ASCII M C, VARIABLE COLUMN# ( current_offset) : ONES O COLUMN# ! ; : TENS 2 COLUMN# ! ; : HUNDREDS 4 COLUMN# ! ; : THOUSANDS 6 COLUMN# ! ;

8/18/83 ASCII V ASCII L ASCII D

C, C, C,

10 11

: COLUMN ( -- adresa sloupce) ROMANS

COLUMN# @

+ ;

12

0 1 2 3 4

\ : : : :

Římské číslice pokračování .SYMBOL ( offset -- ) ONER O .SYMBOL ; FIVER 1 .SYMBOL ; TENER 2 .SYMBOL ;

Okénko č. 21 Sloupec +

8/18/83

C@ EMIT ;

5 6 7 8 9 10 11 12

: JEDNOTKY ( #-jednotek -- ) ?DUP IF O DO JEDNOTKY LOOP THEN ; : ALMOST ( kvocient z-5/ -- ) JEDNOTKA IF TENER ELSE FIVER THEN ; : DIGIT ( číslice -- ) 5 /MOD OVER 4 = IF ALMOST DROP ELSE JEDNOTKY THEN ;

IF FIVER THEN

13

0 1 2 3 4

Okénko č. 22 \ Římské číslice pokračování : ROMAN ( číslice --) 1000 /MOD TISÍC DIGIT 100 /MOD STO DIGIT 10 /MOD DESÍT DIGIT JEDNA DIGIT

8/18/83

;

5

Můžete navrhnout algoritmus třídění karet tak, aby se vyhnul časově náročné zátěži kontroly určitého neurčitého počtu slotů při každém průchodu smyčkou? Můžete tak učinit s použitím pouze jednoho pole?

134 Podrobný návrh/řešení problému

PĚT

Implementace: Prvky stylu Forth

Špatně napsanému Forthu se vyčítá, že vypadá jako "kód, který prošel kompaktorem na odpadky". Je to pravda, Forth poskytuje větší volnost ve způsobu psaní aplikací. Ale tato svoboda nám také dává možnost psát skvěle čitelný a snadno udržovatelný kód, pokud vědomě používáme prvky dobrého stylu jazyka Forth. V této kapitole se budeme zabývat konvencemi kódování jazyka Forth, včetně: - Kéž bych mohl všem doporučit seznam pevně daných konvencí. Bohužel takový seznam může být v mnoha situacích nevhodný. Tato kapitola slučuje mnoho všeobecně přijímaných konvencí s osobními preferencemi, komentovanými alternativními nápady a důvody těchto preferencí. Jinými slovy: : TIP

HODNOTOVÝ ÚSUDEK ;

Zvláště bych chtěl poděkovat Kimovi Harrisovi, který navrhl mnoho konvencí popsaných v této kapitole, za jeho pokračující úsilí o sjednocení rozdílných názorů na správný styl Forthu.

Organizace výčtu Dobře organizovaná kniha má jasně vymezené kapitoly s jasně definovanými oddíly a obsah, který vám pomůže přehledně zjistit organizaci. Dobře organizovaná kniha se snadno čte. Špatně organizovaná kniha ztěžuje porozumění a téměř znemožňuje pozdější vyhledávání informací. Nutnost dobré organizace platí i pro seznam aplikací. Dobrá organizace má tři aspekty: 1. Rozložení

136 Provádění: 1. Uspořádání a uspořádání. 2. Uspořádání a uspořádání: Prvky stylu Forth

Stále nechápu, jak tyto programovací konvence zvyšují čitelnost.

2. Kompozice 3. Rozdělení disku

Dekompozice Jak jsme již viděli, organizace výpisu by měla sledovat dekompozici aplikace na lexikony. Obecně by tyto lexikony měly být řazeny v pořadí "použití". Používané lexikony by měly předcházet lexikonům, které je používají. V širším měřítku by měly být prvky ve výčtu uspořádány podle stupně složitosti, přičemž nejsložitější varianty by se měly objevit až na konci. Nejlepší je uspořádat věci tak, abyste mohli vynechat nejposlednější obrazovky (tj. nenačítat je) a přesto měli soběstačnou, běžící aplikaci, která funguje správně až na absenci pokročilejších funkcí. Umění dekompozice jsme obšírně probrali ve třetí kapitole.

Kompozice Kompozice je skládání jednotlivých částí tak, aby vznikl celek. Dobrá kompozice vyžaduje stejné umění jako dobrá dekompozice. Jednou ze současných konvencí jazyka Forth je, že zdrojový kód se nachází v "obrazovkách", což jsou jednotky 1K hromadné paměti. (Termín "obrazovka" označuje blok používaný speciálně pro zdrojový kód.) Ve Forthu je možné řetězit každou obrazovku kódu s další, čímž se celý výpis lineárně propojí jako dlouhý pergamenový svitek. Tento přístup není užitečný. Namísto toho je vhodné použít tzv: Tip 5.1

Výpis aplikace strukturujte jako knihu: hierarchicky.

Aplikace se může skládat z: Obrazovky: nejmenší jednotka zdrojového kódu Forthu Lexikony: jedna až tři obrazovky, které stačí k implementaci komponenty Kapitoly: řada souvisejících lexikonů a Načítací obrazovky: obdoba obsahu, obrazovka, která načítá kapitoly ve správném pořadí.

Obrazovka načítání aplikace Na obrázku 5.1 je příklad obrazovky načítání aplikace. Protože se nachází na obrazovce 1, můžete celou tuto aplikaci načíst zadáním 1 LOAD

138 Provedení: Prvky stylu Forth

0 1 2 3 4 5 6 7 8 9 10 11

Obrázek 5.1: Příklad obrazovky pro načtení aplikace. Obrazovka č. 1 \ QTF+ Načítací obrazovka : RELEASE# ." 2.01" ; 9 LOAD \ nástroje překladače, jazykové primitivy 12 LOAD \ video primitivy 21 LOAD \ editor 39 LOAD \ řádkové zobrazení 48 LOAD \ formátovač 69 LOAD \ boxy 81 LOAD \ odklad 90 LOAD \ rámování 96 LOAD \ štítky, obrázky, tabulky 102 LOAD \ generátor obsahu

07/09/83

12 13 14 15

Jednotlivé příkazy načítání v rámci této obrazovky načítají kapitoly aplikace. Například obrazovka 12 je načítací obrazovka pro kapitolu video primitivy. Jako referenční nástroj vám obrazovka načtení aplikace říká, kde najdete všechny kapitoly. Pokud se například chcete podívat na rutiny, které provádějí rámování, můžete vidět, že tato kapitola začíná na obrazovce 90. Každá obrazovka načtení kapitoly postupně načte všechny obrazovky, které danou kapitolu tvoří. Některé formáty obrazovek načítání kapitol si prostudujeme za chvíli. Hlavní výhodou tohoto hierarchického schématu je, že můžete načíst libovolnou sekci nebo libovolnou obrazovku samostatně, aniž byste museli načítat celou aplikaci. Modularita zdrojového kódu je jednou z příčin rychlé rychlosti Forthu při úpravách, načítání a testování (nezbytné pro iterativní přístup). Podobně jako stránky knihy lze ke každé obrazovce přistupovat samostatně a rychle. Jedná se o přístup k údržbě zdrojového kódu s "náhodným přístupem". Jakoukoli pasáž kódu můžete také nahradit novou, zkušební verzí pouhou změnou čísla obrazovky v načítací obrazovce. Nemusíte přesouvat velké pasáže zdrojového kódu v rámci souboru. V malých aplikacích nemusí být takové věci jako kapitoly. Na obrazovce načítání aplikace se přímo načtou všechny lexikony. Ve větších aplikacích však může další úroveň hierarchie zlepšit udržovatelnost. Obrazovka by měla být buď obrazovkou načítání, nebo obrazovkou kódu, nikoli jejich kombinací. Vyvarujte se vkládání příkazu LOAD nebo THRU doprostřed obrazovky obsahující definice jen proto, že "něco potřebujete" nebo že vám "došlo místo".

Obrazovka načítání aplikace 139

Příkazy pro přeskočení Dva příkazy umožňují snadno řídit, co se v každé obrazovce načte a co se ignoruje. Jedná se o tyto příkazy: \ \S se také nazývá EXIT \ se vyslovuje "přeskočit řádek". Způsobí, že interpret Forthu ignoruje vše, co je na stejném řádku napravo od něj. (Protože \ je slovo jazyka Forth, musí za ním následovat mezera.) Nevyžaduje oddělovač. Na obrázku 5.1 vidíte \ použité dvěma způsoby: pro začátek řádku s komentářem na obrazovce (řádek 0) a pro začátek komentářů na jednotlivých řádcích, které nemají žádný další kód napravo od komentáře. Během testování slouží \ také k dočasnému "odřádkování" řádků, které již obsahují pravou závorku v názvu nebo komentáři. Například tyto dva "vynechané řádky" zabraňují kompilaci definice NUTATE, aniž by způsobily problémy při setkání s pravou závorkou: \ : NUTATE ( x y z ) \ SWAP ROT (NUTATE) ; \S se vyslovuje "skip-screen". Způsobí, že interpret Forthu přestane zcela interpretovat obrazovku, jako by na obrazovce nebylo nic jiného než \S. V mnoha systémech Forth je tato funkce stejná jako EXIT, což je rutina pro běh středníku. V těchto systémech je použití EXIT přijatelné. Některé systémy Forth však z interních důvodů vyžadují pro funkci "skip-screen" jinou rutinu. Definice \ a \S najdete v dodatku C.

Obrazovky pro načítání kapitol Obrázek 5.2 znázorňuje typickou obrazovku pro načítání kapitol. Obrazovky načítané touto obrazovkou jsou odkazovány relativně, nikoli absolutně, jako tomu bylo v obrazovce načítání aplikace. Je to proto, že obrazovka načtení kapitoly je první obrazovkou z navazujícího rozsahu obrazovek v kapitole. Celou kapitolu můžete v rámci výpisu přesunout dopředu nebo dozadu; relativní ukazatele na obrazovce načtení kapitoly jsou nezávislé na poloze. Jediné, co musíte změnit, je jediné číslo na obrazovce načtení aplikace, které ukazuje na začátek kapitoly. Tip 5.2

Na obrazovce načítání aplikace používejte absolutní čísla obrazovek. Na obrazovkách načítání kapitol nebo oddílů používejte relativní čísla obrazovek.

140 Provedení: V případě, že se jedná o obrazovku, která se nachází na obrazovce, je třeba ji upravit: Prvky stylu jazyka Forth

0

Obrázek 5.2: Příklad obrazovky pro načtení kapitoly. Obrazovka č. 100 Načtení kapitoly

\ GRAFIKA

07/11/83

1 2 3 4 5 6

1 2 4 8 9

FH FH FH FH FH FH FH

ZATÍŽENÍ 3 FH AŽ 7 FH AŽ ZATÍŽENÍ 11 FH AŽ

\ \ \ \ \

primitivy kreslení bodů primitivy kreslení čar měřítko, rotace box kruh

7 8 9 10

CORNER

\ inicializovat relativní polohu na levý dolní roh

11 12 13 14 15

Existují dva způsoby implementace relativního načítání. Nejběžnější je definovat: : +LOAD

( offset -- )

BLK @ +

LOAD ;

a : +THRU ( lo-offset hi-offset -- ) 1+ SWAP DO I +LOAD LOOP ; Můj vlastní způsob, který předkládám jako užitečnější faktoring, vyžaduje jediné slovo, FH (jeho definice viz příloha C). Věta 1 FH LOAD se čte "1 odtud LOAD" a je ekvivalentní 1 +LOAD. Podobně 2 FH

5 FH THRU

se čte "2 odtud, 5 odtud THRU". Někteří programátoři začínají každou kapitolu fiktivním slovem; například : VIDEO-IO ; a uvádějí jeho název v komentáři na řádku, kde se kapitola načítá na obrazovce načítání aplikace. To umožňuje selektivně ZAPOMENOUT na libovolnou kapitolu a načíst ji znovu od tohoto bodu, aniž by bylo nutné se podívat na kapitolu samotnou. V rámci kapitoly první skupina obrazovek obvykle definuje ty proměnné, konstanty a další datové struktury, které jsou v rámci kapitoly globálně potřebné.

Obrazovky pro načtení kapitoly 141

0

Obrázek 5.3: Formát předmluv kapitol od společnosti Moore Products Co. Obrazovka č. 101 KAPITOLA 5 - VÝCHOZÍ/DESTINAČNÍ - MULTILOOP BITOVÉ TRASY

1 2 3 4 5

DOKUMENTY - SEKCE SPECIFIKACE NÁVRHU STRUKTURY KONZOLY - 3.2.7.5.4.1.2.8 3.2.7.5.4.1.2.10

6 7

ABSTRAKT

-

8 9 10 11

Všechny typy řízení souborů E M T Q a R mohou pocházet z regionální družice nebo družice pro zjišťování údajů. Tyto postupy umožňují operátorovi určit, zda kontrola pochází z Regionálního satelitu, či nikoli.

12 13 14 15

0 1 2

Obrazovka č. 102 POZNÁMKY K KAPITOLA - Zda bod pochází z Regionálního satelitu, se určuje podle bitu Regional v BITS, a to následujícím způsobem:

3

1 = Regionální satelit 2 = Satelit pro zjišťování dat

4 5 6

Umístění regionálního bitu v BITS viz část specifikace návrhu - 3.2.7.5.4.1.2.10.

7 8 9 10 11

HISTORIE

-

12 13 14 15

Poté budou následovat lexikony načtené v pořadí "uses". Poslední řádky obrazovky načítání kapitol obvykle vyvolávají všechny potřebné inicializační příkazy. Někteří stylisticky uvědomělejší Forthwriteři začínají každou kapitolu "předmluvou", která obecně pojednává o teorii fungování komponent popisovaných v kapitole. Na obrázku 5.3 je ukázka obrazovky s předmluvou, která demonstruje formát požadovaný u společnosti Moore Products Co. Charles Moore (bez vztahu k Moore Products Co.) přikládá přehlednému hierarchickému výčtu menší význam než já. Moore: Strukturoval jsem aplikace hierarchicky, ale ne nutně výpisy. Moje výpisy jsou uspořádány poměrně nedbale, vůbec ne hierarchicky ve smyslu primitivů na prvním místě.

142 Provádění: Provádění je pro mě důležitější než pro všechny ostatní: Prvky stylu Forthu

Používám LOCATE [známý také jako VIEW; viz praktickou nápovědu v kapitole Starting Forth, kapitola devět]. Výsledkem je, že výpis je mnohem méně pečlivě uspořádaný, protože mám LOCATE, který za mě věci najde. Do výpisů se nikdy nedívám.

-> vs. THRU Pokud jde o relativní načítání, jedním z oblíbených způsobů načítání řady sousedních obrazovek je použití slova --> (vyslovuje se "další blok"). Toto slovo způsobí, že interpret okamžitě přestane interpretovat aktuální obrazovku a začne interpretovat další (s vyšším číslem). Pokud váš systém poskytuje -->, musíte si vybrat mezi použitím příkazu THRU na obrazovce načítání kapitol pro načtení každé série obrazovek, nebo propojením každé série šipkami a načtením pouze první ze série. (Obojí udělat nemůžete; nakonec byste většinu obrazovek načítali vícekrát.) Šipky mají tuto příjemnou vlastnost: Předpokládejme, že uprostřed série změníte obrazovku a pak ji znovu načtete. Zbytek série se načte automaticky. Nemusíte vědět, jaká je poslední obrazovka. To je také nepříjemná věc na šipkách: Neexistuje žádný způsob, jak proces načítání zastavit, jakmile začne. Můžete sestavit mnohem více obrazovek, než je potřeba k otestování této jedné obrazovky. Chcete-li se k tomu postavit analyticky, můžete po provedení právě popsané změny udělat tři věci: 1. načíst pouze tuto jednu obrazovku, abyste změnu otestovali, 2. načíst celou sekci, ve které se obrazovka objevuje, nebo 3. načíst celý zbytek aplikace. Zdá se, že použití THRU vám dává největší kontrolu. Někteří lidé považují šipku za užitečnou pro umožnění definic přesahujících hranice obrazovky. Ve skutečnosti je --> jediným způsobem, jak sestavit definici vysoké úrovně (dvojtečka), která zabírá více než jednu obrazovku, protože --> je "okamžitá". Nikdy však není dobrým stylem nechat definici s dvojtečkou překročit hranice obrazovky. (Nikdy by neměly být tak dlouhé!) Na druhou stranu, extrémně složitý a časově kritický kus kódování v assembleru může zabírat několik po sobě jdoucích obrazovek. V takovém případě však stejně dobře poslouží normální LOADování, protože assembler nepoužívá režim kompilace, a proto nevyžaduje bezprostřednost. A konečně, šipka plýtvá řádkem navíc na každé obrazovce zdrojového kódu. To nedoporučujeme.

-> vs. THRU 143

Alternativa k obrazovkám: Někteří odborníci na Forth obhajují ukládání zdrojového kódu do pojmenovaných textových souborů s proměnnou délkou, čímž záměrně napodobují přístup používaný tradičními kompilátory a editory. Tento přístup se může stávat stále běžnějším, ale jeho užitečnost je stále sporná. Jistě, je příjemné nemuset se obávat, že na obrazovce dojde místo, ale potíže se zápisem v omezeném prostoru jsou kompenzovány zachováním kontroly nad diskrétními částmi kódu. Při vývoji aplikace strávíte mnohem více času načítáním a znovunačítáním obrazovek než přenastavováním jejich obsahu. Soubory "nekonečné délky" umožňují nedbalé, neuspořádané myšlení a špatné faktorizování. Definice se stávají delšími bez disciplíny, kterou ukládají hranice 1K bloků. Vzniká tendence napsat 20K soubor, nebo ještě hůře: 20K definici. Možná by byl pěkným kompromisem systém založený na souborech, který umožňuje vnořené načítání a podporuje používání velmi malých pojmenovaných souborů. S největší pravděpodobností by však zkušenější programátoři Forthu nepoužívali pojmenované soubory delší než 5K až 10K. Jaký je tedy přínos? Někdo by na tuto řečnickou otázku mohl odpovědět: "Je snazší zapamatovat si jména než čísla." Pokud je to tak, pak předdefinujte tato čísla bloků jako konstanty, např: 90 CONSTANT FRAMING Chcete-li pak načíst sekci "rámování", zadejte FRAMING LOAD Nebo chcete-li vypsat blok načítání sekce, zadejte FRAMING LIST (je zvykem, že názvy sekcí končí na "ING".) Samozřejmě, abyste minimalizovali potíže s přístupem založeným na obrazovce, potřebujete dobré nástroje, včetně příkazů editoru, které přesouvají řádky zdroje z jedné obrazovky na druhou, a slov, která posunují řadu obrazovek dopředu nebo dozadu v rámci výpisu.

Rozdělení disku Posledním aspektem dobře organizovaného výpisu je standardizace uspořádání toho, co kam na disku patří. Tyto standardy si musí stanovit každá dílna, oddělení nebo jednotlivý programátor v závislosti na povaze práce. Obrázek 5.4 ukazuje typické schéma rozdělení disku v oddělení. V mnoha obchodech s jazykem Forth se považuje za žádoucí začínat části kódu na číslech obrazovky, která jsou rovnoměrně dělitelná třemi. Hlavní oddíly na disku by měly být provedeny na hranicích rovnoměrně dělitelných třiceti.

144 Implementace: V případě, že se jedná o implementaci, je nutné, aby se na ni podíleli všichni uživatelé: Prvky stylu Forth

Obrázek 5.4: Příklad schématu rozdělení disků v rámci jednoho oddělení. Obrazovka 0 je titulní obrazovka, na které je uveden název aplikace, číslo aktuální verze a hlavní autor. Obrazovka 1 je blok pro načtení aplikace. Obrazovka 2 je vyhrazena pro případné pokračování z obrazovky 1. Obrazovky 4 a 5 obsahují systémové zprávy. Obrazovky 9 až 29 obsahují obecné nástroje potřebné v této aplikaci, ale neomezují se pouze na ni. Obrazovka 30 začíná obrazovky aplikace. Důvod? Podle konvence se obrazovky jazyka Forth tisknou tři na stránku, přičemž horní obrazovka je vždy rovnoměrně dělitelná třemi. Taková stránka se nazývá "triáda"; většina systémů Forth obsahuje slovo TRIAD, které ji vytváří, a jako argument uvádí číslo kterékoli ze tří obrazovek v triádě. Například zadáte-li 77 TRIAD, získáte stránku, která obsahuje 75, 76 a 77. Hlavní výhodou této konvence je, že pokud změníte jedinou obrazovku, můžete novou triádu vložit přímo do pořadače obsahujícího aktuální výpis, čímž nahradíte přesně jednu stránku bez překrývajících se obrazovek. Podobně slovo INDEX uvádí první řádek každé obrazovky, 60 na stránku, na hranicích rovnoměrně dělitelných 60. Tip Začínejte oddíly nebo lexikony na číslech obrazovek rovnoměrně dělitelných třemi. Aplikace nebo kapitoly začínejte na číslech obrazovek rovnoměrně dělitelných třiceti.

5.3

Výběr Prodejci systémů Forth mají problém. Pokud chtějí zahrnout všechny příkazy, které by zákazník mohl očekávat - slova pro ovládání grafiky, tiskáren a další vychytávky -, často zjistí, že systém nabobtnal na více než polovinu kapacity paměti počítače, takže seriózním programátorům zbývá méně místa pro sestavení jejich aplikací. Řešením je, aby dodavatel poskytl holý základ jako předkompilované jádro a další vychytávky poskytl ve formě zdrojových kódů. Tento přístup umožňuje programátorovi vybrat si speciální rutiny, které skutečně potřebuje. Tyto rutiny, které lze načíst uživatelem, se nazývají "volitelné". Aritmetika dvojí délky, podpora data a času, příkazy CASE a konstrukce DOER/MAKE.

Volitelné položky 145

(popsané později) jsou některé z funkcí, které by měly systémy Forth nabízet jako volitelné.

Rozložení obrazovky V této části probereme rozložení jednotlivých zdrojových obrazovek. Tip 5.4

Vyhraďte si řádek 0 jako "řádek pro komentáře".

Komentářový řádek slouží jednak jako záhlaví obrazovky, jednak jako řádek v INDEXU disku. Měl by popisovat účel obrazovky (nikoliv vyjmenovávat slova v ní definovaná). Řádek komentáře obsahuje minimálně název obrazovky. V rozsáhlejších aplikacích můžete uvést i název kapitoly a název obrazovky. Pokud je obrazovka jednou z řady obrazovek implementujících lexikon, měli byste uvést také "číslo stránky". Pravý horní roh je vyhrazen pro "razítko". Razítko obsahuje datum poslední revize a, pokud je důležité autorství, iniciály programátora (tři znaky vlevo od data); např.: ( Název kapitoly

Název obrazovky -- str.

JPJ 06/10/83)

Některé editory jazyka Forth zadají razítko po stisknutí klávesy za vás. Běžný tvar pro vyjádření data je mm-dd-yy, tj. 6. únor 1984 by byl vyjádřen 02-06-84. Stále populárnější alternativa používá ddMmmyy, kde "Mmm" je třípísmenná zkratka měsíce. Například: 22Oct84 Tato forma vyžaduje méně znaků než 10-22-84 a odstraňuje možnou záměnu dat a měsíců. Pokud má váš systém \ ("skip-line" - viz Dodatek C), můžete řádek s komentářem napsat takto: \ Název kapitoly

Název obrazovky -- pg.#

146 Implementace: Prvky stylu Forth

JPJ 06/10/83

Stejně jako u všech komentářů používejte v řádku komentáře malá písmena nebo kombinaci malých a velkých písmen. Jedním ze způsobů, jak v rejstříku aplikace odhalit více o organizaci obrazovek, je odsazení řádku komentáře o tři mezery u obrazovek, které navazují na lexikon. Obrázek 5.5 ukazuje část seznamu vytvořeného programem INDEX, ve kterém jsou řádky komentářů pro pokračující obrazovky odsazeny. Tip Všechny definice začínejte u levého okraje obrazovky a na každém řádku definujte pouze jedno slovo.

5.5

Špatně: : ARRIVING

." HELLO" ;

: PŘIJÍŽDÍ : ODJÍŽDÍ

." HELLO" ; ." GOODBYE" ;

: ODJEZD

." SBOHEM" ;

Dobře:

Toto pravidlo usnadňuje nalezení definice ve výpisu. (Pokud definice pokračují na více než jeden řádek, měly by být následující řádky vždy odsazeny.) Proměnné a proměnné CONSTANT by měly být také definovány po jedné na každém řádku. (Viz "Ukázky správného stylu komentářů" v dodatku E.) Na stejném řádku tak zůstává prostor pro vysvětlující komentář. Výjimkou je velká "rodina" slov (definovaná společným definičním slovem), která nepotřebuje jedinečné komentáře: Obrázek 5.5: Výstup programu INDEX zobrazující odsazené řádky komentářů. 90 91 92 93 94 95 96 97 98 99 100 101 102

\ Zatížení kapitoly Grafika \ Primitiva bodového kreslení \ Primitiva čárového kreslení \ Primitiva čárového kreslení \ Primitiva čárového kreslení \ Měřítko, rotace \ Měřítko, rotace \ Měřítko, rotace \ Měřítko, rotace \ Krabice \ Kruhy \ Kruhy \ Kruhy \ Kruhy

JPJ JPJ JPJ JPJ JPJ JPJ JPJ JPJ JPJ JPJ JPJ JPJ JPJ JPJ JPJ JPJ JPJ JPJ JPJ

06/10/83 06/10/83 06/11/83 06/10/83 09/02/83 06/10/83 02/19/84 02/19/84 02/19/84 06/10/83 06/10/83 06/10/83 06/10/83

Rozložení obrazovky 147

0 ODSTÍN ČERNÉ 3 ODSTÍN AZUROVÉ

1 ODSTÍN MODRÉ 4 ODSTÍN ČERVENÉ

2 ODSTÍN ZELENÉ 5 ODSTÍN PURPUROVÉ

Tip 5.6

V dolní části obrazovky ponechte hodně místa pro pozdější doplnění.

Při prvním průchodu vyplňte každou obrazovku kódem maximálně do poloviny. Iterativní přístup vyžaduje, abyste nejprve načrtli součásti aplikace a pak je iterativně doplňovali, dokud nebudou splněny všechny požadavky. Obvykle to znamená přidání nových příkazů nebo přidání zpracování zvláštních případů do stávajících obrazovek. (Ne však vždy. V nové iteraci může dojít ke zjednodušení kódu. Nebo nová složitost může ve skutečnosti patřit do jiné komponenty a měla by být zohledněna v jiné obrazovce.) Ponechání dostatečného prostoru na začátku zpříjemní pozdější doplňování. Jeden autor doporučuje, aby při prvním průchodu obrazovka obsahovala asi 20-40 % kódu a 80-60 % bílého místa [1]. Mezi jednotlivými definicemi nevynechávejte ani řádek. Můžete však vynechat řádek mezi skupinami definic. Tip 5.7

Na všech obrazovkách musí být BASE nastaveno na hodnotu DECIMAL.

I když máte tři obrazovky za sebou, ve kterých je kód zapsán v HEX (například tři obrazovky kódu assembleru), každá obrazovka musí nahoře nastavit BASE na HEX a dole obnovit base na DECIMAL. Toto pravidlo zajišťuje, že každá obrazovka může být pro účely testování načtena samostatně, aniž by došlo k narušení stavu věcí. Při čtení výpisu také víte, že hodnoty jsou v desítkové soustavě, pokud není na obrazovce výslovně uvedeno HEX. Některé obchody jdou v tomto pravidle ještě dál. Místo toho, aby na konci drze přenastavily základ na DECIMAL, přenastaví základ na to, co bylo na začátku. Této dodatečné pojistky lze dosáhnout tímto způsobem: BASE @ HEX \ uložit původní BASE na zásobník 0A2 KONSTANTNÍ ZVONY 0A4 KONSTANTNÍ PÍSKOTY ... atd. ... BASE ! \ obnovit Někdy se argument předává na zásobníku z obrazovky na obrazovku, například hodnota vrácená příkazem BEGIN nebo IF v definici assembleru s více obrazovkami, nebo adresa báze předávaná z jednoho definičního slova do druhého - viz "Faktorování v době kompilace" v šesté kapitole. V těchto případech je nejlepší uložit hodnotu BASE na návratový zásobník takto:

148 Implementace: Prvky stylu jazyka Forth

BASE @ >R ... atd. ... R> BASE !

HEX

Někteří lidé si stanovují zásadu používat tento přístup na každé obrazovce, která mění BASE, aby se o něj nemuseli starat. Moore dává přednost definici LOAD, která po načtení vyvolá DECIMAL. Tento přístup zjednodušuje obsah obrazovky, protože se nemusíte starat o resetování.

Odstupy a odsazení Tip Odstupy a odsazení jsou nezbytné pro čitelnost.

5.8

Příklady v této knize používají všeobecně přijaté konvence stylu prokladů a odsazení. Vhodně použité mezery dodávají čitelnost. Za ponechání místa ve zdrojových obrazovkách nehrozí žádné sankce kromě diskové paměti, která je levná. Pro ty, kteří mají rádi své konvence černé na bílém, je určena tabulka 5.1, která obsahuje seznam zásad. (Nezapomeňte však, že interpretu jazyka Forth jsou mezery a odsazení ukradené.) Poslední pozice každého řádku by měla být prázdná s výjimkou: 1. uvozených řetězců, které pokračují na dalším řádku, nebo tabulky 5. 1: Pravidla pro odsazování a řádkování 1 mezera mezi dvojtečkou a názvem 2 mezery mezi názvem a komentářem* 2 mezery nebo návrat vozíku, za komentářem a před definicí∗ 3 mezery mezi názvem a definicí, pokud není použit komentář 3 mezery odsazení na každém následujícím řádku (nebo násobky 3 pro vnořené odsazení) 1 mezera mezi slovy/čísly uvnitř věty 2 nebo 3 mezery mezi větami 1 mezera mezi posledním slovem a středníkem 1 mezera mezi středníkem a IMMEDIATE (pokud je vyvolán) Žádné prázdné řádky mezi definicemi, s výjimkou oddělení samostatných skupin definic * Často se vyskytující alternativa vyžaduje 1 mezeru mezi názvem a komentářem a 3 mezery mezi komentářem a definicí. Liberálnější technika používá 3 mezery před a za komentářem. Ať už se rozhodnete jakkoli, buďte důslední.

Mezery a odřádkování 149

2. Konec komentáře. Komentář, který začíná \, může pokračovat až na konec řádku. Také komentář, který začíná znakem (, může mít svou ohraničující pravou závorku v posledním sloupci. Zde jsou uvedeny některé běžné chyby v řádkování a odsazování: Špatné (název není oddělen od těla definice): : Dobré: : PUSH

HEAVE HO ;

Špatné (následující řádky nejsou odsazeny o tři mezery): : RIDDANCE ( thing-never-to-darken-again -- ) DARKEN NEVER AGAIN ; Dobrý: : RIDDANCE ( thing-never-to-darken-again -- ) DARKEN NEVER AGAIN ; Špatné (nedostatek frází): : GETTYSBURG

4 BODY PŘED 7 LETY + ;

: GETTYSBURG

4 SCORE

Dobře: 7 let +

PŘED ;

Frázování je subjektivní umění; ještě jsem neviděl užitečný soubor formálních pravidel. Prostě se snažte o srozumitelnost.

Konvence komentářů Vhodné komentáře jsou nezbytné. Existuje pět typů komentářů: komentáře ke stackeffectu, komentáře k datové struktuře, komentáře ke vstupnímu proudu, komentáře k účelu a komentáře k popisu. Komentář stack-effect zobrazuje argumenty, které definice spotřebovává ze zásobníku, a argumenty, které do zásobníku vrací, pokud existují. Komentář k datové struktuře udává pozici a význam prvků v datové struktuře. Například textový buffer může obsahovat počet v prvním bajtu a 63 volných bajtů pro text. Komentář vstupního proudu udává, jaké řetězce word očekává ve vstupním proudu. Například forthovské slovo FORGET hledá ve vstupním proudu jméno slovníkové položky.

150 Implementace: V případě, že se jedná o příkaz, který se používá v jazyce Forth, je možné, že se jedná o příkaz, který se používá v jazyce Forth: Prvky stylu Forth

Komentář k účelu popisuje co nejmenším počtem slov, co daná definice dělá. To, jak definice funguje, není předmětem účelového komentáře. Popisný komentář se objevuje uprostřed definice, aby vysvětlil, o co jde, obvykle řádek po řádku. Popisné komentáře se používají pouze ve "vertikálním formátu", který popíšeme v jedné z dalších částí. Komentáře se obvykle píší malými písmeny, aby se odlišily od zdrojového kódu. (Většina slov jazyka Forth se píše velkými písmeny, ale ve zvláštních případech se někdy používají malá písmena). V následujících kapitolách shrneme standardizované formáty těchto typů komentářů a uvedeme příklady pro každý typ.

Tip pro zápis zásobníku Každá dvojtečka nebo definice kódu, která spotřebovává a/nebo vrací nějaké argumenty na zásobník, musí obsahovat komentář s efektem zásobníku.

5.9

"Zápis zásobníku" označuje konvence pro reprezentaci toho, co je na zásobníku. Mezi formy zápisu zásobníku patří "obrázky zásobníku", "efekty zásobníku" a "komentáře stackeffect".

Obrázek zásobníku Obrázek zásobníku znázorňuje položky, které jsou v daném okamžiku chápány jako položky na zásobníku. Položky jsou uvedeny zleva doprava, přičemž položka úplně vlevo představuje spodní část zásobníku a položka úplně vpravo představuje jeho horní část. Například obrázek zásobníku nl n2 označuje dvě čísla na zásobníku, přičemž n2 je nahoře (na nejdostupnější pozici). V tomto pořadí byste tyto hodnoty zadali, tj. pokud je n1 100 a n2 5000, pak byste zadali 100 5000, abyste tyto hodnoty správně umístili na zásobník. Obrázek zásobníku může obsahovat buď zkratky, jako například "n1", nebo plně napsaná slova. Obvykle se používají zkratky. Některé standardní zkratky jsou uvedeny v tabulce 5.2. Ať už jsou použity zkratky nebo plně rozepsaná slova, každá položka zásobníku by měla být oddělena mezerou. Pokud je položka zásobníku popsána frází (například "address-of-latest-link"), měla by být slova ve frázi spojena pomlčkami. Například obrázek zásobníku:

Zápis zásobníku 151

address current-count max-count zobrazuje tři prvky na zásobníku.

Efekt zásobníku "Efekt zásobníku" zobrazuje dva obrázky zásobníku: jeden obrázek všech prvků, které mohou být spotřebovány definicí, a druhý obrázek všech prvků vrácených definicí. Nejdříve se zobrazí obrázek "před", za ním následují dvě pomlčky a poté obrázek "po". Například efekt zásobníku pro operátor sčítání v jazyce Forth, +, je n n -- součet, kde + spotřebuje dvě čísla a vrátí jejich součet. Pamatujte, že efekt zásobníku popisuje pouze čistý výsledek operace na zásobníku. Ostatní hodnoty, které se náhodou nacházejí na zásobníku pod argumenty, které nás zajímají, není třeba zobrazovat. Stejně tak hodnoty, které se mohou během provádění operace objevit nebo zmizet. Pokud slovo vrací některé vstupní argumenty beze změny, měly by se opakovat ve výstupním obrázku; např. 3. 2. top-vstup -- 3. 2. top-výstup Naopak pokud slovo mění některé argumenty, musí komentář zásobníku používat jiný deskriptor: nl -- n2 n -- n' Efekt zásobníku se může objevit ve formátovaném slovníku.

Komentář k zásobníkovému efektu "Komentář k zásobníkovému efektu" je zásobníkový efekt, který se objevuje ve zdrojovém kódu obklopený závorkami. Zde je komentář stack-effect pro slovo COUNT: ( adresa počítaného řetězce -- adresa textu count) nebo: (Pokud definice nemá žádný efekt na zásobník (tj. žádný efekt, který by si uživatel uvědomil, přestože v definici dochází k jakýmkoli pohybům), nepotřebuje žádný stack-effect komentář: : BAKE

SUŠENKY TROUBA ! ;

Na druhou stranu můžete chtít použít prázdný komentář o zásobníku - tj,

152 Provedení: V případě, že se jedná o zásobník, je třeba, abyste si vybrali, zda chcete, aby se zásobník používal, nebo ne: Prvky stylu Forth

: BAKE

( -- )

SUŠENKY TROUBA ! ;

pro zdůraznění, že slovo nemá žádný vliv na zásobník. Pokud definice spotřebovává argumenty, ale žádné nevrací, je dvojitý znak nepovinný. Například ( address count -- ) lze zkrátit na ( address count) Předpoklad této konvence je následující: Definic s dvojtečkou, které spotřebovávají argumenty a nic nevracejí, je mnohem více než definic, které nic nespotřebovávají a argumenty vracejí.

Standardy zkratek zásobníku Zkratky používané v zápisu zásobníku by měly být konzistentní. Tabulka 5.2 uvádí většinu běžně používaných zkratek. (Tato tabulka se znovu objevuje v dodatku E.) Termíny "single-length", "double-length" atd. se vztahují k velikosti "buňky" v konkrétním systému Forth. (Pokud systém používá 16bitovou buňku, "n" představuje 16bitové číslo; pokud systém používá 32bitovou buňku, "n" představuje 32bitové číslo.)

Zápis příznaků Tabulka 5.2 ukazuje tři způsoby, jak reprezentovat logický příznak. Pro ilustraci uvádíme tři verze téhož komentáře zásobníku pro slovo -TEXT: ( at u a2 -- ?) ( at u a2 -- t=no-match) ( at u a2 -- f=match) Znaménko rovnosti za symboly "t" a "f" ztotožňuje výsledek příznaku s jeho významem. Na straně výsledku druhé verze by se četlo "true znamená žádná shoda".

Zápis možností proměnných Některé definice přinášejí za různých okolností jiný efekt zásobníku. Pokud počet položek na zásobníku zůstává za všech podmínek stejný, ale samotné položky se mění, můžete použít svislou čárku ( | ), která znamená "nebo". Následující komentář k efektu zásobníku popisuje slovo, které vrací buď adresu souboru, nebo, pokud požadovaný soubor není nalezen, nulu: (Pokud se počet položek v obrázku zásobníku může měnit - buď v obrázku "před", nebo "po" - musíte vypsat obě verze celého obrázku zásobníku spolu s dvojtečkou, oddělenou symbolem "nebo". Například:

Standardy pro zkracování zásobníku 153

Tabulka 5.2: Zkratky zásobníku. n číslo s jednou délkou se znaménkem d číslo s dvojnásobnou délkou se znaménkem u číslo s jednou délkou bez znaménka ud číslo s dvojnásobnou délkou bez znaménka t číslo s trojnásobnou délkou q číslo se čtyřnásobnou délkou c 7bitová hodnota znaku b 8bitový bajt ? logický příznak; nebo; t= true f= false a nebo adr adresa acf adresa kódového pole apf adresa parametrového pole ' (jako prefix) adresa sd (jako pár) zdroj cíl lo hi dolní mez horní mez (včetně) # count o offset i index m maska x nezajímá (zápis datové struktury) "Offset" je rozdíl vyjádřený v absolutních jednotkách, například v bajtech. Index" je rozdíl vyjádřený v logických jednotkách, jako jsou prvky nebo záznamy.

-FIND

( -- apf len t=found | -- f=not-found )

Tento komentář označuje, že pokud je slovo nalezeno, jsou vráceny tři argumenty (s příznakem nahoře); v opačném případě je vrácen pouze příznak false. Všimněte si významu druhého znaku "- -". Jeho vynechání by znamenalo, že definice vždy vrací tři argumenty, z nichž horní je příznak. Pokud chcete, můžete celý zásobníkový efekt zapsat dvakrát, buď na stejném řádku, oddělený třemi mezerami: ?DUP

\ pokud je nulový: ( n -- n)

pokud nenulový:( n -- n n)

nebo vypsat vertikálně: -FIND

\ nalezeno:( -- apf len t ) \ nenalezeno:( -- f )

154 Implementace: Prvky stylu Forth

Komentáře k datové struktuře "Komentář k datové struktuře" zobrazuje prvky datové struktury. Například zde je definice vkládací vyrovnávací paměti s názvem |INSERT : CREATE |INSERT

64 ALLOT

\

{ 1# | 63text }

Čelní strany (kudrnaté závorky) začínají a končí komentář struktury; sloupce oddělují jednotlivé prvky struktury; čísla představují bajty na prvek. Ve výše uvedeném komentáři obsahuje první bajt počet a zbývajících 63 bajtů obsahuje text. "Bitový komentář" používá stejný formát jako komentář datové struktury k zobrazení významu bitů v bajtu nebo buňce. Například bitový komentář { 1busy? | 1acknowledge? | 2x | 6input-device | 6output-device } popisuje formát 16bitového stavového registru komunikačního kanálu. První dva bity jsou příznaky, druhé dva bity jsou nevyužité a poslední dvojice šestibitových polí označuje vstupní a výstupní zařízení, ke kterým je tento kanál připojen. Pokud více než jedna datová struktura používá stejný vzor prvků, vypište komentář pouze jednou (případně v preambuli) a vzoru dejte jméno pro odkaz v následujících obrazovkách. Pokud například preambule dává výše uvedenému bitovému vzoru název "status", pak lze v komentářích k zásobníku použít "status" pro označení hodnot s tímto vzorem: : STATUS?

( -- status) ... ;

Pokud 2VARIABLE obsahuje jednu hodnotu dvojí délky, měl by být komentář obrázkem zásobníku, který označuje obsah: 2PROMĚNNÁ CENA

\ cena v centech

Pokud 2VARIABLE obsahuje dva datové prvky o jedné délce, je uveden obrázek zásobníku, který ukazuje, co by bylo na zásobníku po 2@. Tedy: To se liší od komentáře, který by se použil, kdyby se MEASUREMENTS definoval pomocí CREATE. CREATE MEASUREMENTS 4 ALLOT

\ { 2weight | 2height }

(Ačkoli oba příkazy vedou ke stejnému výsledku ve slovníku, použití 2VARIABLE znamená, že hodnoty budou normálně "2 načteny" a "2 uloženy" společně - proto používáme komentář k zásobníku. Část vyššího řádu, která se objevuje na vrcholu zásobníku, je uvedena vpravo. Použití CREATE znamená, že hodnoty budou obvykle načítány a ukládány odděleně - proto používáme komentář k datové struktuře. Položka na 0. pozici je uvedena vlevo).

Komentáře k datové struktuře 155

Komentáře vstupního proudu Komentář vstupního proudu udává, jaká slova a/nebo řetězce se předpokládají ve vstupním proudu. Tabulka 5.3 uvádí označení používaná pro argumenty vstupního proudu. Tabulka 5.3: Označení komentářů vstupního proudu. c název text

jeden znak, prázdná ohraničená posloupnost znaků, prázdná ohraničená posloupnost znaků, ohraničená neprázdnými znaky

Za "text" následuje skutečný požadovaný oddělovač; např.: text" nebo text) Komentář vstupního proudu se objevuje před komentářem zásobníku a není uzavřen mezi vlastní dvojici závorek, ale je jednoduše obklopen třemi mezerami na každé straně. Například zde je jeden ze způsobů, jak okomentovat definici ' (zaškrtávátko), přičemž se nejprve zobrazí komentář vstupního proudu a poté komentář zásobníku: : '

\ jméno

( -- a)

Pokud byste raději použili ( , komentář by vypadal takto: : '

( jméno

( -- a)

Mimochodem, existují tři různé způsoby přijímání řetězcového vstupu. Aby nedocházelo k záměně, uvádíme jednotlivé termíny: Skenování znamená hledání slova nebo čísla ve vstupním proudu, jako v případě zaškrtnutí, nebo oddělovače, jako v případě ." a ( . Očekávání znamená čekání. EXPECT a KEY a definice, které je vyvolávají, jsou takové, které "očekávají" vstup. Presuming označuje, že při běžném použití bude něco následovat. Slovo: "očekává" jméno, které má být definováno, a "předpokládá", že definice bude následovat. Komentář input-stream je vhodný pouze pro vstup, který je skenován.

Účel Komentáře Tip 5.10

Každá definice by měla být opatřena účelovým komentářem, pokud: 1. její účel není zřejmý z jejího názvu nebo z komentáře stack-effect, nebo 2. pokud se skládá ze tří nebo méně slov.

156 Provedení: Prvky stylu jazyka Forth

Komentář k účelu by měl být omezen na minimum - nikdy by neměl být delší než celý řádek. Například: : COLD \ obnovit systém do počátečního stavu ... ; Použijte rozkazovací způsob: "nastaví barvu popředí", nikoli "nastaví barvu popředí". Na druhou stranu, účel slova lze často popsat pomocí komentáře se stohovým efektem. Zřídkakdy potřebujete jak komentář zásobníku, tak komentář účelu. Například: : SPACES

( #)

... ;

: SPACES

( #spaces-to-type -- )

nebo ... ;

Tato definice přijímá jako vstupní argument číslo, které představuje počet mezer k zadání. : ELEMENT

( element# -- 'element) 2*

TABLE + ;

Tato definice převádí index, který spotřebovává, na adresu v rámci tabulky 2bajtových prvků odpovídající indexovanému prvku. : PAD

( -- 'scratch-pad) ZDE

80 + ;

Tato definice vrací adresu scratch oblasti paměti. Někdy je pro čitelnost nejvhodnější uvést oba typy komentářů. V takovém případě by se účelový komentář měl objevit jako poslední. Například: : BLOCK

( n -- a)

\

zajistí blok n ve vyrovnávací paměti při a

Tip Uveďte typ komentáře podle pořadí: nejprve komentáře ke vstupnímu proudu, poté komentáře ke stackeffectu, nakonec účelové komentáře.

5.11

Například: : GET

\

name

( -- a)

získá první shodu

Pokud dáváte přednost použití (, pak napište: : GET

(

name

( -- a)

( získejte první shodu)

V případě potřeby můžete na druhý řádek vložit účelový komentář: : \ jméno ( c -- a) \ hledat řetězec oddělený znakem "c"; ponechat na a ... ;

Účelové komentáře 157

Komentáře k definičním slovům Definice definičního slova zahrnuje dvě chování: - chování definujícího slova, když definuje svého "potomka" (chování v době kompilace), a - chování samotného potomka (chování v době běhu). Tato dvě chování je třeba komentovat odděleně. Tip 5.12

Chování definujícího slova v době kompilace komentujte obvyklým způsobem; jeho chování v době běhu komentujte zvlášť, za slovem DOES> (nebo ;CODE).

Například : CONSTANT ( n ) CREATE , DOES> ( -- n) @ ; Komentář k chování v době běhu (podřízeného slova) představuje čistý efekt zásobníku pro podřízené slovo. Nezahrnuje tedy adresu vrácenou DOES>, přestože tato adresa je na zásobníku v okamžiku zahájení run-time kódu. Špatně (komentář run-time obsahuje apf): : ARRAY \ name ( #cells) CREATE 2* ALLOT DOES> ( i apf -- 'cell)

SWAP

2* + ;

Dobrý: : ARRAY \ name ( #cells) CREATE 2* ALLOT DOES> ( i -- 'cell) SWAP

2* + ;

Slova definovaná tímto slovem ARRAY budou vykazovat stohový efekt: ( i -- 'cell) Pokud definující slovo neurčuje chování za běhu, stále existuje chování za běhu a může být komentováno: : VARIABLE \ does>

( name ( -- ) ( -- adr )

158 Implementace: Prvky stylu Forth

CREATE

2 ALLOT ;

Komentáře k sestavovacím slovům Stejně jako u definičních slov zahrnuje většina sestavovacích slov dvě chování: 1. Kompilující slovo, když je kompilována definice, ve které se objevuje. 2. Rutina, která se spustí, když zavoláme definované slovo. Opět musíme každé chování komentovat zvlášť. Tip Chování kompilujícího slova v době běhu komentujte obvyklým způsobem; jeho chování v době kompilace komentujte zvlášť a začněte označením "Compile:".

5.13

Například: : IF ( ? -- ) ... \ Compile: (V případě kompilujících slov první komentář popisuje chování v době běhu, což je obvykle syntaxe pro použití slova. Druhý komentář popisuje, co slovo při kompilaci skutečně dělá (což je pro uživatele méně důležité). Další příklady: : \ Compile: text": ABORT" ( ? -- ) \ Compile: text"

( -- )

Příležitostně může slovo při kompilaci vykazovat odlišné chování, pokud je vyvoláno mimo definici dvojtečky. Taková slova (abychom byli úzkostliví) vyžadují tři komentáře. Například: : ASCII ( -- c) \ Compile: c ( -- ) \ Interpret: c ( -- c ) ... ; IMMEDIATE Příloha E obsahuje dvě obrazovky ukazující správný styl komentování.

Vertikální formát vs. horizontální formát Účelem komentářů je umožnit čtenáři vašeho kódu snadno zjistit, o co jde. Kolik komentářů je však potřeba? Chcete-li určit úroveň komentářů vhodnou pro vaše podmínky, musíte si položit dvě otázky: - Kdo bude můj kód číst?

Komentáře pro sestavování slov 159

- Jak čitelné jsou mé definice? Existují dva základní styly komentování, z nichž si můžete vybrat. První styl, často nazývaný "vertikální formát", obsahuje popis postupu krok za krokem na způsob dobře okomentovaného výpisu jazyka assembleru. Těmto řádkovým komentářům se říká "narativní komentáře". \ CRC Checksum 07/15/83 : ACCUMULATE ( oldcrc char -- newcrc) 256 * \ shift char to hi-order byte XOR \ & xor into previous crc 8 0 DO \ Then for eight repetitions, DUP 0< IF \ if hi-order bit is "1" 16386 XOR \ xor it with mask and DUP + \ shift it left one place 1+ \ set lo-order bit to "1" ELSE \ otherwise, i. DUP + \ posuňte jej o jedno místo doleva THEN LOOP ; \ dokončete smyčku Jiný přístup neprokládá komentáře mezi frázemi kódu. Tomuto způsobu se říká "horizontální formát". : ACCUMULATE ( oldcrc char -- newcrc) 256 * XOR 8 0 DO DUP 0< IF 16386 XOR DUP + 1+ ELSE DUP +

THEN

LOOP ;

Vertikální formát se upřednostňuje v případě, že aplikaci kóduje a udržuje velký tým programátorů. Obvykle takový tým zahrnuje několik programátorů na nižší úrovni, kteří jsou zodpovědní za drobné opravy. V takovém prostředí může pečlivé komentování ušetřit mnoho času a rozčilení. Jak říká Johnson ze společnosti Moore Products Co: "Při údržbě kódu vás obvykle zajímá jen jedna malá část, a čím více informací tam napíšete, tím větší máte šanci na rychlou opravu." Zde je několik relevantních pravidel vyžadovaných od programátorů Forthu ve společnosti Moore Products Co. (parafrázuji): 1. Bude se používat vertikální formát. Komentáře se budou zobrazovat vpravo od zdrojového kódu, ale v případě potřeby mohou pokračovat až do úplného pohlcení dalšího řádku. 2. Znaků komentáře by mělo být více než znaků zdrojového kódu. (Společnost podporuje dlouhé popisné názvy, delší než deset znaků, a umožňuje, aby se názvy započítávaly jako znaky komentáře). 3. Jakákoli podmíněná struktura nebo aplikační slovo by se měly objevit na samostatném řádku. "Šumová slova" mohou být seskupena dohromady. Odsazení se používá pro zobrazení vnořených podmiňovacích výrazů.

160 Provedení: Prováděcí pravidla jsou uvedena v příloze č. 1: Prvky stylu jazyka Forth

S tímto formátem jsou však spojeny určité potíže. Za prvé, komentování po řádcích je časově náročné, a to i s dobrým editorem obrazovky. Produktivita může být potlačena, zejména když zastavení při psaní komentářů přeruší řetězec myšlenek. Kromě toho musíte také pečlivě dbát na aktuálnost komentářů. Velmi často se stává, že je kód opraven, revize je otestována, změna funguje - a programátor zapomene komentáře změnit. Čím více je komentářů, tím větší je pravděpodobnost, že budou chybné. Pokud jsou chybné, jsou horší než zbytečné. Tento problém lze zmírnit, pokud vedoucí projektu pečlivě kontroluje kód a dbá na správnost komentářů. A konečně, komentování po řádcích může umožnit falešný pocit bezpečí. Nepředpokládejte, že když je každý řádek opatřen komentářem, je aplikace dobře okomentovaná. Komentování po řádcích se nezabývá významnými aspekty fungování definice. Co například stojí za použitým algoritmem kontrolního součtu? Kdo to ví z komentářů k příběhu? Řádně popsat v próze důsledky daného postupu obvykle vyžaduje mnoho odstavců, ne jednu větu. Takové popisy správně patří do pomocné dokumentace nebo do preambule kapitoly. Navzdory těmto varováním považuje mnoho společností vertikální formát za nezbytný. Jistě by si jej měl osvojit tým, který se nově seznamuje s jazykem Forth, stejně jako každý velmi rozsáhlý tým. A co horizontální formát? Možná je to otázka umění versus praktičnosti, ale cítím se nucen obhajovat horizontální formát jako stejně platný a v některých ohledech lepší. Pokud je kód Forthu opravdu dobře napsaný, nemělo by na něm být nic nejednoznačného. To znamená, že: - podpůrné lexikony mají dobře navrženou syntaxi - vstupy a výstupy zásobníku jsou okomentovány - účel je okomentován (pokud to není jasné z názvu nebo komentáře zásobníku) - definice nejsou příliš dlouhé - jedné definici se nepředává příliš mnoho argumentů prostřednictvím zásobníku (viz "Stylový zásobník" v sedmé kapitole). Forth zkrátka není jako jiné jazyky, v nichž je komentování řádek po řádku jednou z mála věcí, které lze udělat pro lepší čitelnost programů. Šikovně napsaný kód Forthu je jako poezie, obsahuje přesný význam, který snadno přečte jak programátor, tak stroj. Vaším cílem by mělo být psát kód, který nepotřebuje komentáře, i když se rozhodnete jej komentovat. Navrhněte svou aplikaci tak, aby smysl vyjadřoval kód, nikoli komentáře. Pokud se vám to podaří, můžete odstranit nepořádek způsobený nadměrným komentováním a dosáhnout čistoty vyjádření bez zbytečných vysvětlivek.

Vertikální formát vs. horizontální formát 161

Wiggins, hrdý na svou techniku komentování.

Tip Nejpřesnější a nejméně nákladnou dokumentací je vlastní dokumentace kódu.

5.14

Bohužel i ti nejlepší programátoři mohou pod tlakem uzávěrky napsat funkční kód, který je bez komentářů špatně čitelný. Pokud píšete pro sebe nebo pro malou skupinu lidí, s nimiž můžete komunikovat ústně, je ideální horizontální formát. V opačném případě zvažte vertikální formát.

Výběr názvů: Edsger W. Dijkstra [3]): Umění Kromě matematických sklonů je mimořádně dobré ovládání rodného jazyka nejdůležitějším přínosem schopného programátora.

Hovořili jsme o významu používání jmen pro symbolizaci myšlenek a objektů v aplikaci. Výběr jmen se ukazuje jako důležitá součást procesu návrhu. Nováčci mají tendenci důležitost názvů přehlížet. "Koneckonců," myslí si, "počítači je jedno, jaká jména zvolím." To je ale v rozporu s jejich názory. Dobré názvy jsou však pro čitelnost zásadní. Navíc mentální cvičení spočívající ve vyvolání jednoslovného popisu nese synergický efekt na vaše vnímání toho, co by daná entita měla nebo neměla dělat. Zde je několik pravidel pro výběr dobrých názvů: Tip Názvy vybírejte podle toho, "co", nikoli "jak".

5.15

Definice by měla skrývat složitosti implementace před ostatními definicemi, které se na ni odvolávají. Také název by měl skrývat podrobnosti postupu a místo toho by měl popisovat vnější vzhled nebo čistý efekt. Například forthovské slovo ALLOT jednoduše inkrementuje ukazatel slovníku (ve většině systémů se nazývá DP nebo H). Název ALLOT je však lepší než DP+!, protože uživatel má na mysli rezervaci místa, nikoli inkrementaci ukazatele. Standard '83 přijal název CMOVE> místo předchozího názvu pro stejnou funkci <CMOVE. Operace umožňuje zkopírovat oblast paměti dopředu do překrývající se paměti. Dosahuje toho tak, že začíná posledním bajtem a postupuje směrem dozadu. V novém názvu nahrazuje dopřednost "co" zpětnost "jak". Tip Najděte nejvýraznější slovo.

5.16

Výběr názvů: Umění 163

Silným prostředkem je správné slovo. Kdykoli narazíme na jedno z těch intenzivně správných slov v knize nebo v novinách, výsledný účinek je fyzický i duchovní a elektricky pohotový (Mark Twain). Rozdíl mezi správným slovem a téměř správným slovem je jako rozdíl mezi bleskem a bleskovicí (Mark Twain). Přizpůsobte akci slovu, slovo akci (Shakespeare, Hamlet, III. dějství).

Henry Laxen, konzultant a autor Forthu, navrhuje, že nejdůležitějším nástrojem vývoje Forthu je dobrý tezaurus [4]. Někdy vás napadne adekvátní slovo pro definici, ale nepřipadá vám úplně správné. Může trvat měsíce, než si uvědomíte, že jste se netrefili. V příkladu s římskými číslicemi ve čtvrté kapitole je slovo, které řeší případ výjimky: čísla, která jsou o jednu menší než hodnota následujícího symbolu. Moje první volba byla 4-0R-9. To je nešikovné, ale až mnohem později mě napadlo ALMOST. Většina systémů Fig-Forth obsahuje slovo VLIST, které uvádí názvy všech slov v aktuálním slovníku. Po mnoha letech si někdo uvědomil, že hezčí název je SLOVNÍKY. Nejenže slovo WORDS zní samo o sobě příjemněji, ale také hezky spolupracuje s názvy slovíček. Např: Na druhou stranu Moore upozorňuje, že nevhodné názvy se mohou stát jednoduchou technikou šifrování. Pokud potřebujete zajistit bezpečnost, když jste nuceni distribuovat zdrojové kódy, můžete záměrnou volbou zavádějících názvů učinit svůj kód velmi nečitelným. Údržba se tím samozřejmě stává nemožnou. Tip 5.17

Volte názvy, které fungují ve frázích.

Tváří v tvář definici, kterou nevíte, jak nazvat, přemýšlejte o tom, jak bude slovo použito v kontextu. Např: SHUTTER OPEN OPEN je vhodný název pro slovo, které nastavuje bit v I/O adrese označené názvem SHUTTER. 3 BUTTON DOES IGNITION DOES je vhodnou volbou pro slovo, které vektoruje adresu funkce IGNITION do tabulky funkcí, takže IGNITION se provede při stisknutí tlačítka 3. V případě, že je stisknuto tlačítko 3, je vhodné slovo nazvat IGNITION.

164 Provedení: Prvky stylu Forth

SAY HELLO SAY je ideální volbou pro vektorování adresy HELLO do proměnné pro provádění. (Když jsem tento příklad psal poprvé pro Starting Forth, nazval jsem ho VERSION. Moore rukopis zkontroloval a navrhl SAY, které je zjevně mnohem lepší). I'M HARRY Slovo I'M se zdá být přirozenější než LOGON HARRY, LOGIN HARRY nebo SESSION HARRY, jak se často vyskytuje. Volba slova I'M je další Mooreův výmysl, který říká: Nesnáším slovo LOGON. Takové slovo v angličtině neexistuje. Hledal jsem slovo, které by říkalo: "Jsem ... . " Bylo to přirozené. Prostě jsem na něj narazil. I když je to nešikovné s tím apostrofem, má to ten pocit správnosti. Všechna tato slovíčka jsou tím nejhezčím způsobem, jak získat reakci "Aha!". Když vás napadne správné slovo, je to samozřejmě správné slovo. Pokud máte širokou slovní zásobu pro vybavování, jste v lepší pozici, abyste na to správné slovo přišli.

Dalším Moorovým oblíbeným slovem je TH, které používá jako slovo pro indexování pole. Například věta 5 TH vrací adresu "pátého" prvku pole. Tip Hláskujte jména celá.

5.18

Jednou jsem viděl nějaký kód Forthu publikovaný v časopise, ve kterém se autor zřejmě pekelně snažil vyčistit názvy od všech samohlásek a vymýšlel takové očividné věci jako DSPL-BFR pro "display buffer". Jiní autoři si zřejmě myslí, že tři znaky magicky říkají vše, a vymýšlejí LEN pro "length". Takové postupy odrážejí myšlení z minulé doby. Čtvrtá slova by měla být plně spisovná. Buďte hrdí na to, že napíšete každé písmeno INITIALIZE nebo TERMINAL nebo BUFFER. Právě tato slova máte na mysli. Nejhorším problémem při zkracování slov je, že zapomenete, jak přesně jste je zkrátili. Bylo to DSPL nebo DSPLY? Dalším problémem je, že zkratky zhoršují čitelnost. Jakýkoli programovací jazyk je dostatečně těžký na čtení, aniž by se obtížnost ještě zhoršovala. Přesto existují výjimky. Zde je několik příkladů: 1. Slova, která se v kódu používají velmi často. Forth používá hrstku příkazů, které se používají stále dokola, ale mají malý nebo žádný vlastní význam:

Výběr názvů: Umění 165

:

;

@

!

.

,

Ale je jich tak málo a používají se tak často, že se z nich stávají staří známí. Nikdy bych nechtěl pravidelně psát DEFINE END-DEFINITION PRINT COMPILE#.

FETCH

STORE

(Zajímavé je, že většina těchto symbolů nemá české protějšky. Výraz "definice dvojtečkou" používáme proto, že jiný výraz neexistuje; "čárka číslo do slovníku" říkáme proto, že to není zrovna kompilace a jiný výraz neexistuje). 2. Slova, která může operátor terminálu často používat k řízení nějaké operace. Tato slova by se měla psát jako jednotlivá písmena, stejně jako příkazy řádkového editoru. 3. Slova, u nichž známé použití předpokládá, že se budou zkracovat. Mnemotechniky assembleru Forth jsou obvykle vytvořeny podle vzoru mnemotechnik navrhovaných výrobcem, což jsou zkratky (například JMP a MOV). Vaše názvy by měly být vyslovitelné; jinak byste mohli litovat, až se budete snažit o programu diskutovat s ostatními lidmi. Pokud je název symbolický, vymyslete si výslovnost (např. >R se nazývá "to-r"; R> se nazývá "r-from"). Tip 5.19

Dávejte přednost krátkým slovům.

Máte-li na výběr mezi tříslabičným slovem a jednoslabičným slovem, které znamená totéž, zvolte to kratší. BRIGHT je lepší název než INTENZIVNÍ. ENABLE je lepší název než ACTIVATE; GO, RUN nebo ON mohou být ještě lepší. Kratší názvy se lépe píší. Šetří místo na zdrojové obrazovce. A co je nejdůležitější, kód je díky nim jasný a čistý. Tip 5.20

Názvy s pomlčkami mohou být známkou špatného faktoringu.

Moore: V komunitě programátorů jazyka Forth existují rozdílné programovací styly. Jeden používá spojovníky, které v angličtině vyjadřují, co dané slovo dělá. Tato velká dlouhá slova spojíte dohromady a získáte něco, co je docela čitelné. Ale já mám hned podezření, že programátor ta slova nepromyslel dost pečlivě, že by se spojovník měl rozbít a slova definovat zvlášť. Ne vždy je to možné a ne vždy je to výhodné. Ale podezřívám slovo s pomlčkou ze směšování dvou pojmů.

166 Provedení: V případě, že se jedná o slovní spojení, je třeba, aby se v něm objevilo slovo, které se používá v češtině: Prvky stylu Forth

Porovnejte následující dvě strategie pro vyjádření stejné věci: ENABLE-LEFT-MOTOR ENABLE-RIGHT-MOTOR DISABLE-LEFT-MOTOR DISABLE-RIGHT-MOTOR ENABLE-LEFT-SOLENOID ENABLE-RIGHT-SOLENOID DISABLE-LEFT-SOLENOID DISABLE-RIGHT-SOLENOID

LEVÝ MOTOR ZAPNUTÝ PRAVÝ MOTOR ZAPNUTÝ LEVÝ MOTOR VYPNUTÝ PRAVÝ MOTOR VYPNUTÝ LEVÝ SOLENOID ZAPNUTÝ PRAVÝ SOLENOID VYPNUTÝ LEVÝ SOLENOID VYPNUTÝ PRAVÝ SOLENOID VYPNUTÝ

Syntaxe vlevo vyžaduje osm slovníkových hesel, syntaxe vpravo pouze šest - a některá slova budou pravděpodobně znovu použita v jiných částech aplikace. Pokud byste měli také motor MIDDLE a solenoid, potřebovali byste k popisu šestnácti kombinací pouze sedm slov. Tip Nespojujte čísla do názvů.

5.21

Dávejte si pozor na řadu názvů začínajících nebo končících čísly, například 1KANÁL, 2KANÁL, 3KANÁL atd. Toto svazování názvů a čísel může být známkou špatného faktoringu. Jedná se o podobný zločin jako u spojovníků, s tím rozdílem, že to, co by mělo být vyfakturováno, je číslo, nikoliv slovo. Lepší faktorizace výše uvedeného by byla 1 CHANNEL 2 CHANNEL 3 CHANNEL V tomto případě byla tři slova redukována na jedno. Často svazování názvů a čísel značí fuzzy pojmenování. Ve výše uvedeném případě by popisnější názvy mohly naznačovat účel kanálů, jako například HLAS , TELEMETRIE , KYTARA Tyto myšlenky rozšíříme v další kapitole "Faktorizace".

Standardy pojmenování: Naučte se a osvojte si pojmenovací konvence jazyka Forth.

5.22

Ve snaze o krátké, ale smysluplné názvy přijali programátoři jazyka Forth určité konvence pojmenování. Příloha E obsahuje seznam nejužitečnějších konvencí vytvořených v průběhu let.

Pojmenovací standardy: Věda 167

Příkladem síly pojmenovacích konvencí je použití slova "dot" ve významu "print" nebo "display". Samotný jazyk Forth používá .

D.

U.R

pro zobrazení různých typů čísel v různých formátech. Tato konvence se rozšiřuje i na aplikační slova. Pokud máte proměnnou s názvem DATE a chcete slovo, které zobrazuje datum, použijte název .DATE A pozor: Nadměrné používání předpon a přípon činí slova ošklivějšími a v konečném důsledku méně čitelnými. Nesnažte se popsat vše, co slovo dělá, pouze jeho názvem. Jméno je koneckonců symbol, nikoli zkratka kódu. Co je čitelnější a přirozeněji znějící: Oidipův komplex

(který nemá žádný vlastní význam), nebo komplex podvědomé náklonnosti k rodiči opačného pohlaví.

Pravděpodobně to první, i když to předpokládá, že hru znáte. Tip 5.23

Předpony a přívlastky používejte spíše k odlišení podobných slov než k tomu, abyste do samotného názvu nacpali detaily významu.

Například výraz .... DONE IF CLOSE THEN ... je stejně čitelná jako ... DONE? IF CLOSE THEN ... a je také čistší. Je proto vhodnější, pokud nepotřebujeme další slovo s názvem DONE (například jako příznak). Poslední rada k pojmenování: Tip 5.24

Všechna hexadecimální čísla začínejte "0" (nulou), abyste se vyhnuli případným kolizím s názvy.

Například pište 0ADD, nikoli ADD. Mimochodem, neočekávejte, že váš systém Forth bude nutně odpovídat výše uvedeným konvencím. Konvence jsou určeny k použití v nových aplikacích. Jazyk Forth byl vytvořen a zdokonalován po mnoho let lidmi, kteří jej používali jako prostředek k dosažení cíle. V té době nebylo rozumné ani možné vnucovat názvoslovné standardy nástroji, který stále rostl a vyvíjel se. Kdyby byl Forth navržen komisí, neměli bychom ho tak rádi.

168 Implementace: Prvky stylu Forth

Další tipy pro čitelnost Zde je několik závěrečných návrhů, jak učinit váš kód čitelnějším. (Definice jsou uvedeny v příloze C.) Jednou z konstant, která se vyplatí ve většině aplikací, je BL (hodnota ASCII pro "prázdný prostor"). Slovo ASCII se používá především v definicích dvojteček, abyste nemuseli znát doslovnou hodnotu znaku ASCII. Například místo zápisu: : (

41 WORD

DROP ;

IMMEDIATE

kde 41 je reprezentace ASCII pro pravostranný znak, můžete napsat : (

ASCII ) WORD

DROP ;

IMMEDIATE

Dvojice slov, která může usnadnit práci s logickými symboly, jsou TRUE a FALSE. S těmito doplňky můžete psát věty jako TRUE 'STAMP? ! pro nastavení příznaku nebo FALSE 'STAMP? ! pro jeho vymazání. (Kdysi jsem používal T a F, ale tato slova jsou potřeba tak zřídka, že nyní dbám na zákaz zkracování). V rámci vaší aplikace (ne nutně součástí systému Forth) můžete tuto myšlenku posunout o krok dál a definovat: : ON : OFF

( a) TRUE SWAP ! ; ( a) FALSE SWAP ! ;

Tato slova vám umožňují psát: 'STAMP? ON nebo 'STAMP? OFF Mezi další názvy těchto definic patří SET a RESET, i když SET a RESET nejčastěji používají bitové masky pro manipulaci s jednotlivými bity. Často používané slovo je WITHIN, které určuje, zda daná hodnota leží uvnitř dvou jiných hodnot. Syntaxe je následující: n

lo hi WITHIN

Další tipy pro čitelnost 169

kde "n" je testovaná hodnota a "lo" a "hi" představují rozsah. WITHIN vrací true, pokud je "n" větší nebo rovno "lo" a menší než "hi". Toto použití neúplné horní meze je paralelní se syntaxí smyček DO LOOP. Moore doporučuje slovo UNDER+. Je užitečné pro přičítání hodnoty k číslu těsně pod horní položkou zásobníku místo k horní položce zásobníku. Mohlo by být implementováno na vysoké úrovni jako: : UNDER+

( a b c -- a+c b )

ROT +

SWAP ;

Shrnutí Udržovatelnost vyžaduje čitelnost. V této kapitole jsme vyjmenovali různé způsoby, jak učinit výpis zdrojového kódu čitelnějším. Vycházeli jsme ze zásady, že náš kód bude co nejvíce dokumentován sám sebou. Mezi techniky patří uspořádání výpisu, řádkování a odsazování, komentování, volba názvů a speciální slova, která zvyšují přehlednost. Jen stručně jsme se zmínili o pomocné dokumentaci, která zahrnuje veškerou dokumentaci kromě samotného výpisu. V tomto svazku se pomocnou dokumentací nebudeme dále zabývat, ale zůstává nedílnou součástí procesu vývoje softwaru.

Odkazy [1] Gregory Stevenson, "Documentation Priorities", 1981 FORML Conference Proceedings, s. 401. [2] Joanne Lee, "Quality Assurance in a Forth Environment," (Dodatek A), 1981 FORML Proceedings, str. 363. [3] Edsger W. Dijkstra, Selected Writings on Computing: A Personal Perspective, New York, Springer Verlag, Inc. 1982. [4] Henry Laxen, "Choosing Names", Forth Dimensions, roč. 4, č. 1, str. 1, str. 2, str. 3, str. 4, str. 5, str. 6, str. 7, str. 8. 4, Forth Interest Group.

170 Provádění: Prvky stylu Forth

ŠEST

Faktorování

V této kapitole budeme pokračovat ve studiu implementační fáze, tentokrát se zaměříme na faktoring. Dekompozice a faktoring jsou čipy ze stejného bloku. Obě zahrnují rozdělování a uspořádávání. K dekompozici dochází během předběžného návrhu, k faktorizaci během detailního návrhu a implementace. Vzhledem k tomu, že každá definice dvojtečky odráží rozhodnutí o faktoringu, je pochopení dobré techniky faktoringu pro programátora Forthu asi nejdůležitější dovedností. Co je to faktoring? Faktoring znamená uspořádání kódu do užitečných fragmentů. Aby byl fragment užitečný, musíte často oddělit opakovaně použitelné části od částí, které použít nelze. Opakovaně použitelné části se stanou novými definicemi. Z nepoužitelných částí se stanou argumenty nebo parametry definic. Toto oddělení se obvykle označuje jako "vyfakturování". V první části této kapitoly se budeme zabývat různými technikami "factoring-out". Dalším aspektem faktorizace je rozhodování o tom, co všechno by mělo být součástí definice a co ne. Druhá část nastíní kritéria užitečného faktoringu.

Techniky faktorizace Pokud se modul jeví jako téměř, ale ne zcela užitečný z druhého místa v systému, pokuste se identifikovat a izolovat užitečnou dílčí funkci. Zbytek modulu může být začleněn do jeho původního volajícího (ze "Strukturovaného návrhu" [1]).

"Užitečnou podfunkcí" se samozřejmě stává nově zfaktorizovaná definice. co s částí, která "není zcela užitečná"? To záleží na tom, co to je.

Faktorování dat Nejjednodušší věc, kterou lze faktorizovat, jsou data, a to díky datovému zásobníku jazyka Forth. Chceme-li například vypočítat dvě třetiny z 1 000, napíšeme 1000 2 3 */.

172 Faktorování

Chceme-li definovat slovo, které vypočítá dvě třetiny libovolného čísla, vyfaktorujeme argument z definice: : Dvě třetiny ( n1 -- n2)

2 3 */ ;

Pokud se údaj nachází uprostřed užitečné věty, musíme použít manipulaci se zásobníkem. Chceme-li například vycentrovat text dlouhý deset znaků na osmdesátisloupcové obrazovce, napíšeme: 80

10 -

2/ MEZERY

Ale text není vždy dlouhý deset znaků. Aby byla tato věta použitelná pro libovolný řetězec, vynásobíte jeho délku zápisem: : CENTER ( délka -- ) 80

SWAP -

2/ MEZERY ;

Zásobník dat lze také použít k předávání adres. Proto to, co je vyfakturováno, může být spíše ukazatel na data než samotná data. Data mohou být čísla nebo dokonce řetězce, a přesto mohou být faktorována pomocí zásobníku. Někdy se rozdíl jeví jako funkce, ale lze jej vyfakturovat jednoduše jako číslo na zásobníku. Například Segment 1: WILLY NILLY

PUDINKOVÝ KOLÁČ A

Segment 2: WILLY NILLY

8 *

PUDINKOVÝ KOLÁČ A

Jak můžete vynásobit operaci "8 *"? Tak, že do faktoringu zahrneme "*" a předáme mu jedničku nebo osmičku: : NOVINKA

( n )

WILLY NILLY

*

PUDINKOVÝ KOLÁČ A ;

Segment 1: 1 NEW Segment 2: 8 NEW (Pokud WILLY NILLY změní zásobník, je samozřejmě nutné přidat příslušné operátory pro manipulaci se zásobníkem.) Pokud operace zahrnuje sčítání, můžete ji zrušit předáním nuly. Tip Pro zjednodušení se snažte rozdíl mezi podobnými fragmenty vyjádřit spíše jako číselný rozdíl (hodnoty nebo adresy) než jako procedurální rozdíl.

6.1

Faktorování dat 173

Faktorování funkcí Na druhé straně je někdy rozdíl funkcí. Svědčí o tom např: Segment 1: Segment 2:

BLETCH-B BLETCH-C BLETCH-D BLETCH-E BLETCH-F BLETCH-A BLETCH-B ZVRÁCENOST BLETCH-D BLETCH-E BLETCH-F BLETCH-A

Špatný přístup: : BLETCHES ( t=do-BLETCH-C | f=do-PERVERSITY -- ) BLETCH-A BLETCH-B IF BLETCH-C ELSE PERVERSITY THEN BLETCH-D BLETCH-E BLETCH-F ; Segment 1:

BLETCHES

Segment 2:

FALSE BLETCHES

Lepší přístup: : BLETCH-AB : BLETCH-DEF

BLETCH-A BLETCH-B ; BLETCH-D BLETCH-E BLETCH-F ;

Segment 1:

BLETCH-AB BLETCH-C

Segment 2:

BLETCH-AB PERVERSITY BLETCH-DEF

BLETCH-DEF

Tip 6.2

Nepředávejte řídicí příznaky směrem dolů.

Proč ne? Za prvé, žádáte běžící aplikaci, aby učinila nesmyslné rozhodnutí - rozhodnutí, na které jste znali odpověď již při programování - a tím snižujete efektivitu. Za druhé, terminologie neodpovídá koncepčnímu modelu. Co jsou to PRAVDIVÉ BLESKY na rozdíl od FALEŠNÝCH BLESKŮ?

Faktorování kódu uvnitř řídicích struktur Dávejte si pozor na opakování na obou stranách příkazu IF ELSE THEN. Například: ... ( c) DUP BL 127 WITHIN IF EMIT ELSE DROP ASCII . EMIT THEN ... Tento fragment normálně vysílá znak ASCII, ale pokud je znakem řídicí kód, vysílá tečku. V každém případě se provede EMIT. Vylučte EMIT z podmíněné struktury takto:

174 Faktoring

... ( c) DUP BL 127 WITHIN NOT IF DROP ASCII . THEN EMIT

...

Nejnepřehlednější situace nastává, když je rozdíl mezi dvěma definicemi funkcí v rámci struktury, která znemožňuje faktorizaci polovičních fragmentů. V takovém případě použijte argumenty zásobníku, proměnné nebo dokonce vektorování. Jak lze vektorování použít, uvidíme v části sedmé kapitoly nazvané "Použití DOER/MAKE". Zde je připomínka k faktorizaci kódu z DO LOOP: Tip Při faktorizaci obsahu DO LOOP do nové definice přepracujte kód tak, aby se na I (index) neodkazovalo v rámci nové definice, ale předávalo se jí jako argument zásobníku.

6.3

Faktorování samotných řídicích struktur Zde jsou dvě definice, jejichž rozdíly spočívají v konstrukci IF THEN: : ACTIVE : LAZY

A B NEBO A B NEBO

C AND C AND

IF IF

TUMBLE JUGGLE JUMP THEN ; SIT EAT SLEEP THEN ;

Struktura podmínky a kontroly zůstává stejná, mění se pouze událost. Protože nemůžete faktor IF vložit do jednoho slova a THEN do druhého, nejjednodušší je faktorizovat podmínku: : PODMÍNKY? ( -- ?) A B NEBO C A ; : AKTIVNÍ PODMÍNKY? IF TUMBLE JUGGLE JUMP THEN ; : LÍNÉ PODMÍNKY? IF SIT EAT SLEEP THEN ; V závislosti na počtu opakování stejné podmínky a řídicí struktury můžete dokonce chtít faktorizovat obě. Sledujte toto: : PODMÍNĚNĚ A B NEBO C A NE IF R> DROP : AKTIVNĚ PODMÍNĚNĚ TUMBLE JUGGLE JUMP ; : LÍNĚ PODMÍNĚNĚ SIT EAT SLEEP ;

POTÉ ;

Slovo PODMÍNĚNĚ může - v závislosti na podmínce - změnit tok řízení tak, že zbývající slova v každé definici budou přeskočena. Tento přístup má i určité nevýhody. Tuto techniku - klady a zápory - probereme v osmé kapitole. Mezi příznivější příklady vyčleňování řídicích struktur patří příkazy case, které eliminují vnořené IF ELSE THEN, a vícenásobné výstupní smyčky (konstrukce BEGIN WHILE WHILE WHILE ... REPEAT). Těmto tématům se budeme věnovat také v osmé kapitole.

Faktorování samotných řídicích struktur 175

Faktorování názvů Je dobré faktorizovat názvy i tehdy, když se názvy zdají být téměř, ale ne zcela stejné. Prozkoumejte následující příšerný příklad kódu, který má inicializovat tři proměnné spojené s každým z osmi kanálů: PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ : : : : : : : :

0STS 3STS 6STS 1TNR 4TNR 7TNR 2UPS 5UPS

INIT-CHO INIT-CH1 INIT-CH2 INIT-CH3 INIT-CH4 INIT-CH5 INIT-CH6 INIT-CH7

0 0 0 0 0 0 0 0

PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ 0STS 1STS 2STS 3STS 4STS 5STS 6STS 7STS

! ! ! ! ! ! ! !

1000 1000 1000 1000 1000 1000 1000 1000

1STS 4STS 7STS 2TNR 5TNR 0UPS 3UPS 6UPS

0TNR 1TNR 2TNR 3TNR 4TNR 5TNR 6TNR 7TNR

! ! ! ! ! ! ! !

PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ -1 -1 -1 -1 -1 -1 -1 -1 -1 -1

0UPS 1UPS 2UPS 3UPS 4UPS 5UPS 6UPS 7UPS

! ! ! ! ! ! ! !

2STS 5STS 0TNR 3TNR 6TNR 1UPS 4UPS 7UPS

; ; ; ; ; ; ; ;

: INIT-ALL-CHS INIT-CHO INIT-CH1 INIT-CH2 INIT-CH4 INIT-CH5 INIT-CH6 INIT-CH7 ;

INIT-CH3

Nejprve je tu podobnost mezi názvy proměnných; pak je tu podobnost v kódu použitém ve všech slovech INIT-CH. Zde je vylepšené ztvárnění. Podobná jména proměnných byla rozdělena do tří datových struktur a dlouhá recitace slov INIT-CH byla rozdělena do cyklu DO LOOP: : ARRAY ( #cells -- ) CREATE 2* ALLOT DOES> ( i -- 'cell) SWAP 2* + ; 8 ARRAY STATUS ( channel# -- adr) 8 ARRAY TENOR ( " ) 8 ARRAY UPSHOT ( " ) : STABLE 8 0 DO 0 I STATUS ! 1000 I TENOR ! -1 I UPSHOT ! LOOP ; To je vše, co potřebujeme. I v těch nejnevinnějších případech může malá datová struktura eliminovat další jména. Podle konvence Forth zpracovává text v "počítaných řetězcích" (tj. s počtem v prvním bajtu). Jakékoli slovo, které vrací "adresu řetězce", ve skutečnosti vrací tuto počáteční adresu, kde je počet. Používá se nejen

176 Faktorování

této dvouprvkové datové struktury odstraňuje potřebu samostatných názvů pro řetězec a počet, ale také usnadňuje přesouvání řetězce v paměti, protože řetězec i počet můžete zkopírovat jediným příkazem CMOVE. Když začnete tu a tam narážet na stejnou nešikovnost, můžete věci spojit a nešikovnost zmizí.

Rozdělení funkcí do definičních slov Tip Pokud řada definic obsahuje identické funkce, které se liší pouze v datech, použijte definiční slovo.

6.4

Prozkoumejte strukturu tohoto kódu (aniž byste se starali o jeho účel - stejný příklad uvidíte později): : HUE ( color -- color') 'LIGHT? @ NEBO 0 'LIGHT? ! ; : BLACK 0 HUE ; : BLUE 1 HUE ; : GREEN 2 HUE ; : CYAN 3 HUE ; : RED 4 HUE ; : MAGENTA 5 HUE ; : BROWN 6 HUE ; : GRAY 7 HUE ; Výše uvedený přístup je technicky správný, ale paměťově méně efektivní než následující přístup využívající definiční slova: : ( -- barva ) DOES> ( -- barva 0 HUE BLACK 3 HUE CYAN 6 HUE BROWN

CREATE , ) @ 'LIGHT? @ 1 ODSTÍN MODRÉ 4 ODSTÍN ČERVENÉ 7 ODSTÍN ŠEDÉ

NEBO

0 'LIGHT? ! ; 2 ODSTÍN ZELENÁ 5 ODSTÍN MAGENTA

(Definiční slova jsou vysvětlena v kapitole Starting Forth, jedenáctá kapitola). Použitím definičního slova šetříme paměť, protože každá zkompilovaná definice dvojtečky potřebuje k uzavření definice adresu EXIT. (Při definování osmi slov ušetří použití definičního slova 14 bajtů na 16bitovém Forthu.) Také v definici dvojtečky vyžaduje každý odkaz na číselný literál kompilaci LIT (neboli literál), což jsou další 2 bajty na definici. (Pokud jsou 1 a 2 předdefinované konstanty, stojí to dalších 10 bajtů - celkem 24.) Z hlediska čitelnosti je díky definičnímu slovu naprosto jasné, že všechny barvy, které definuje, patří do stejné rodiny slov. Největší síla definičních slov však vzniká, když řada definic sdílí stejné chování při kompilaci. Toto téma je předmětem pozdějšího oddílu "Faktorování v době kompilace".

Faktorování funkcí do definičních slov 177

Kritéria faktorizace Vyzbrojeni pochopením technik faktorizace probereme nyní několik kritérií pro faktorizaci definic jazyka Forth. Patří mezi ně: 1. Omezení velikosti definic 2. Omezení opakování kódu 3. Pojmenovatelnost 4. Skrývání informací 5. Zjednodušení příkazového rozhraní

Tip 6.5

Udržujte definice krátké.

Zeptali jsme se Moora: "Jak dlouhá by měla být definice jazyka Forth?". Slovo by mělo být dlouhé jeden řádek. To je cíl. Když máte celou řadu slov, která jsou všechna užitečná sama o sobě - třeba při ladění nebo zkoumání, ale nevyhnutelně existuje důvod jejich existence - máte pocit, že jste vystihli podstatu problému a že ji tato slova vyjádřila. Krátká slova vám dávají dobrý pocit.

Neformální zkoumání jedné Moorovy aplikace ukazuje, že na jednu definici připadá v průměru sedm odkazů, včetně slov i čísel. Jedná se o pozoruhodně krátké definice. (Ve skutečnosti byl jeho kód rozdělen zhruba půl na půl mezi jednořádkové a dvouřádkové definice). Psychologické testy ukázaly, že lidská mysl dokáže najednou soustředit svou vědomou pozornost pouze na sedm věcí, plus minus dvě [2]. Přesto po celou dobu, ve dne v noci, obrovské zdroje mysli podvědomě ukládají obrovské množství dat, vytvářejí souvislosti a asociace a řeší problémy. I když naše podvědomí zná každou část aplikace skrz naskrz, naše úzkoprsá vědomá mysl dokáže najednou korelovat pouze sedm jejích prvků. Za touto hranicí naše chápání ochabuje. Stručné definice odpovídají našim mentálním schopnostem. Něco, co mnohé programátory Forthu svádí k psaní příliš dlouhých definic, je vědomí, že hlavičky zabírají ve slovníku místo. Čím hrubší je faktoring, tím méně názvů a tím méně paměti se vyplýtvá. Je pravda, že se spotřebuje více paměti, ale těžko říci, že cokoli, co vám pomáhá testovat, ladit a komunikovat s kódem, je "plýtvání". Pokud váš

178 Faktoring

aplikace velká, zkuste použít výchozí šířku tři s možností přepnout na plnou délku jména, abyste se vyhnuli konkrétní kolizi. ("Šířkou" se rozumí omezení počtu znaků uložených v poli názvu každé hlavičky slovníku). Pokud je aplikace stále příliš velká, přepněte na Forth s více slovníky na stroji s rozšířenou pamětí, nebo ještě lépe na 32bitový Forth na stroji s 32bitovou adresací. S tím souvisí i obava, že přílišné faktorizování sníží výkon kvůli režii vnitřního interpretu jazyka Forth. Opět je pravda, že za každou úroveň vnoření je určitá penalizace. Obvykle však postih za dodatečné vnoření v důsledku správného faktoringu nebude znatelný. Pokud máte tak napjaté časování, skutečným řešením je přeložit něco do assembleru. Tip Faktorujte v okamžiku, kdy se cítíte ve svém kódu nejistí (kdy se složitost blíží vědomé hranici).

6.6

Nenechte se ovládnout svým egem s přístupem "Tohle si můžu líznout!". Kód jazyka Forth by nikdy neměl působit nepříjemně složitě. Faktor! Moore: Pocit, že jste možná zavedli chybu, je jedním z důvodů pro faktorizaci. Kdykoli uvidíte dvakrát vnořený DO LOOP, je to znamení, že je něco špatně, protože se to bude těžko ladit. Téměř vždy vezměte vnitřní DO LOOP a vytvořte slovo. A poté, co jste slovo pro testování vyfakturovali, není důvod ho vracet zpět. V první řadě jste zjistili, že je užitečné. Neexistuje žádná záruka, že ho nebudete potřebovat znovu.

Zde je další aspekt téhož principu: Tip Factor v místě, kde se komentář zdá být nezbytný.

6.7

Zejména pokud cítíte potřebu připomenout si, co je na zásobníku, může to být vhodná chvíle pro "přestávku". Předpokládejme, že máte ... BALANCE DUP xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx ( balance) SHOW ... který začíná výpočtem zůstatku a končí jeho zobrazením. Mezitím několik řádků kódu používá zůstatek pro své vlastní účely. Protože je obtížné zjistit, že zůstatek je při provádění SHOW stále na zásobníku, programátor do něj vložil obrázek zásobníku. Toto řešení je obecně známkou špatného faktoringu. Lepší je napsat:

Faktorovací kritéria 179

: REVISE ( balance -- ) xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx ; ... BALANCE DUP REVISE SHOW ... Žádné obrázky z hromady příběhů nejsou potřeba. Navíc má nyní programátor k dispozici opakovaně použitelnou, testovatelnou podmnožinu definice. Tip 6.8

Omezte opakování kódu.

Druhý důvod pro faktorizaci, tedy eliminace opakujících se fragmentů kódu, je ještě důležitější než omezení velikosti definic. Moore: Když je slovo jen kousek něčeho, je užitečné pro přehlednost nebo ladění, ale není zdaleka tak dobré jako slovo, které je použito vícekrát. Kdykoli je slovo použito jen jednou, chcete zpochybnit jeho hodnotu. Mnohokrát, když se program příliš rozroste, ho znovu projdu a hledám výrazy, které mi padnou do oka jako kandidáti na faktorizaci. Počítač to nedokáže, je v něm příliš mnoho proměnných.

Při prohlížení své práce často narazíte na několikrát zopakované totožné fráze nebo krátké pasáže. Při psaní editora jsem našel tuto několikrát opakovanou větu: RÁMEC

CURSOR @ +

Protože se objevila několikrát, zohlednil jsem ji v novém slově s názvem AT. Je na vás, abyste rozpoznali fragmenty, které jsou kódovány odlišně, ale funkčně jsou rovnocenné, jako např: FRAME

CURSOR @ 1-

+

Zdá se, že díky 1- se tato věta liší od věty definované jako AT. Ve skutečnosti ji však lze zapsat AT 1Na druhé straně: Tip 6.9

Při faktorování duplicitního kódu dbejte na to, aby faktorovaný kód sloužil jedinému účelu.

180 Faktorování

Nezachytávejte slepě duplicity, které nemusí být užitečné. Například na několika místech jedné aplikace jsem použil tuto větu: BLK @ BLOCK

>IN @ +

C@

Udělal jsem z ní nové slovo a nazval ji LETTER, protože vracela písmeno, na které ukazoval interpret. V pozdější revizi jsem nečekaně musel napsat: BLK @ BLOCK

>IN @ +

C!

Mohl jsem použít existující LETTER, nebýt jeho C@ na konci. Než abych duplikoval většinu věty v nové sekci, rozhodl jsem se raději přeformulovat LETTER na jemnější rozlišení a odstranit C@. Použití pak bylo buď LETTER C@, nebo LETTER C!. Tato změna vyžadovala, abych prošel výpis a změnil všechny případy LETTER na LETTER C@. To jsem ale měl udělat hned na začátku a oddělit výpočet adresy písmene od operace, která se má s adresou provést. Podobně jako náš zákaz opakování kódu: Tip Hledejte opakování vzorů.

6.10

Pokud zjistíte, že se v programu vracíte zpět a kopírujete vzor dříve použitých slov, pak jste možná smísili obecnou myšlenku s konkrétní aplikací. Část vzoru, kterou kopírujete, možná lze vyčlenit jako samostatnou definici, kterou lze použít ve všech podobných případech. Tip Ujistěte se, že umíte pojmenovat to, co faktorujete.

6.11

Moore: Pokud máte koncept, kterému nemůžete přiřadit jediné jméno, nikoliv jméno s pomlčkou, ale jméno, nejedná se o dobře vytvořený koncept. Možnost přiřadit jméno je nezbytnou součástí rozkladu. Jistě tím získáte větší důvěru v myšlenku.

Kritéria rozkladu 181

Porovnejte tento pohled s kritérii pro dekompozici modulu, která zastává strukturovaný návrh v první kapitole. Podle této metody by měl modul vykazovat "funkční vazbu", kterou lze ověřit popisem jeho funkce v jediné, nesložené větě. Forthovský "atom", jméno, je o řád rafinovanější. Tip 6.12

Definice faktorů skrývají detaily, které se mohou změnit.

V dřívějších kapitolách jsme viděli hodnotu skrývání informací, zejména s ohledem na předběžný návrh. Je užitečné mít toto kritérium na paměti i ve fázi implementace. Zde je velmi krátká definice, která kromě skrytí informací neudělá téměř nic: : >TĚLO

( acf -- apf )

2+ ;

Tato definice umožňuje převést acf (adresu pole kódu) na apf (adresu pole parametru) bez závislosti na skutečné struktuře definice slovníku. Pokud byste místo slova >BODY použili 2+, ztratili byste přenositelnost, pokud byste někdy přešli na systém Forth, ve kterém jsou hlavy odděleny od těl. (Toto je jedno ze souboru slov navržených Kimem Harrisem a zařazených jako experimentální návrh do standardu Forth-83 [3]). Zde je skupina definic, které by mohly být použity při psaní editoru: : FRAME ( -- a) SCR @ BLOCK ; : CURSOR ( -- a) R# ; : AT ( -- a) FRAME CURSOR @ + ; Tyto tři definice mohou tvořit základ všech výpočtů adres potřebných pro pohyb textu. Použití těchto tří definic zcela odděluje vaše editační algoritmy od závislosti na blocích jazyka Forth. K čemu je to dobré? Pokud byste se během vývoje rozhodli vytvořit editační vyrovnávací paměť, která by chránila uživatele před chybami, jež by zničily blok, stačí nadefinovat dvě z těchto slov, třeba takto: Zbytek kódu může zůstat nedotčen. Tip 6.13

Vylučte funkce z definic, které zobrazují výsledky.

182 Faktorování

Ve skutečnosti se jedná o rozklad. Zde je příklad. Níže definované slovo, vyslovované "people-topaths", počítá, kolik komunikačních cest existuje mezi daným počtem lidí ve skupině. (To je dobré vědět pro manažery programátorských týmů - počet komunikačních cest se drasticky zvyšuje s každým novým členem týmu). : PEOPLE>PATHS ( #people -- #paths )

DUP 1-

*

2/ ;

Tato definice provádí pouze výpočet. Zde je "uživatelská definice", která vyvolá PEOPLE>PATHS k provedení výpočtu a poté zobrazí výsledek: : PEOPLE ( #people) ." = " PEOPLE>PATHS .

." PATHS " ;

Výsledkem je: 2 LIDÉ = 1 CESTY 3 LIDÉ = 3 CESTY 5 LIDÍ = 10 CEST 10 LIDÍ = 45 CEST I když si myslíte, že určitý výpočet provedete jen jednou, abyste ho zobrazili určitým způsobem, věřte, že se mýlíte. Budete se muset později vrátit a část výpočtu vyfakturovat. Možná budete potřebovat zobrazit informace ve sloupci s pravým okrajem nebo možná budete chtít výsledky zaznamenat do databáze - nikdy nevíte. Ale vždycky to budete muset vyfakturovat, takže byste to měli udělat správně hned napoprvé. (Těch několik případů, kdy vám to může projít, nestojí za tu námahu.) Slovo . (tečka) je ukázkovým příkladem. Tečka je v 99 % případů skvělá, ale občas toho dělá příliš mnoho. Tady je, co vlastně dělá (ve Forthu-83): : .

( n )

DUP ABS 0 <# #S

ROT SIGN

#> TYP MEZERA ;

Předpokládejme však, že chcete převést číslo na zásobníku na řetězec ASCII a uložit jej do vyrovnávací paměti pro pozdější zadání. Dot jej převede, ale také napíše. Nebo předpokládejme, že chcete formátovat hrací karty ve tvaru 10C (pro "křížovou desítku"). K zobrazení desítky nemůžete použít dot, protože vypisuje závěrečnou mezeru. Zde je lepší faktoring, který se vyskytuje v některých systémech Forth: : (.) ( n -- a #) DUP ABS 0 : . ( n) (.) TYPE SPACE ;

<# #S

ROT SIGN

#> ;

Další příklad selhání faktoru výstupní funkce z výpočetní funkce najdeme v našem vlastním příkladu s římskými číslicemi ve čtvrté kapitole. Vzhledem k našemu řešení nemůžeme římskou číslici uložit do vyrovnávací paměti, a dokonce ani vycentrovat do pole. (Lepší by bylo použít místo EMIT funkci HOLD.) Důvodem pro neprovedení faktoru může být také skrývání informací. Například pokud faktorujete výraz

Kritéria faktorizace 183

SCR @ BLOCK do definice : FRAME

SCR @ BLOCK ;

pamatujte, že tak činíte pouze proto, že možná budete chtít změnit umístění editačního rámečku. Nenahrazujte slepě všechny výskyty výrazu novým slovem FRAME, protože můžete změnit definici FRAME a určitě se vyskytnou situace, kdy budete chtít opravdu SCR @ BLOCK. Tip 6.14

Pokud je pravděpodobné, že se opakovaný fragment kódu v některých případech změní, ale v jiných ne, vyčleňte pouze ty případy, které se mohou změnit. Pokud je pravděpodobné, že se fragment změní více než jedním způsobem, zohledněte jej ve více definicích.

Vědět, kdy informaci skrýt, vyžaduje intuici a zkušenost. Poté, co jste během své kariéry provedli mnoho změn návrhu, se naučíte, které věci se budou v budoucnu s největší pravděpodobností měnit. Nikdy však nemůžete předvídat všechno. Bylo by zbytečné se o to pokoušet, jak uvidíme v nadcházející části nazvané "Iterativní přístup při implementaci". Tip 6.15

Zjednodušte příkazové rozhraní snížením počtu příkazů.

Může se to zdát paradoxní, ale dobré faktorizování může často přinést menší počet jmen. V páté kapitole jsme viděli, jak šest jednoduchých názvů (LEVÝ, PRAVÝ, MOTOR, SOLENOID, ZAPNUTO a VYPNUTO) může vykonat práci osmi špatně zfaktorizovaných, spojovaných názvů. Jako další příklad jsem našel dvě definice, které kolovaly v jednom oddělení, v němž se Forth nedávno zavedl. Jejich účel byl čistě instrukční, aby programátorovi připomněly, který slovník je CURRENT a který CONTEXT: : .CONTEXT : .CURRENT

CONTEXT @ CURRENT @

Pokud jste napsali .CONTEXT, systém odpověděl .CONTEXT FORTH

184 Faktorování

8 8 -

NFA NFA

ID. ID.

; ;

(Fungovaly - alespoň v systému, který se tam používal - tak, že se zálohovaly do pole s názvem definice slovníku a zobrazily se.) Zjevné opakování kódu mi padlo do oka jako známka špatného faktoringu. Opakující se pasáž by bylo možné sjednotit do třetí definice: : .VOCABULARY

( ukazatel )

@

8 -

NFA

ID;

zkrácení původních definic na: : .CONTEXT : .CURRENT

.CONTEXT .VOCABULARY ; CURRENT .VOCABULARY ;

V tomto přístupu se však jediným rozdílem mezi oběma definicemi stal ukazatel, který se má zobrazit. Protože součástí dobrého faktoringu je vytvářet méně, nikoli více definic, zdálo se logické mít pouze jednu definici a nechat ji přijímat jako argument buď slovo CONTEXT, nebo slovo CURRENT. Při uplatnění zásad dobrého pojmenování jsem navrhl: : IS

( adr)

@

8 -

NFA

ID;

umožňující syntaxi CONTEXT IS ASSEMBLER ok nebo CURRENT IS FORTH ok Původním vodítkem bylo opakování kódu, ale konečný výsledek vyplynul ze snahy zjednodušit příkazové rozhraní. Zde je další příklad. IBM PC má čtyři režimy čtyři zobrazování pouze textu: 40 40 80 80

sloupec sloupec sloupec sloupec sloupec

monochromatický barevný monochromatický barevný

V systému Forth, který používám, je k dispozici slovo MODE. MODE přijímá argument mezi 0 a 3 a podle toho mění režim. Výraz 0 MODE nebo 1 MODE mi samozřejmě nepomůže zapamatovat si, který režim je který. Protože při provádění prezentací potřebuji mezi těmito režimy přepínat, potřebuji mít k dispozici vhodnou sadu slov, která tuto změnu provedou. Tato slova musí také nastavit proměnnou, která obsahuje aktuální počet sloupců - 40 nebo 80. Zde je nejjednodušší způsob, jak tyto požadavky splnit:

Faktorovací kritérium 185

: : : :

40-BAREVNÝ 40-BAREVNÝ 80-BAREVNÝ 80-BAREVNÝ

40 40 80 80

#SLOUPCE #SLOUPCE #SLOUPCE #SLOUPCE #SLOUPCE

! ! ! !

0 1 2 3

REŽIM REŽIM REŽIM REŽIM REŽIM

; ; ; ;

Faktorováním, které eliminuje opakování, dostaneme tuto verzi: : : : : : :

COL-MODE! 40-B&W 40-COLOR 80-B&W 80-COLOR

( 40 40 80 80

#columns mode ) 0 COL-MODE! ; 1 COL-MODE! ; 2 COL-MODE! ; 3 COL-MODE! ;

MODE

#COLUMNS ! ;

Při pokusu o redukci počtu příkazů a také při dodržování zákazu číselně předřazených a pomlčkových názvů však zjistíme, že můžeme použít počet sloupců jako argument zásobníku a vypočítat režim: : B&W : COLOR

( #cols -- ) ( #cols -- )

DUP #COLUMNS ! DUP #COLUMNS !

20 / 20 /

22-

MODE ; 1+ MODE ;

To nám dává tuto syntaxi: 40 80 40 80

ČERNOBÍLE ČERNOBÍLE BAREVNĚ BAREVNĚ

Snížili jsme počet příkazů ze čtyř na dva. Opět však máme několik duplicitních kódů. Pokud tento kód vynásobíme, dostaneme: : COL-MODE! ( #columns chroma?) SWAP DUP #COLUMNS ! 20 / 2- + MODE ; : B&W ( #columns -- ) 0 COL-MODE! ; : COLOR ( #columns -- ) 1 COL-MODE! ; Nyní jsme dosáhli hezčí syntaxe a zároveň jsme výrazně zmenšili velikost objektového kódu. Při použití pouze dvou příkazů, jako v tomto příkladu, může být přínos zanedbatelný. Při větších sadách příkazů však přínosy rostou geometrickou řadou. Naším posledním příkladem je sada slov pro reprezentaci barev v určitém systému. Názvy jako MODRÁ a ČERVENÁ jsou hezčí než čísla. Jedním z řešení může být definice:

186 Faktoring

0 2 4 6 8 10 12 14

KONSTANTNÍ KONSTANTNÍ KONSTANTNÍ KONSTANTNÍ KONSTANTNÍ KONSTANTNÍ KONSTANTNÍ KONSTANTNÍ

ČERNÁ ZELENÁ ČERVENÁ HNĚDÁ TMAVĚ ŠEDÁ SVĚTLE ZELENÁ SVĚTLE ČERVENÁ ŽLUTÁ

1 3 5 7 9 11 13 15

KONSTANTNÍ KONSTANTNÍ KONSTANTNÍ KONSTANTNÍ KONSTANTNÍ KONSTANTNÍ KONSTANTNÍ KONSTANTNÍ

MODRÁ AZUROVÁ PURPUROVÁ ŠEDÁ SVĚTLE MODRÁ SVĚTLE AZUROVÁ SVĚTLE PURPUROVÁ BÍLÁ

Tyto barvy lze použít se slovy BACKGROUND, FOREGROUND a BORDER: Toto řešení však vyžaduje 16 názvů a mnoho z nich je spojeno pomlčkou. Existuje způsob, jak to zjednodušit? Všimli jsme si, že všechny barvy mezi 8 a 15 jsou "světlejšími" verzemi barev mezi 0 a 7. (V hardwaru je jediným rozdílem mezi těmito dvěma sadami nastavení "bitu intenzity"). Pokud "světlost" vynásobíme, můžeme dojít k tomuto řešení: PROMĚNNÁ "LIGHT? ( bit intenzity?) : HUE ( barva) CREATE , DOES> ( -- barva ) @ 'LIGHT? @ 0 ODSTÍN ČERNÁ 1 ODSTÍN MODRÁ 3 ODSTÍN AZUROVÁ 4 ODSTÍN ČERVENÁ 6 ODSTÍN HNĚDÁ 7 ODSTÍN ŠEDÁ : SVĚTLO 8 'LIGHT? ! ;

NEBO

0 'LIGHT? ! ; 2 ODSTÍN ZELENÁ 5 ODSTÍN MAGENTA

Při této syntaxi slovo BLUE samo o sobě vrátí na zásobník "1", ale věta LIGHT BLUE vrátí "9". (Přídavné jméno LIGHT nastavuje příznak, který se používá u odstínů a poté se vymaže.) Pokud je to nutné kvůli čitelnosti, mohli bychom ještě definovat: 8 HUE DARK-GRAY 14 HUE YELLOW Opět jsme tímto přístupem dosáhli příjemnější syntaxe a kratšího objektového kódu.

Faktorovací kritéria 187

Tip 6.16

Nefaktorujte pro faktorizaci. Používejte klišé.

S frází OVER + SWAP se můžeme běžně setkat v některých aplikacích. (Převádí adresu a počet na koncovou a počáteční adresu vhodnou pro DO LOOP). Další běžně vídaná fráze je 1+ SWAP (Převádí pořadí prvního a posledního čísla na pořadí posledního čísla plus jedna a prvního čísla, které vyžaduje DO). Je trochu lákavé chopit se těchto frází a udělat z nich slova, jako například (pro první frázi) RANGE. Moore: Tato konkrétní fráze [OVER + SWAP] je přesně na hranici toho, aby se stala užitečným slovem. Často se však stává, že když něco definujete jako slovo, ukáže se, že to použijete jen jednou. Pokud takovou frázi pojmenujete, máte problém přesně vědět, co dělá RANGE. Nemůžete si tuto manipulaci v hlavě představit. OVER + SWAP má větší mnemotechnickou hodnotu než RANGE.

Těmto frázím říkám "klišé". Drží pohromadě jako smysluplné funkce. Nemusíte si pamatovat, jak fráze funguje, stačí, co dělá. A nemusíte si pamatovat další název.

Faktorování v době kompilace V minulé části jsme se zabývali mnoha technikami organizace kódu a dat, které snižují redundanci. Omezenou redundanci můžeme uplatnit také během kompilace, a to tak, že necháme Forth udělat část špinavé práce. Tip 6.17

Pro maximální udržovatelnost omezte redundanci i v době kompilace.

Předpokládejme, že v naší aplikaci musíme nakreslit devět políček, jak je znázorněno na obrázku 6.1. V našem návrhu potřebujeme mít konstanty, které reprezentují hodnoty, jako je velikost každého políčka, velikost mezery mezi políčky a souřadnice prvního políčka nejvíce vlevo a nejvíce nahoře. Samozřejmě můžeme definovat:

188 Faktorování

Obrázek 6.1: Co máme zobrazit

8 5 4 2

KONSTANTA KONSTANTA KONSTANTA KONSTANTA

******** ******** ******** ******** ********

******** ******** ******** ******** ********

******** ******** ******** ******** ********

******** ******** ******** ******** ********

******** ******** ******** ******** ********

******** ******** ******** ******** ********

******** ******** ******** ******** ********

******** ******** ******** ******** ********

******** ******** ******** ******** ********

ŠIROKÁ ULICE HIGH AVE

(Ulice vedou na východ a na západ; třídy vedou na sever a na jih.) Nyní bychom mohli levý okraj definovat mentálním výpočtem: Chceme všechna tato pole vycentrovat na obrazovce široké 80 sloupců. Chceme-li něco vycentrovat, odečteme jeho šířku od 80 a vydělíme dvěma, abychom určili levý okraj. Abychom zjistili celkovou šířku všech políček, sečteme 8 + 4 + 8 + 4 + 8 = 32 (tři šířky a dvě uličky). (80 - 31)/2 = 24. Mohli bychom tedy zhruba definovat: 24 KONSTANTNÍ LEFTMARGIN a stejný postup použít pro TOPMARGIN. Ale co kdybychom později vzor přepracovali, takže by se změnila šířka nebo třeba mezera mezi políčky? Museli bychom sami přepočítat levý okraj. V prostředí Forth můžeme využít plnou sílu Forthu i při kompilaci. Proč nenechat Forth, aby si to spočítal sám? WIDE 3 * HIGH 3 *

AVE 2 * + 80 SWAP - 2/ KONSTANTA LEFTMARGIN STREET 2 * + 24 SWAP - 2/ KONSTANTA TOPMARGIN

Faktorování v době kompilace 189

Tip 6.18

Pokud hodnota konstanty závisí na hodnotě dřívější konstanty, použijte Forth k výpočtu hodnoty druhé konstanty.

Žádný z těchto výpočtů se neprovádí za běhu aplikace, takže rychlost běhu není ovlivněna. Zde je další příklad. Obrázek 6.2 ukazuje kód pro slovo, které kreslí obrazce. Slovo DRAW vysílá hvězdičku na každé souřadnici x-y uvedené v tabulce nazvané POINTS. (Poznámka: slovo XY umístí kurzor na souřadnici ( x y ) na zásobníku). Všimněte si řádku, který následuje bezprostředně za seznamem bodů: HERE POINTS -

( /tabulka)

2/

KONSTANTA #BODY

Věta "HERE POINTS -" vypočítává počet x-y souřadnic v tabulce: tato hodnota se stává konstantou #POINTS, která se používá jako limit v DO LOOP funkce DRAW. Tato konstrukce umožňuje přidávat nebo odebírat body z tabulky, aniž byste se museli starat o jejich počet. Forth to vypočítá za vás.

Faktorování v době kompilace pomocí definičních slov Prozkoumejme řadu přístupů ke stejnému problému - definování skupiny souvisejících adres. Zde je první pokus: HEX 01A0 KONSTANTA BASE.PORT.ADDRESS BASE.PORT.ADDRESS BASE.PORT.ADDRESS BASE.PORT.ADDRESS DECIMAL

BASE.PORT.ADDRESS KONSTANTA SPEAKER 2+ KONSTANTA FLIPPER-A 4 + KONSTANTA FLIPPER-B 6 + KONSTANTA WIN-LIGHT

Myšlenka je správná, ale implementace je ošklivá. Jediné prvky, které se mění od portu k portu, jsou číselný offset a jméno portu, který je Obrázek 6.2: Další příklad omezení redundance při kompilaci. : P ( x y -- ) C, C, ; CREATE POINTS 10 10 P 10 11 P 10 12 P 10 13 P 10 14 P 11 10 P 12 10 P 13 10 P 14 10 P 11 12 P 12 12 P 13 12 P 14 12 P ZDE POINTS - ( /tabulka) 2/ CONSTANT #POINTS : @POINTS ( i -- x y) 2* POINTS + DUP 1+ C@ SWAP C@ ; : DRAW #POINTS 0 DO I @POINTS XY ASCII * EMIT LOOP ;

190 Faktorování

definováno; vše ostatní se opakuje. Toto opakování naznačuje použití definičního slova. Následující přístup, který je čitelnější, spojuje veškerý opakující se kód do části "dělá" definičního slova: : V tomto řešení provádíme výpočet offsetu za běhu, pokaždé, když vyvoláme jeden z těchto názvů. 2 PORT ( offset -- ) CREATE , \ does> ( -- 'port) @ BASE.PORT.ADDRESS + ; 0 PORT SPEAKER 2 PORT FLIPPER-A 4 PORT FLIPPER-B 6 PORT WIN-LIGHT V tomto řešení provádíme výpočet offsetu za běhu, pokaždé, když vyvoláme jeden z těchto názvů. Efektivnější by bylo provést výpočet v době kompilace, například takto: : V tomto případě jsme vytvořili definiční slovo PORT, které má jedinečné chování při kompilaci, a to přidání offsetu do BASE.PORT.ADDRESS a definování CONSTANT. 0 PORT SPEAKER 2 PORT FLIPPER-A 4 PORT FLIPPER-B 6 PORT WIN-LIGHT. Mohli bychom jít ještě o krok dál. Předpokládejme, že všechny adresy portů jsou od sebe vzdáleny dva bajty. V takovém případě není důvod, proč bychom měli tyto offsety specifikovat. Číselná posloupnost 0246 je sama o sobě zbytečná. V následující verzi začínáme s BASE.PORT.ADDRESS na zásobníku. Definiční slovo PORT tuto adresu duplikuje, vytvoří z ní konstantu a pak k adrese, která je stále na zásobníku, přidá 2 pro další volání PORT. : PORT ( 'port -- 'next-port) DUP CREATE , \ does> ( -- 'port) BASE.PORT.ADDRESS PORT SPEAKER PORT FLIPPER-A PORT FLIPPER-B PORT WIN-LIGHT DROP ( port.address)

2+ ;

Faktorování v době kompilace pomocí definičních slov 191

Všimněte si, že před definováním prvního portu musíme zadat počáteční adresu portu na zásobníku a po dokončení definování všech portů vyvolat příkaz DROP, abychom se zbavili adresy portu, která je stále na zásobníku. Na závěr ještě jedna poznámka. Je velmi pravděpodobné, že se adresa základního portu bude měnit, a proto by měla být definována pouze na jednom místě. To neznamená, že musí být definována jako konstanta. Za předpokladu, že adresa základního portu nebude použita mimo tento lexikon názvů portů, je stejně dobré odkazovat na ni zde číslem. HEX 01A0 ( adr základního portu) PORT SPEAKER PORT FLIPPER-A PORT FLIPPER-B PORT WIN-LIGHT DROP

Iterativní přístup při implementaci Na začátku knihy jsme se zabývali iterativním přístupem a věnovali jsme zvláštní pozornost jeho vlivu na fázi návrhu. Nyní, když mluvíme o implementaci, se podíváme, jak se tento přístup skutečně používá při psaní kódu. Tip 6.19

Pracujte vždy jen na jednom aspektu problému.

Předpokládejme, že jsme pověřeni úkolem nakódovat slovo, které nakreslí nebo vymaže rámeček na dané souřadnici x-y. V tomto případě se jedná o kódování. (Jedná se o stejný problém, který jsme si představili v části nazvané "Faktorování v čase kompilace".) Nejprve zaměříme svou pozornost na problém nakreslení políčka - o jeho vymazání ani nemluvě. Mohli bychom přijít s tímto: : LAYER WIDE 0 DO ASCII * EMIT LOOP ; : BOX ( upper-left-x upper-left-y -- ) HIGH 0 DO 2DUP I + XY LAYER LOOP 2DROP ; Poté, co jsme si vyzkoušeli, zda to funguje správně, se nyní zaměříme na problém použití stejného kódu ke zrušení vykreslení boxu. Řešení je jednoduché: namísto tvrdého kódu ASCII * bychom rádi změnili emitovaný znak z hvězdičky na prázdný. To vyžaduje přidání proměnné a několik čitelných slov pro nastavení obsahu proměnné. Takže: PROMĚNNÁ INK : DRAW ASCII * INK ! ; : UNDRAW BL INK ! ; : LAYER WIDTH 0 DO INK @

192 Faktorování

EMIT

LOOP ;

Definice BOXu spolu se zbytkem aplikace zůstává stejná. Tento přístup umožňuje syntaxi ( x y ) DRAW BOX nebo ( x y ) UNDRAW BOX Přechodem z explicitní hodnoty na proměnnou, která obsahuje hodnotu, jsme přidali úroveň indirekce. V tomto případě jsme přidali indirekci "pozpátku", čímž jsme definici LAYER přidali novou úroveň složitosti, aniž bychom definici podstatně prodloužili. Tím, že se soustředíte na jednu dimenzi problému najednou, můžete každou dimenzi řešit efektivněji. Pokud se ve vašem uvažování vyskytne chyba, bude problém snáze viditelný, pokud nebude zastřen dalším nevyzkoušeným a neotestovaným aspektem vašeho kódu. Tip Neměňte příliš mnoho věcí najednou.

6.20

Zatímco upravujete svou aplikaci - přidáváte novou funkci nebo něco opravujete - je často lákavé jít a opravit několik dalších věcí najednou. Naše rada: Nedělejte to. Při každé úpravě-kompilování provádějte co nejméně změn. Než budete pokračovat, nezapomeňte otestovat výsledky každé revize. Divili byste se, jak často se vám může stát, že provedete tři nevinné úpravy, jen abyste je překompilovali a nic nefungovalo! Provádění změn po jedné zajistí, že když to přestane fungovat, budete vědět proč. Tip Nesnažte se předvídat způsoby faktorů příliš brzy.

6.21

Někteří lidé se diví, proč většina systémů Forth neobsahuje definiční slovo ARRAY. Důvodem je právě toto pravidlo. Moore: Často mám třídu věcí, které se nazývají pole. Nejjednodušší pole pouze přidá k adrese index a vrátí vám adresu. Pole můžete definovat příkazem CREATE X

100 ALLOT

Iterační přístup při implementaci 193

a pak řeknete X + Nebo můžete říct : X

X + ;

Jedním z problémů, který mě nejvíce frustruje, je vědět, zda má cenu vytvářet definiční slovo pro určitou datovou strukturu. Budu mít dostatek případů, aby to mělo opodstatnění? Málokdy předem vím, zda budu mít více než jedno pole. Takže slovo ARRAY nedefinuji. Poté, co zjistím, že potřebuji dvě pole, je tato otázka okrajová. Pokud potřebuji tři, pak je to jasné. Ledaže by byla různá. A je pravděpodobné, že se lišit budou. Možná budete chtít, aby vám je načetl. Možná budete chtít pole bajtů, nebo pole bitů. Možná budete chtít provést kontrolu hranic nebo uložit jeho aktuální délku, abyste mohli přidávat věci na konec. Zatnu zuby a řeknu si: "Mám z pole bajtů udělat pole buněk, jen aby se mi datová struktura vešla do slova, které už mám k dispozici?". Čím složitější je problém, tím menší je pravděpodobnost, že najdete univerzálně použitelnou datovou strukturu. Počet případů, kdy skutečně složitá datová struktura našla univerzální použití, je velmi malý. Jedním z příkladů úspěšné komplexní datové struktury je slovník jazyka Forth. Velmi pevná struktura, velká univerzálnost. Ve Forthu se používá všude. Ale to je vzácné. Pokud se rozhodnete definovat slovo ARRAY, provedli jste krok dekompozice. Vyřadili jste pojem pole ze všech slov, která později vrátíte zpět. A přešli jste na další úroveň abstrakce. Vytváření úrovní abstrakce je dynamický proces, který nelze předvídat.

Tip 6.22

Dnes to udělejte tak, aby to fungovalo. Zítra to optimalizujte.

Opět Moore. V den tohoto rozhovoru Moore dokončoval práci na návrhu počítače Forth na úrovni desky s použitím komerčně dostupných integrovaných obvodů. Jako součást sady nástrojů pro návrh desky vytvořil simulátor v jazyce Forth, aby otestoval logiku desky: Dnes ráno jsem si uvědomil, že jsem zaměnil popisy čipů s jejich umístěním na desce. To se mi v tuto chvíli dokonale hodí pro mé účely, ale až vymyslím další desku, pro kterou budu chtít použít stejné čipy, tak jsem to uspořádal velmi špatně. Měl jsem to zohlednit popisem tady a použitím tam. Pak bych měl k dispozici jazyk pro popis čipů. Dobře. V době, kdy jsem to dělal, jsem se o takovou úroveň optimalizace nezajímal.

194 Faktorování

I kdyby mě to tehdy napadlo, pravděpodobně bych si řekl: "Dobře, to udělám později," a pak bych pokračoval v tom, co jsem dělal. Optimalizace pro mě tehdy nebyla nejdůležitější. Samozřejmě se snažím věci dobře faktorizovat. Ale když se mi zdá, že něco nejde udělat dobře, řeknu: "Prostě to uděláme tak, aby to fungovalo." A pak to udělám. Mou motivací není lenost, ale vědomí, že se na cestě objeví další věci, které toto rozhodnutí ovlivní způsobem, který nedokážu předvídat. Snažit se to teď optimalizovat je pošetilé. Dokud nebudu mít před sebou celý obraz, nemohu vědět, co je optimální.

Postřehy v této části by neměly být v rozporu s tím, co bylo řečeno dříve o skrývání informací a o předvídání prvků, které se mohou změnit. Dobrý programátor se neustále snaží vyvažovat náklady na zabudování měnitelnosti a náklady na pozdější změnu v případě potřeby. Tato rozhodnutí vyžadují zkušenosti. Obecně však platí, že Tip Předvídejte věci, které se mohou změnit, uspořádáním informací, ne přidáváním složitosti. Složitost přidávejte jen v případě, že je to nutné k tomu, aby aktuální iterace fungovala.

6.23

Shrnutí V této kapitole jsme probrali různé techniky a kritéria pro faktorizaci. Zkoumali jsme také, jak se iterační přístup uplatňuje ve fázi implementace.

Literatura [1] W. P. Stevens, G. J. Myers a L. L. Constantine, IBM Systems Journal, roč. 13, č. 2, 1974, Copyright 1974 by International Business Machines Corporation. [2] G.A. Miller, "The Magical Number Seven, Plus or Minus Two: Some Limits on our Capacity for Processing Information", Psychol. Rev., roč. 63, s. 81-97, březen 1956. [3] Kim R. Harris, "Definition Field Address Conversion Operators," Forth- 83 Standard, Forth Standards Team.

Shrnutí 195

SEDMÝ

Manipulace s daty: Zásobníky a stavy

Forth zpracovává data jedním ze dvou způsobů: buď na zásobníku, nebo v datových strukturách. Kdy použít který přístup a jak spravovat zásobník i datové struktury, to jsou témata této kapitoly.

Stylový zásobník Nejjednodušší způsob, jak si slova jazyka Forth předávají argumenty, je prostřednictvím zásobníku. Tento proces je "jednoduchý", protože veškerá práce s odesíláním a vyskakováním hodnot na zásobník a ze zásobníku je implicitní. Moore: Zásobník dat využívá této myšlenky "skryté informace". Argumenty předávané mezi podprogramy nejsou v posloupnosti volání explicitní. Tentýž argument se může vlnit celou řadou slov zcela neviditelně, dokonce pod úrovní povědomí programátora, jednoduše proto, že na něj nemusí být explicitně odkazováno.

Jedním z důležitých důsledků tohoto přístupu: Argumenty jsou nepojmenované. Nacházejí se na zásobníku, nikoli v pojmenovaných proměnných. Tento efekt je jedním z důvodů elegance jazyka Forth. Zároveň je to jeden z důvodů, proč může být špatně napsaný kód jazyka Forth nečitelný. Pojďme tento paradox prozkoumat. Vynález zásobníku je analogický vynálezu zájmen v angličtině. Vezměme si tento úryvek: Vezměte tento dárek, zabalte ho do hedvábného papíru a vložte do krabice.

Všimněte si, že slovo "dárek" je zde zmíněno pouze jednou. Dárek je od této chvíle označován jako "to". Neformálnost konstrukce "it" činí angličtinu čitelnější (za předpokladu, že odkaz je jednoznačný). Stejně tak u zásobníku činí implicitní předávání argumentů kód čitelnějším. Zdůrazňujeme procesy, nikoli předávání argumentů procesům.

198 Manipulace s daty: Zásobníky a stavy

Naše analogie se zájmeny naznačuje, proč může být špatný Forth tak nečitelný. Mluvený jazyk se stává nepřehledným, když se příliš mnoho věcí označuje zájmeny. Sundejte obal a otevřete krabici. Vyjměte dárek a zahoďte ho.

Problém této pasáže spočívá v tom, že používáme "to" k označení příliš mnoha věcí najednou. Existují dvě řešení této chyby. Nejjednodušším řešením je dodat místo "to" skutečné jméno: Odstraňte obal a otevřete krabici. Vyjměte dárek a krabici vyhoďte.

Nebo můžeme zavést slova "dříve" a "později". Nejlepším řešením je však přepracování úryvku: Sundejte obal a otevřete dárek. Vyhoďte krabici.

Ve Forthu tedy máme analogické postřehy: Tip Zjednodušte kód pomocí zásobníku. Ale neukládejte zásobník příliš hluboko v rámci jedné definice. Přepracujte návrh, nebo v krajním případě použijte pojmenovanou proměnnou.

7.1

Někteří nováčci v jazyce Forth se na zásobník dívají stejně jako gymnasta na trampolínu: jako na zábavné místo, kde se dá skákat. Zásobník je však určen k předávání dat, nikoli k akrobacii. Jak hluboký je tedy "příliš hluboký"? Obecně platí, že tři prvky na zásobníku jsou maximum, které můžete zvládnout v rámci jedné definice. (V aritmetice s dvojnásobnou délkou zabírá každý "prvek" dvě pozice zásobníku, ale logicky se s ním operátory jako 2DUP, 2OVER atd. zachází jako s jediným prvkem.) V běžném slovníku operátorů zásobníku je ROT jediný, který vám umožňuje přístup ke třetímu prvku zásobníku. Kromě operátorů PICK a ROLL (které si brzy okomentujeme) neexistuje žádný jednoduchý způsob, jak se dostat k čemukoli pod ním. Abychom naši analogii protáhli do krajnosti, možná tři prvky na zásobníku odpovídají třem anglickým zájmenům "this", "that" a "t'other".

Přepracování Pojďme se stát svědky případu, kdy chybný přístup vede k nepřehlednému problému se zásobníkem. Předpokládejme, že se snažíme zapsat definici +THRU (viz kapitola pátá, oddíl "Organizace výpisu", pododdíl "Relativní načítání"). Rozhodli jsme se, že tělo naší smyčky bude ....

DO

I LOAD

LOOP ;

Přepracování 199

to znamená, že LOAD vložíme do smyčky a pak zařídíme, aby index a limit odpovídaly absolutně načítaným obrazovkám. Na zásobníku máme zpočátku: lo hi, kde "lo" a "hi" jsou posuny od BLK. Musíme je pro DO proložit takto: hi+1+blk lo+blk Naším největším problémem je přičíst k oběma offsetům hodnotu BLK. Už jsme se dostali na špatnou odbočku, ale zatím o tom nevíme. Pokračujme tedy dál. Zkusíme: lo hi BLK @ lo hi blk SWAP lo blk hi OVER lo blk hi blk + lo blk hi+blk 1+ lo blk hi+blk+1 ROT ROT hi+blk+1 lo blk + hi+blk+1 lo+blk Zvládli jsme to, ale jaký zmatek! Pokud jsme žrouti trestu, mohli bychom udělat další dva pokusy, které dorazí na: BLK @

DUP ROT + 1+

BLK @

ROT OVER +

ROT ROT +

a ROT ROT + 1+

SWAP

Všechny tři sekvence dělají totéž, ale zdá se, že kód je stále rozmazanější, nikoli lepší. Se zkušenostmi se naučíme rozpoznat kombinaci ROT ROT jako znamení nebezpečí: zásobník je příliš přeplněný. Aniž bychom museli řešit alternativy, rozpoznáme problém: jakmile vytvoříme dvě kopie "blk", máme na zásobníku čtyři prvky.

200 Manipulace s daty: Zásobníky a stavy

V tomto okamžiku se obvykle jako první uchýlíme k návratovému zásobníku: BLK @

DUP >R

+ 1+

SWAP R> +

(Viz "Stylový návratový zásobník", který bude následovat.) Zde jsme DUPovali "blk", uložili jednu kopii na návratový zásobník a druhou kopii přidali k "hi". Je to sice zlepšení. Ale čitelné? Dále nás napadne: "Možná bychom potřebovali pojmenovanou proměnnou". Samozřejmě, že už jednu máme: BLK. Tak to zkusíme: BLK @

+ 1+

SWAP BLK @ +

Nyní je to čitelnější, ale stále poměrně dlouhé a navíc zbytečné. BLK @ + se objeví dvakrát. "BLK @ +"? To zní povědomě. Konečně se naše neurony propojily. Podíváme se zpět na právě definovaný zdroj pro +LOAD: : +LOAD

( offset -- )

BLK @ +

LOAD ;

Toto slovo, +LOAD, by mělo vykonávat práci. Vše, co musíme napsat, je: : +THRU

( lo hi )

1+ SWAP

DO

I +LOAD

LOOP ;

Efektivnější verzi jsme zde nevytvořili, protože práce BLK @ + bude provedena při každém průchodu smyčkou. Vytvořili jsme však čistší, koncepčně jednodušší a čitelnější kus kódu. V tomto případě je neefektivita nepostřehnutelná, protože k ní dochází pouze při načítání každého bloku. Přepracování nebo přehodnocení problému bylo cestou, kterou jsme se měli vydat, jakmile se věci začaly znepříjemňovat.

Lokální proměnné Většinu problémů lze uspořádat tak, aby na zásobníku bylo v jednom okamžiku potřeba jen několik argumentů. Občas se však nedá nic dělat. Zde je příklad nejhoršího případu. Předpokládejme, že máte slovo s názvem LINE, které kreslí čáru mezi libovolnými dvěma body, zadanými jako souřadnice v tomto pořadí: ( x1 y1 x2 y2), kde x1 , y1 představují souřadnice x, y pro jeden koncový bod a x2 , y2 představují opačný koncový bod. Nyní je třeba napsat slovo pro kreslení krabic s názvem [BOX], které přijímá čtyři argumenty v tomto pořadí: ( x1 y1 x2 y2)

Lokální proměnné 201

kde x1 y1 představují souřadnice x, y levého horního rohu krabice a x2 y2 představují souřadnice pravého dolního rohu. Nejenže máte na zásobníku čtyři prvky, ale na každý z nich se musíte odkazovat více než jednou, když kreslíte čáry z bodu do bodu. Přestože k získání čtyř argumentů používáme zásobník, algoritmus kreslení boxu se k povaze zásobníku nehodí. Pokud spěcháte, bylo by asi nejlepší zvolit jednodušší cestu: VARIABLE TOP ( y koordinuje vrchol krabice) VARIABLE LEFT ( x " levá strana) VARIABLE BOTTOM ( y " spodní strana) VARIABLE RIGHT ( x " pravá strana) : [BOX] ( x1 y1 x2 y2) BOTTOM ! RIGHT ! TOP ! LEVÁ @ HORNÍ @ PRAVÁ @ HORNÍ @ ŘÁDEK PRAVÁ @ HORNÍ @ PRAVÁ @ DOLNÍ @ ŘÁDEK PRAVÁ @ DOLNÍ @ LEVÁ @ DOLNÍ @ ŘÁDEK LEVÁ @ DOLNÍ @ LEVÁ @ HORNÍ @ ŘÁDEK ;

LEVÝ !

Vytvořili jsme čtyři pojmenované proměnné, jednu pro každou souřadnici. První věc, kterou [BOX] udělá, je naplnění těchto proměnných argumenty ze zásobníku. Poté se nakreslí čtyři čáry, které se na proměnné odkazují. Takové proměnné, které se používají pouze v rámci definice (nebo v některých případech v rámci lexikonu), se nazývají "lokální proměnné". Mnohokrát jsem se provinil tím, že jsem si hrál na horkokrevného a snažil se co nejvíce věcí dělat na zásobníku, místo abych definoval lokální proměnnou. Existují tři důvody, proč se této kokotiny vyvarovat. Zaprvé, kódovat tímto způsobem je otrava. Za druhé, výsledek je nečitelný. Zatřetí, veškerá vaše práce se stane zbytečnou, když bude nutná změna návrhu a změní se pořadí dvou argumentů na zásobníku. DUPy, OVERy a ROTy ve skutečnosti neřešily problém, jenom šoupaly věci do pozice. S ohledem na tento třetí důvod doporučuji následující postup: Tip 7.2

Zejména ve fázi návrhu ponechávejte na zásobníku pouze argumenty, které bezprostředně používáte. Pro všechny ostatní vytvořte lokální proměnné. (Pokud je to nutné, ve fázi optimalizace tyto proměnné odstraňte.)

Za čtvrté, pokud je definice extrémně časově kritická, mohou tyto záludné manipulátory zásobníku, (např. ROT ROT), opravdu sežrat hodinové takty. Přímý přístup k proměnným je rychlejší. Pokud je to opravdu časově kritické, možná budete muset stejně převést do assembleru. V takovém případě všechny problémy se zásobníkem vyletí dveřmi, protože všechna data budou odkazována buď v registrech, nebo nepřímo přes registry. Naštěstí definice s nejnepořádnějšími argumenty zásobníku jsou často ty, které jsou zapsány v kódu. Příkladem je naše primitivum [BOX]. CMOVE> je další.

202 Manipulace s daty: Zásobníky a stavy

Přístup, který jsme zvolili u [BOX], je určitě lepší než strávit půl hodiny žonglováním s položkami na zásobníku, ale rozhodně to není nejlepší řešení. Nepříjemné na něm jsou náklady na vytvoření čtyř pojmenovaných proměnných, hlaviček a všeho ostatního, výhradně pro použití v rámci této jediné rutiny. (Pokud cíleně kompilujete aplikaci, která nebude vyžadovat hlavičky ve slovníku, jedinou ztrátou bude 8 bajtů v RAM pro proměnné. V budoucích systémech Forth mohou být hlavičky stejně odděleny do jiných stránek paměti; ztráta bude opět jen 8 bajtů.) Dovolte mi zopakovat: Tento příklad představuje nejhorší možnou situaci a ve většině aplikací jazyka Forth se vyskytuje jen zřídka. Pokud jsou slova dobře rozfázována, pak je každé slovo navrženo tak, aby dělalo jen velmi málo. Slova, která dělají málo, obvykle vyžadují málo argumentů. V tomto případě však máme co do činění se dvěma body, z nichž každý je reprezentován dvěma souřadnicemi. Můžeme tento návrh změnit? Za prvé, LINE může být příliš primitivní primitivum. Vyžaduje čtyři argumenty, protože může kreslit čáry mezi libovolnými dvěma body, v případě potřeby i diagonálně. Při kreslení našeho boxu můžeme potřebovat pouze dokonale svislé a vodorovné čáry. V takovém případě můžeme pro kreslení těchto čar napsat výkonnější, ale méně specifické VERTIKÁLNÍ a HORIZONTÁLNÍ. Každé z nich vyžaduje pouze tři argumenty: x a y počáteční pozice a délku. Toto rozdělení funkcí zjednodušuje definici [BOX]. Nebo můžeme zjistit, že tato syntaxe je pro uživatele přirozenější: 10 10 ORIGINÁL! 30 30 BOX kde ORIGIN! nastavuje dvouprvkový ukazatel na "počátek", místo, kde bude box začínat (levý horní roh). Pak "30 30 BOX" nakreslí box o výšce 30 jednotek a šířce 30 jednotek vzhledem k počátku. Tento přístup snižuje počet argumentů zásobníku BOX v rámci návrhu. Tip Při rozhodování, které argumenty zpracovávat prostřednictvím datových struktur, a nikoli přes zásobník, vybírejte argumenty, které jsou trvalejší nebo které představují aktuální stav.

7.3

O PICK a ROLL Někteří lidé mají rádi slova PICK a ROLL. Používají tato slova pro přístup k prvkům z libovolné úrovně zásobníku. My je však nedoporučujeme. Za prvé, PICK a ROLL nabádají programátora, aby zásobník považoval za pole, což není. Pokud máte na zásobníku tolik prvků, že potřebujete PICK a ROLL, měly by být tyto prvky místo toho v poli.

O PICK a ROLL 203

Zadruhé vybízejí programátora, aby se odvolával na argumenty, které byly na zásobníku ponechány vyššími, volajícími definicemi, aniž by byly explicitně předány jako argumenty. Tím se definice stává závislou na jiných definicích. To je nestrukturované - a nebezpečné. A konečně, pozice prvku na zásobníku závisí na tom, co je nad ním, a počet věcí nad ním se může neustále měnit. Například pokud máte adresu na čtvrté pozici zásobníku dole, můžete napsat 4 PICK @ a získat její obsah. Musíte však napsat ( n) 5 PICK ! protože s "n" na zásobníku je nyní adresa na páté pozici. Takový kód se špatně čte a hůře upravuje.

Vytvářejte nákresy zásobníku Když už musíte vyřešit nějakou složitou situaci se zásobníkem, je nejlepší ji vyřešit pomocí papíru a tužky. Někteří lidé si dokonce vytvářejí formuláře, jako je ten na obrázku 7.1. Takto formálně provedené (místo na zadní straně telefonního účtu) slouží komentáře zásobníku jako pěkná pomocná dokumentace.

Tipy pro zásobníky Tip 7.4

Dbejte na to, aby se efekty zásobníku vyrovnaly při všech možných řídicích tocích.

V komentáři zásobníku pro CMOVE> na obrázku 7.1 představuje vnitřní závorka obsah cyklu DO LOOP. Hloubka zásobníku při výstupu ze smyčky je stejná jako při vstupu do ní: jeden prvek. Uvnitř vnějších závorek je výsledek zásobníku klauzule IF stejný jako v případě klauzule ELSE: jeden prvek, který zbývá. (Na tom, co tento zbylý prvek představuje, nezáleží, což je symbolizováno symbolem "x" vedle THEN.) Tip 7.5

Když děláte dvě věci se stejným číslem, proveďte nejdříve tu funkci, která bude pod ním.

Například: : POČET

( a -- a+1 # )

DUP C@

SWAP 1+

SWAP ;

(kde nejprve získáte počet) je efektivnější zapsat: : COUNT

( a -- a+1 # )

DUP 1+

(kde se nejprve vypočítá adresa).

204 Manipulace s daty: Zásobníky a stavy

SWAP C@ ;

Obrázek 7.1: Příklad komentáře k zásobníku.

Tip Pokud je to možné, zachovejte ve všech možných případech stejný počet návratových argumentů.

7.6

Často se setkáte s definicí, která provede nějakou práci a v případě, že se něco nepovede, vrátí chybový kód identifikující problém. Zde je jeden ze způsobů, jak může být navrženo rozhraní zásobníku: ( -- error-code f | -- t) Pokud je příznak pravdivý, operace proběhla úspěšně. Pokud je příznak false, operace byla neúspěšná a na zásobníku je další hodnota, která označuje povahu chyby.

Tipy pro zásobník 205

Manipulaci se zásobníkem však usnadníte, pokud rozhraní přepracujete tak, aby vypadalo takto: ( -- error-code | O=no-error) Jedna hodnota slouží jako příznak a zároveň (v případě chyby) jako kód chyby. Všimněte si, že se používá obrácená logika; nenulová hodnota znamená chybu. Pro chybové kódy můžete použít libovolné hodnoty kromě nuly.

Stylový návratový zásobník Co říkáte na toto použití návratového zásobníku pro uložení dočasných argumentů? Je to dobrý styl, nebo ne? Někteří lidé se nad jeho použitím velmi pohoršují. Návratový zásobník však nabízí nejjednodušší řešení některých drsných zaseknutí zásobníku. Svědčí o tom definice CMOVE> v předchozí části. Pokud se rozhodnete návratový zásobník k tomuto účelu použít, nezapomeňte, že používáte komponentu jazyka Forth k jinému účelu, než pro který je určena. (Viz oddíl nazvaný "Sdílení komponent" dále v této kapitole.) Zde je několik návrhů, abyste si nestříleli do nohy: Tip 7.7

1. Operátory návratového zásobníku udržujte symetrické. 2. Udržujte operátory návratového zásobníku symetrické za všech podmínek toku řízení. 3. V definicích faktorů dávejte pozor, aby jedna část neobsahovala jeden operátor návratového zásobníku a druhá jeho protějšek. 4. Jsou-li použity uvnitř cyklu DO LOOP, musí být operátory návratového zásobníku v rámci cyklu symetrické a v kódu ohraničeném >R a R> již neplatí I.

Pro každé >R musí existovat R> ve stejné definici. Někdy se operátory budou jevit jako symetrické, ale vzhledem k řídicí struktuře tomu tak není. Například: ... BEGIN ... >R ... WHILE ... R> ... REPEAT Pokud tuto konstrukci použijete ve vnější smyčce své aplikace, vše poběží v pořádku až do okamžiku, kdy ji ukončíte (třeba o několik hodin později), kdy najednou vybouchne. Problém? Při posledním průchodu smyčkou bylo přeskočeno řešení R>.

206 Manipulace s daty: Zásobníky a stavy

Problém s proměnnými Přestože data, která nás bezprostředně zajímají, zpracováváme na zásobníku, jsme závislí na mnoha informacích uložených v proměnných, připravených k opakovanému přístupu. Část kódu může měnit obsah proměnné, aniž by nutně musela vědět cokoli o tom, jak budou tato data použita, kdo je bude používat nebo kdy a zda vůbec budou použita. Jiný kus kódu může načíst obsah proměnné a použít jej, aniž by věděl, odkud tato hodnota pochází. Každé slovo, které na zásobník posune hodnotu, musí jiné slovo tuto hodnotu spotřebovat. Zásobník nám poskytuje komunikaci mezi jednotlivými body, jako je pošta. Naproti tomu proměnné lze nastavit libovolným příkazem a přistupovat k nim libovolný početkrát - nebo vůbec - libovolným příkazem. Proměnné jsou k dispozici každému, kdo se chce podívat - jako graffiti. Proměnné lze tedy použít k vyjádření aktuálního stavu věcí. Použití aktuálnosti může zjednodušit řešení problémů. V příkladu s římskými číslicemi ve čtvrté kapitole jsme použili proměnnou COLUMN# k vyjádření aktuálního desetinného místa; slova ONER, FIVER a TENER závisela na této informaci, aby určila, který typ symbolu se má zobrazit. Nemuseli jsme pokaždé zadávat oba popisy, jako v případě TENS ONER, TENS FIVER atd. Na druhou stranu proudovost přidává novou úroveň složitosti. Abychom něco učinili aktuálním, musíme nejprve definovat proměnnou nebo nějaký typ datové struktury. Musíme ji také nezapomenout inicializovat, pokud existuje nějaká šance, že se na ni část našeho kódu bude odkazovat dříve, než ji jiná část bude mít možnost nastavit. Závažnějším problémem proměnných je, že nejsou "reentrantní". Ve víceúlohovém systému Forth musí mít každá úloha, která vyžaduje lokální proměnné, své vlastní kopie. K tomuto účelu slouží proměnné USER jazyka Forth. (Viz část Starting Forth, kapitola devět, "Forth geografie".) Dokonce i v rámci jedné úlohy se definice, která odkazuje na proměnnou, hůře testuje, ověřuje a opakovaně používá v jiné situaci než v situaci, kdy se argumenty předávají přes zásobník. Předpokládejme, že implementujeme editor textového procesoru. Potřebujeme rutinu, která vypočítá počet znaků mezi aktuální pozicí kurzoru a předchozí sekvencí carriage-return/line-feed. Napíšeme tedy word, který používá DO LOOP začínající na aktuální pozici (CURSOR @) a končící na nulté pozici, přičemž hledá znak pro posuv řádku. Jakmile smyčka najde sekvenci znaků, odečteme její relativní adresu od naší aktuální pozice kurzoru its-position CURSOR @

SWAP -

a určíme vzdálenost mezi nimi. Efekt zásobníku našeho slova je následující: ( -- vzdálenost-předchozí-cr/lf)

Problém s proměnnými 207

Při pozdějším kódování však zjistíme, že podobné slovo potřebujeme k výpočtu vzdálenosti od libovolného znaku - nikoliv aktuální pozice kurzoru - k prvnímu předchozímu znaku řádkového posuvu. Nakonec vyřadíme faktor "CURSOR @" a umožníme předání počáteční adresy jako argumentu na zásobníku, což vede k následujícímu výsledku: ( starting-position -- distance-to-previous-cr/lf) Vyřazením odkazu na proměnnou jsme definici učinili užitečnější. Tip 7.8

Pokud se nejedná o zahlcení zásobníku až k nečitelnosti, snažte se předávat argumenty raději přes zásobník než je vytahovat z proměnných.

Kogge: Většina modularity jazyka Forth pochází z návrhu a zacházení se slovy jazyka Forth jako s "funkcemi" v matematickém smyslu. Podle mých zkušeností se programátor Forthu obvykle dost snaží vyhnout definování jakýchkoli globálních proměnných kromě těch nejnutnějších (mám kamaráda, který má nad stolem nápis "Help stamp out variables") a snaží se psát slova s takzvanou "referenční průhledností", tj. při stejných vstupech na zásobníku bude slovo vždy dávat stejné výstupy ze zásobníku bez ohledu na globálnější kontext, ve kterém se provádí. Ve skutečnosti je tato vlastnost přesně to, co používáme, když testujeme slova izolovaně. Slova, která tuto vlastnost nemají, se testují podstatně obtížněji. V jistém smyslu je "pojmenovaná proměnná", jejíž hodnota se často mění, další nejhorší věcí po dnes "zakázaném" GOTO.

Již dříve jsme navrhovali používat lokální proměnné zejména ve fázi návrhu, abychom eliminovali provoz na zásobníku. Je důležité si uvědomit, že přitom byly proměnné odkazovány pouze v rámci jedné definice. V našem příkladu [BOX] přijímá čtyři argumenty ze zásobníku a ihned je načítá do lokálních proměnných pro své vlastní použití. Na tyto čtyři proměnné se mimo tuto definici neodkazuje a slovo se chová bezpečně jako funkce. Programátoři, kteří nejsou zvyklí na jazyk, v němž lze data předávat implicitně, nevyužívají zásobník vždy tak plně, jak by měli. Michael Ham naznačuje, že důvodem může být to, že začínající uživatelé Forthu zásobníku nedůvěřují [1]. Přiznává, že se zpočátku cítil bezpečněji, když ukládal hodnoty do proměnných, než když je nechával na zásobníku. "Nikdo neví, co by se mohlo stát, kdyby se to všechno na zásobníku házelo," měl pocit. Nějakou dobu mu trvalo, než docenil, že "pokud se slova drží řádně při sobě, používají zásobník pouze pro svůj očekávaný vstup a výstup a uklízejí po sobě, lze na ně pohlížet jako na uzavřené systémy...". Mohl jsem na začátku smyčky umístit počet na zásobník, projít celou procedurou pro každou skupinu a na konci se počet objevil zpět na vrcholu zásobníku, ani o chlup mimo."

208 Manipulace s daty: Zásobníky a stavy

"Výstřel z děla v rychle jedoucím vlaku, řítící se mezi lopatkami větrného mlýna a očekávající, že se chytí hrazdy visící z horkovzdušného balónu. . . Říkal jsem ti, Eso, že je tu příliš mnoho proměnných!"

Lokální a globální proměnné/inicializace Jak jsme viděli dříve, proměnná, která se používá výhradně v rámci jedné definice (nebo jednoho lexikonu), skrytá před ostatním kódem, se nazývá lokální proměnná. Proměnná, která se používá ve více než jednom lexikonu, se nazývá globální proměnná. Jak jsme viděli v předchozí kapitole, sada globálních proměnných, které společně popisují společné rozhraní mezi několika lexikony, se nazývá "lexikon rozhraní". Forth nerozlišuje mezi lokálními a globálními proměnnými. Programátoři Forthu však rozlišují. Moore: Měli bychom psát pro čtenáře. Pokud se na něco odkazujeme pouze lokálně, na dočasnou proměnnou určenou pouze pro kumulování součtu, měli bychom ji definovat lokálně. Šikovnější je definovat ji v bloku, kde se používá, kde je vidět její komentář. Pokud se používá globálně, měli bychom věci shromažďovat podle jejich logické funkce a definovat je společně na samostatné obrazovce. Na každém řádku jednu s komentářem. Otázkou je, kde je inicializovat. Někteří říkají, že na stejném řádku, hned za jeho definicí. Ale tím se komentáře rozhází a na nějaký slušný komentář není místo. A navíc to inicializaci rozptýlí po celé aplikaci. Já mám tendenci provádět veškerou inicializaci v načítací obrazovce. Po načtení všech bloků inicializuji věci, které je třeba inicializovat. Může také nastavit vyhledávací tabulky barev nebo spustit nějaký inicializační kód. Pokud je váš program určen k cílové kompilaci, pak je snadné napsat slovo v místě, které zahrnuje veškerou inicializaci. Může to být mnohem složitější. Definoval jsem proměnné v paměti ROM, kde byly všechny proměnné vypnuty v poli ve vysoké paměti a počáteční hodnoty jsou v paměti ROM a v době inicializace zkopíruji počáteční hodnoty. Ale obvykle inicializujete jen několik proměnných na jinou hodnotu než nula.

Uložení a obnovení stavu Proměnné mají tu vlastnost, že když změníte jejich obsah, vymažete hodnotu, která tam byla předtím. Podívejme se na některé problémy, které to může způsobit, a na některé věci, které s nimi můžeme udělat. BASE je proměnná, která udává aktuální číselný radix pro všechny číselné vstupy a výstupy. V systémech Forth se běžně vyskytují následující slova: : DECIMAL 10 BASE ! ; : HEX 16 BASE ! ; Předpokládejme, že jsme napsali slovo, které zobrazuje "výpis" paměti. Obvykle pracujeme v desítkové soustavě, ale chceme výpis v šestnáctkové soustavě. Napíšeme tedy:

210 Manipulace s daty: Zásobníky a stavy

: DUMP HEX

( a # ) ... ( kód pro výpis) ... DECIMAL ;

To funguje - většinou. Existuje však předpoklad, že se chceme vrátit do desetinného režimu. Co když pracoval v šestnáctkové soustavě a chce se vrátit do šestnáctkové? Než změníme základnu na HEX, musíme uložit jeho aktuální hodnotu. Po ukončení výpisu ji obnovíme. To znamená, že uloženou hodnotu musíme dočasně schovat, zatímco budeme výpis formátovat. Jedním z míst, kde to lze provést, je návratový zásobník: : DUMP ( a # ) BASE @ >R HEX

( kód pro výpis)

R> BASE !

Pokud se věci stanou příliš nepřehlednými, možná budeme muset definovat dočasnou proměnnou: PROMĚNNOU OLD-BASE : DUMP ( a # ) BASE @ OLD-BASE ! HEX ( kód pro výpis ) OLD-BASE @ BASE ! ; Jak rychle se věci zkomplikují. Pokud v této situaci patří aktuální i stará verze proměnné pouze vaší aplikaci (a není součástí systému) a pokud se stejná situace vyskytne vícekrát, použijte techniku faktoringu: : BURY ( a) DUP 2+ 2 CMOVE ; : EXHUME ( a) DUP 2+ SWAP 2 CMOVE ; Pak místo definování dvou proměnných, jako jsou CONDITION a OLD-CONDITION, definujte jednu proměnnou o dvojnásobné délce: 2VARIABLE CONDITION K uložení a obnovení původní hodnoty použijte BURY a EXHUME: : DIDDLE CONDITION BURY CONDITION EXHUME ;

17 CONDITION !

( diddle )

BURY uloží "starou" verzi podmínky na CONDITION 2+. Přesto je třeba být opatrný. Vrátíme-li se k našemu příkladu DUMP, předpokládejme, že jste se rozhodli přidat přátelskou funkci umožňující uživateli kdykoli ukončit výpis stisknutím klávesy "escape". Uvnitř smyčky tedy sestavíte test na stisknutí klávesy, a pokud ano, provedete QUIT. Co se však stane? Uživatel začne v desítkové soustavě a pak zadá DUMP. V polovině ukončí DUMP a kupodivu se ocitne v šestnáctkové soustavě. V tomto jednoduchém případě je nejlepším řešením nepoužívat QUIT, ale raději řízené opuštění smyčky (pomocí LEAVE atd.) na konec definice, kde se vynuluje BASE. Ve velmi složitých aplikacích je řízené ukončení často nepraktické, přesto je třeba mnoho proměnných nějakým způsobem uvést do přirozeného stavu.

Uložení a obnovení stavu 211

Moore na tento příklad reaguje: To se opravdu zamotává. Vytváříte si problémy. Když chci hexadecimální výpis, řeknu HEX DUMP. Pokud chci desetinný výpis, řeknu DECIMAL DUMP. Nedávám DUMPu privilegium, aby si hrál s mým prostředím. Existuje filozofická volba mezi obnovením situace, když skončíte, a nastolením situace, když začínáte. Dlouho jsem měl pocit, že byste měli obnovit situaci, když skončíte. A snažil bych se to dělat důsledně všude. Ale je těžké definovat "všude". Takže teď mám tendenci nastolit stav před začátkem. Pokud mám slovo, kterému záleží na tom, kde se věci nacházejí, musí je lépe nastavit. Pokud je někdo jiný změní, nemusí se starat o jejich resetování. Výstupů je víc než vstupů.

V případech, kdy potřebuji provést resetování předtím, než skončím, se mi osvědčilo mít jediné slovo (které nazývám PRISTINE), které toto resetování provede. Slovo PRISTINE vyvolávám: - v místě normálního ukončení aplikace - v místě, kde může uživatel záměrně ukončit aplikaci (těsně před QUIT) - v jakémkoli místě, kde může dojít k fatální chybě, která způsobí přerušení. A konečně, když se setkáte s touto situací, kdy je třeba uložit/obnovit hodnotu, ujistěte se, že se nejedná pouze o špatný faktor. Předpokládejme například, že jsme napsali: : LONG : SHORT : GAME

18 #HOLES ! ; 9 #HOLES ! ; #HOLES @ O DO

I HOLE PLAY

LOOP ;

Aktuální HRA je buď DLOUHÁ, nebo KRÁTKÁ. Později se rozhodneme, že potřebujeme slovo pro hraní libovolného počtu jamek. Vyvoláme tedy GAME, přičemž dbáme na to, abychom nepřehlušili aktuální hodnotu #HOLES: : HOLES

( n)

#HOLES @

SWAP #HOLES !

GAME

#HOLES ! ;

Protože jsme HOLES potřebovali až po definici GAME, zdálo se nám to složitější; HOLES jsme postavili kolem GAME. Ale ve skutečnosti - možná už to vidíte - je na místě přemýšlet: : HOLES ( n) O DO I HOLE PLAY : GAME #HOLES @ HOLES ;

LOOP ;

Můžeme postavit GAME kolem HOLES a vyhnout se všem těm nesmyslům s ukládáním/obnovováním.

212 Manipulace s daty: Hromádky a stavy

Zásobníky aplikací V minulé části jsme prozkoumali některé způsoby ukládání a obnovování jedné předchozí hodnoty. Některé aplikace vyžadují uložení a obnovení několika hodnot. Nejlepší řešení tohoto problému můžete často najít v definici vlastního zásobníku. Zde je kód pro uživatelský zásobník včetně velmi jednoduché kontroly chyb (chyba zásobník vymaže): STACK STACK STACK : ?BAD ( ?) IF .": VYTVOŘIT ZÁSOBNÍK 12 ALLOT \ ZDE KONSTANTA STACK> : INIT-STACK STACK STACK : ?BAD ( ?) IF ." STACK : PUSH ( n) 2 STACK +! : POP ( -- n) STACK @ @

{ 2tos-pointer | 10stack [5 buněk] } ! ; INIT-STACK ERROR " INIT-STACK ABORT THEN ; STACK @ DUP STACK> = ?BAD ! ; -2 STACK +! STACK @ STACK < ?BAD ;

Slovo PUSH vezme hodnotu ze zásobníku dat a "strčí" ji na tento nový zásobník. Slovo POP je opačné, "vysune" hodnotu z nového zásobníku na zásobník dat jazyka Forth. Ve skutečné aplikaci byste možná chtěli názvy PUSH a POP změnit, aby lépe odpovídaly svému koncepčnímu účelu.

Sdílení komponent Tip Komponentu je možné legálně použít i k jinému účelu, než ke kterému je určena, pokud:

7.9

1. Všechna použití komponenty se vzájemně vylučují 2. Každé přerušení použití komponenty po ukončení obnoví komponentu do předchozího stavu. V opačném případě je potřeba další komponenta nebo úroveň složitosti.

Jednoduchý příklad tohoto principu jsme viděli u návratového zásobníku. Návratový zásobník je komponenta systému Forth určená k uchovávání návratových adres, a tím slouží jako ukazatel toho, kde jste byli a kam jdete. Používat návratový zásobník jako držák dočasných hodnot je možné a v mnoha případech i žádoucí. Problémy nastanou, když se ignoruje jedno z výše uvedených omezení. V mém textovém formátovači může být výstup neviditelný. Tato funkce má dva účely: 1. pro pohled dopředu, aby se zjistilo, zda se něco vejde, a 2. pro formátování obsahu (celý dokument je naformátován a čísla stránek jsou vypočítána, aniž by se cokoli skutečně zobrazilo).

Zásobníky aplikací 213

Bylo lákavé si myslet, že když jsem jednou přidal možnost zneviditelnit výstup, mohl bych tuto funkci použít k oběma účelům. Bohužel se tyto dva účely vzájemně nevylučují. Podívejme se, co by se stalo, kdybych se pokusil toto pravidlo porušit. Představte si, že slovo DISPLAY provádí výstup a je dostatečně chytré na to, aby vědělo, zda má být viditelné, nebo neviditelné. Slova VISIBLE a INVISIBLE nastavují tento stav, resp. Můj kód pro pohled dopředu nejprve provede funkci INVISIBLE, pak testovací formátování nadcházejícího textu, aby určil jeho délku, a nakonec provede funkci VISIBLE, aby se vše vrátilo do normálního stavu. To funguje dobře. Později přidám funkci tabulky obsahu. Kód nejprve provede příkaz INVISIBLE, pak projde dokument a určí čísla stránek atd. a nakonec provede příkaz VISIBLE, aby se vše vrátilo do normálního stavu. Háček? Předpokládejme, že spustím tabulku obsahu a narazím na jedno z těch míst, kde se dívám dopředu. Když skončím s prohlížením dopředu, spustím VISIBLE. Najednou začnu tisknout dokument v době, kdy jsem měl spustit obsah. Řešení? Je jich několik. Jedno z řešení vidí problém v tom, že kód lookahead ruší příznak visible/invisible, který mohl být přednastaven tabulkou obsahu. Proto by měl být kód lookahead zodpovědný za uložení a pozdější obnovení příznaku. Jiné řešení spočívá ve vedení dvou samostatných proměnných - jedna označuje, že se díváme dopředu, a druhá, že tiskneme obsah. Slovo DISPLAY vyžaduje, aby oba příznaky byly false, aby se skutečně něco zobrazilo. Existují dva způsoby, jak dosáhnout druhého přístupu, v závislosti na tom, jak chcete problém rozložit. Zaprvé bychom mohli jednu podmínku vnořit do druhé: : [DISPLAY] ... ( původní definice, vždy provede výstup) ... ; VARIABLE 'LOOKAHEAD? ( t=looking-ahead) : <DISPLAY> 'LOOKAHEAD? @ NOT IF [DISPLAY] THEN ; PROMĚNNÁ 'TOC? ( t=setting-table-of-contents) : DISPLAY 'TOC? @ NOT IF <DISPLAY> THEN ; DISPLAY kontroluje, zda nenastavujeme obsah, a vyvolá <DISPLAY>, který zase kontroluje, zda se nedíváme dopředu, a vyvolá [DISPLAY]. Ve vývojovém cyklu se slovo [DISPLAY], které vždy provádí výstup, původně jmenovalo DISPLAY. Pak bylo definováno nové DISPLAY, které obsahovalo kontrolu lookahead, a původní definice byla přejmenována na [DISPLAY], tedy

214 Manipulace s daty: Zásobníky a stavy

přidala úroveň složitosti zpět, aniž by se změnil kód, který DISPLAY používal. Nakonec, když byla přidána funkce tabulky obsahu, byl definován nový DISPLAY, který zahrnoval kontrolu tabulky obsahu, a původní DISPLAY byl přejmenován na <DISPLAY>. To je jeden z přístupů k používání dvou proměnných. Dalším je zahrnutí obou testů do jednoho slova: : DISPLAY

'LOOKAHEAD? @

'TOC @ OR

NOT IF [DISPLAY] THEN ;

V tomto konkrétním případě však může celý zmatek zjednodušit ještě jiný přístup. Jednu proměnnou můžeme použít nikoli jako příznak, ale jako čítač. Definujeme: PROMĚNNOU 'INVISIBLE? ( t=invisible) : DISPLAY 'INVISIBLE? @ O= IF [DISPLAY] THEN ; : INVISIBLE 1 'INVISIBLE? +! ; : VISIBLE -1 'NEVIDITELNÝ? +! ; Kód lookahead začíná vyvoláním funkce INVISIBLE, která posune počítadlo o jedničku nahoru. Nenulová hodnota je "true", takže DISPLAY neprovede výstup. Po skončení lookaheadu kód vyvolá VISIBLE, který sníží čítač zpět na nulu ("false"). Kód tabulky obsahu také začíná příkazem VISIBLE a končí příkazem INVISIBLE. Pokud spouštíme tabulku obsahu a zároveň narazíme na lookahead, druhé vyvolání VISIBLE zvýší čítač na dvojku. Následné vyvolání příkazu INVISIBLE sníží čítač na jedničku, takže jsme stále neviditelní a zůstaneme neviditelní, dokud nebude spuštěna tabulka obsahu. (Všimněte si, že místo NOT musíme dosadit 0=. Norma z roku 83 změnila NOT tak, aby znamenal doplněk jedničky, takže 1 NOT dává true. Mimochodem, myslím, že to byla chyba.) Toto použití čítače však může být nebezpečné. Vyžaduje totiž paritu použití příkazů: dvě VISIBLE dávají invisible. To znamená, že pokud VISIBLE nepřipojí čítač: : VISIBLE

'INVISIBLE? @

1-

O MAX

"NEVIDITELNÝ? ! ;

Stavová tabulka Jedna proměnná může vyjadřovat jednu podmínku, buď příznak, hodnotu, nebo adresu funkce. Soubor podmínek dohromady představuje stav aplikace nebo určité komponenty [2]. Některé aplikace vyžadují možnost uložit aktuální stav a později jej obnovit nebo třeba mít několik střídajících se stavů.

Tabulka stavů 215

Tip 7.10

Pokud aplikace vyžaduje současné zpracování skupiny stavů, použijte stavovou tabulku, nikoli samostatné proměnné.

Jednoduchý případ vyžaduje uložení a obnovení stavu. Předpokládejme, že na začátku máme šest proměnných reprezentujících stav určité komponenty, jak je znázorněno na obrázku 7.2. Obrázek 7.2: Soubor souvisejících proměnných. PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ PROMĚNNÁ

NAHOŘE DOLE VLEVO VPRAVO UVNITŘ VEN

Nyní předpokládejme, že je potřebujeme všechny uložit, aby mohlo probíhat další zpracování, a později je všechny obnovit. Mohli bychom definovat: : @STATE ( -- top bottom left right inside out) TOP @ BOTTOM @ LEFT @ RIGHT @ INSIDE @ OUT @ ; : !STATE ( top bottom left right inside out -- ) OUT ! INSIDE ! RIGHT ! LEVÝ ! BOTTOM ! TOP ! ; čímž se všechny hodnoty uloží na zásobník, dokud není čas je obnovit. Nebo bychom mohli pro každou z výše uvedených proměnných definovat alternativní proměnné, do kterých bychom uložili každou hodnotu zvlášť. Upřednostňovaná technika však zahrnuje vytvoření tabulky, přičemž každý prvek tabulky je označován jménem. Poté vytvoříme druhou tabulku stejné délky. Jak vidíte na obrázku 7.3, můžeme stav uložit zkopírováním tabulky s názvem POINTERS do druhé tabulky s názvem SAVED. Obrázek 7.3: Koncepční model ukládání tabulky stavu.

Tento přístup jsme implementovali pomocí kódu na obrázku 7.4.

216 Manipulace s daty: Zásobníky a stavy

Obrázek 7.4: Implementace ukládání/obnovování stavové tabulky. 0 CONSTANT POINTERS \ adresa stavové tabulky PATCHED LATER : POSITION ( o -- o+2 ) CREATE DUP , 2+ DOES> ( -- a ) @ POINTERS + ; 0 \ počáteční offset POSITION TOP POSITION BOTTOM POSITION LEFT POSITION RIGHT POSITION INSIDE POSITION OUT CONSTANT /POINTERS \ konečný vypočtený offset HERE ' POINTERS >BODY ! /POINTERS ALLOT \ reálná tabulka CREATE SAVED /POINTERS ALLOT \ místo uložení : SAVE POINTERS SAVED /POINTERS CMOVE ; : RESTORE SAVED POINTERS /POINTERS CMOVE ;

Všimněte si, že v této implementaci názvy ukazatelů TOP, BOTTOM atd. vracejí vždy stejnou adresu. V každém okamžiku se používá pouze jedno umístění, které reprezentuje aktuální hodnotu jakéhokoli stavu. Všimněte si také, že POINTERS (název tabulky) definujeme pomocí CONSTANT, nikoli pomocí CREATE, přičemž používáme fiktivní hodnotu nula. Je to proto, že se na POINTERS odkazujeme v definičním slově POSITION, ale teprve poté, co jsme definovali všechna jména polí, víme, jak velká musí být tabulka, a můžeme ji skutečně VYTVOŘIT. Jakmile vytvoříme názvy polí, definujeme velikost tabulky jako konstantu /POINTERS. Nakonec vyhradíme místo pro samotnou tabulku a do konstanty POINTERS zapíšeme její počáteční adresu (ZDE). (Slovo >BODY převádí adresu vrácenou tickem na adresu hodnoty konstanty). POINTERS tedy vrací adresu později přidělené tabulky, stejně jako jméno definované příkazem CREATE vrací adresu tabulky přidělené přímo pod hlavičkou jména. Ačkoli je platné opravit hodnotu KONSTANTY v době kompilace, jak to děláme zde, existuje omezení stylu: Tip Hodnota CONSTANTu by se nikdy neměla měnit po kompilaci aplikace.

7.11

Případ střídání stavů je o něco složitější. V této situaci potřebujeme střídat dva (nebo více) stavů tam a zpět, přičemž nikdy nesmíme klopit

Tabulka stavů 217

podmínky v každém stavu, když přecházíme do druhého stavu. Obrázek 7.5 ukazuje konceptuální model pro tento druh stavové tabulky. Obrázek 7.5: Konceptuální model pro tabulky střídavých stavů.

V tomto modelu mohou jména TOP, BOTTOM atd. ukazovat na jednu ze dvou tabulek, REAL nebo PSEUDO. Pokud je tabulka REAL aktuální, všechna jména ukazatelů odkazují na adresy v tabulce REAL; pokud je aktuální tabulka PSEUDO, odkazují na tabulku PSEUDO. Kód na obrázku 7.6 implementuje tento mechanismus střídání stavů. Slova WORKING a PRETENDING vhodně mění ukazatel. Například: PRACOVNÍ 10 NAHOŘE ! TOP ? 10 Obrázek 7.6: Implementace mechanismu střídání stavů. VARIABLE 'POINTERS \ ukazatel na tabulku stavů : POINTERS ( -- adr aktuální tabulky) 'POINTERS @ ; : POSITION ( o -- o+2 ) CREATE DUP , 2+ DOES> ( -- a ) @ POINTERS + ; 0 \ počáteční offset POSITION TOP POSITION BOTTOM POSITION LEFT POSITION RIGHT POSITION INSIDE POSITION OUT CONSTANT /POINTERS \ konečný vypočtený offset CREATE REAL /POINTERS ALLOT \ skutečná stavová tabulka CREATE PSEUDO /POINTERS ALLOT \ dočasná stavová tabulka : WORKING REAL 'POINTERS ! ; PRACOVNÍ : PŘEDSTÍRAJÍCÍ PSEUDO 'POINTERS ! ;

218 Manipulace s daty: Zásobníky a stavy

PŘEDSTÍRÁNÍ 20 TOP ! TOP ? 20 PRACOVNÍ TOP ? 10 PŘEDSTÍRÁNÍ TOP ? 20 Hlavním rozdílem tohoto druhého přístupu je, že jména procházejí další úrovní indirekce (POINTERS byl změněn z konstanty na definici s dvojtečkou). Názvy polí mohou ukazovat na jednu ze dvou stavových tabulek. Každé jméno má tedy o něco více práce. V prvním přístupu navíc názvy odkazují na pevně daná místa; při každém ukládání nebo obnovování hodnot je nutné provést CMOVE. V tomto přístupu nám ke změně aktuální tabulky stačí změnit jediný ukazatel.

Vektorové provádění Vektorové provádění rozšiřuje myšlenky aktuálnosti a indirekce mimo data i na funkce. Stejně jako můžeme ukládat hodnoty a příznaky do proměnných, můžeme ukládat i funkce, protože na funkce se lze odkazovat pomocí adresy. Tradiční techniky implementace vektorovaného vykonávání jsou popsány v kapitole Starting Forth, kapitola 9. V této části probereme novou syntaxi, kterou jsem vymyslel a o níž si myslím, že ji lze za mnoha okolností použít elegantněji než tradiční metody. Syntaxe se nazývá DOER/MAKE. (Pokud váš systém tato slova neobsahuje, podívejte se do přílohy B, kde najdete kód a podrobnosti o implementaci.) Funguje takto: Slovo, jehož chování bude vektorové, definujete pomocí definičního slova DOER, jako ve slově DOER PLATFORM Zpočátku nové slovo PLATFORM nedělá nic. Pak můžete napsat slova, která změní to, co PLATFORM dělá, pomocí slova MAKE: : LEVÉ KŘÍDLO MAKE PLATFORM : PRAVÉ KŘÍDLO MAKE PLATFORM

." zastánce " ; ." odpůrce " ;

Když se odvoláte na LEVICOVÝ, výraz MAKE PLATFORM změní to, co bude dělat PLATFORM. Když nyní zadáte příkaz PLATFORM, zobrazí se: LEFTWING ok PLATFORM proponent ok RIGHTWING způsobí, že PLATFORM zobrazí "protivníka". PLATFORMU můžete použít i v rámci jiné definice:

Vektorové provedení 219

: SLOGAN ." Náš kandidát je dlouhodobě " PLATFORM ." silného zdanění pro podnikání. " ; Příkaz LEVÝ SLOGAN zobrazí jedno prohlášení o kampani, zatímco PRAVÝ SLOGAN zobrazí jiné. Kód "MAKE" může být libovolný kód jazyka Forth, libovolně dlouhý nebo libovolně velký; nezapomeňte jej jen zakončit středníkem. Středník na konci LEFTWING slouží jak pro LEFTWING, tak pro kousek kódu za MAKE. Když MAKE přesměruje provádění slova DOER, zastaví také provádění slova, ve kterém se objevuje. Když například vyvoláte příkaz LEFTWING, MAKE přesměruje příkaz PLATFORM a ukončí jej. Vyvolání příkazu LEFTWING nezpůsobí vypsání slova "proponent". Obrázek 7.7 demonstruje tento bod na konceptuální ilustraci slovníku. Pokud chcete pokračovat ve vykonávání, můžete místo středníku použít slovo ;AND. ;AND ukončí kód, na který slovo DOER ukazuje, a obnoví vykonávání definice, ve které se objevuje, jak vidíte na obrázku 7.8. A konečně můžete řetězit "výrobu" slov DOER za sebou tak, že nepoužijete ;AND. Obrázek 7.9 to vysvětluje lépe, než bych o tom mohl psát.

Použití DOER/MAKE Existuje mnoho příležitostí, kdy se konstrukce DOER/MAKE ukáže jako výhodná. Jsou to např: 1. Pro změnu stavu funkce (kdy není nutné externí testování stavu). Slova LEVÝ a PRAVÝ mění stav slova PLATFORM. 2. K vydělování vnitřních výrazů z podobných definic, ale v rámci řídicích struktur, jako jsou smyčky. Uvažujme definici slova DUMP, určeného k odhalení obsahu určené oblasti paměti : DUMP ( a # ) O DO I 16 MOD O= IF CR DUP I + DUP I + @ 6 U.R 2 +LOOP DROP ;

5 U.R

2 SPACES

THEN

Problém nastane, když napíšete definici nazvanou CDUMP, která je určena k formátování výstupu podle bajtů, nikoliv buněk:

220 Manipulace s daty: Zásobníky a stavy

Obrázek 7.7: DOER a MAKE. DOER JOE ok JOE Vytvoří slovo DOER s názvem JOE, které nic nedělá : TEST MAKE JOE 1 . ; ok JOE TEST

MAKE

JOE

1

.

;

1

.

;

Definuje nové slovo s názvem TEST TEST ok JOE TEST

MAKE

JOE

MAKE přesměruje JOE tak, aby ukazoval na kód za MAKE JOE, a zastaví provádění zbytku TEST. JOE 1 ok Provede kód, na který ukazuje JOE ( 1 . ).

: CDUMP ( a # ) O DO I 16 MOD O= IF CR DUP I + DUP I + C@ 4 U.R LOOP DROP ;

5 U.R

2 SPACES

THEN

Kód v těchto dvou definicích je totožný s výjimkou tučně vyznačených fragmentů. Faktorování je však obtížné, protože fragmenty se vyskytují uvnitř DO LOOP. Zde je řešení tohoto problému pomocí DOER/MAKE. Kód, který se mění, byl nahrazen slovem .UNIT, jehož chování je vektorováno kódem v DUMP a CDUMP. (Uvědomte si, že "1 +LOOP" má stejný účinek jako "LOOP".) DOER .UNIT ( a -- přírůstek) \ zobrazit bajt nebo buňku : <DUMP> ( a # ) O DO I 16 MOD O= IF CR DUP I + 5 U.R 2 SPACES DUP I + .UNIT +LOOP DROP ;

THEN

Použití DOER/MAKE 221

Obrázek 7.8: Více MAKE paralelně pomocí ;AND. DOER SAM ok DOER BIFF ok SAM

BIFF

Vytvoří dvě slova DOER, která nic nedělají : TESTB MAKE SAM 2 . ;AND MAKE BIFF 3 . ; ok TESTB

MAKE

SAM

2

.

;AND

MAKE

BIFF

3

.

;

MAKE

BIFF

3

.

;

Definuje nové slovo TESTB. TESTB ok SAM TESTB

BIFF MAKE

SAM

2

.

;AND

První MAKE přesměruje SAM tak, aby ukazoval na kód, který následuje za ním. . . SAM TESTB

BIFF MAKE

SAM

2

.

;A

POKRAČOVAT MAKE

BIFF

3

.

;

AND pokračuje ve vykonávání TESTB. Druhé MAKE přesměruje BIFF. SAM 2 ok BIFF 3 ok Dvě slova DOER byla současně přesměrována jediným slovem TESTB. Kód SAM se zastaví na ;AND. Kód BIFF se zastaví na středníku.

: DUMP ( a #) : CDUMP ( a #)

MAKE .UNIT @ MAKE .UNIT C@

6 U.R 4 U.R

2 ;A <DUMP> ; 1 ;A <DUMP> ;

Všimněte si, jak DUMP a CDUMP nastavují vektor a poté pokračují ve vykonávání shellu (slovo <DUMP>). 3. Změna stavu souvisejících funkcí vyvoláním jediného příkazu. Např: DOER TYPE' DOER EMIT' DOER SPACES'

222 Manipulace s daty: Zásobníky a stavy

Obrázek 7.9: Více příkazů MAKE za sebou : TESTC MAKE JOE 4 . MAKE JOE 5 . ; ok TESTC

MAKE

JOE

4

.

MAKE

JOE

5

.

;

MAKE

JOE

5

.

;

5

.

;

.

;

Definuje nové slovo s názvem TESTC. TESTC ok JOE TESTC

MAKE

JOE

4

.

MAKE přesměruje JOE na kód za MAKE JOE. JOE 4 ok TESTC

MAKE

JOE

4

.

MAKE

JOE

Provede kód, na který ukazuje JOE ( 4 . MAKE atd.). JOE TESTC

MAKE

JOE

4

.

MAKE

JOE

5

Po provedení příkazu 4 . druhý MAKE přesměruje JOE tak, aby ukazoval na pětku. (Nebylo žádné ;AND, které by to zastavilo.). JOE 5 ok TESTC

MAKE

JOE

4

.

MAKE

JOE

5

.

;

Druhým zadáním JOE se spustí nový kód, na který ukazuje JOE ( 5 . ). Zde ukazatel zůstane.

DOER CR' : VISIBLE

: INVISIBLE

MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE

TYPE' TYPE ;A EMIT' EMIT ;A SPACES' SPACES ;A CR' CR ; TYPE' 2DROP ;A EMIT' DROP ;A SPACES' DROP ;A CR' ;

Použití DOER/MAKE 223

Zde jsme definovali vektorovou množinu výstupních slov, přičemž každé jméno má na konci značku "prime". VISIBLE jim nastaví jejich očekávané funkce. INVISIBLE z nich udělá no-ops a sežere argumenty, které by jim byly normálně předány. Řekněte INVISIBLE a jakákoli slova definovaná v termínech těchto čtyř výstupních operátorů nebudou vytvářet žádný výstup. 4. Změnit stav pouze pro další výskyt, poté stav opět změnit (nebo resetovat). Předpokládejme, že píšeme dobrodružnou hru. Když hráč poprvé přijde do určité místnosti, hra zobrazí podrobný popis. Pokud se hráč do stejné místnosti vrátí později, hra zobrazí kratší zprávu. Napíšeme: DOER ANNOUNCE : LONG MAKE ANNOUNCE CR ." Nacházíte se ve velkém sále s obrovským trůnem" CR ." zakrytým červeným sametovým baldachýnem." CR .". MAKE ANNOUNCE CR ." Jsi v trůnním sále." ; Slovo ANNOUNCE zobrazí kteroukoli ze zpráv. Nejprve řekneme LONG, abychom inicializovali ANNOUNCE na dlouhou zprávu. Nyní můžeme ANNOUNCE otestovat a zjistíme, že vytiskne dlouhou zprávu. Poté však pokračuje v "nucení" ANNOUNCE zobrazit krátkou zprávu. Pokud otestujeme ANNOUNCE podruhé, vytiskne krátkou zprávu. A bude tak činit i nadále, dokud znovu nevyslovíme LONG. V podstatě tak vytváříme frontu chování. Do fronty můžeme zařadit libovolný počet chování a nechat každé z nich nastavit další. Následující příklad (ačkoli není příliš praktický) to ilustruje. DOER WHERE VARIABLE SHIRT VARIABLE PANTS VARIABLE DRESSER VARIABLE CAR : ORDER \ specifikuje pořadí hledání MAKE WHERE SHIRT MAKE WHERE PANTS MAKE WHERE DRESSER MAKE WHERE CAR MAKE WHERE O ; : HUNT ( -- a|O ) \ najít místo obsahující 17 ORDER 5 O DOERE DUP O= OVER @ 17 = OR IF LEAVE ELSE DROP THEN LOOP ;

224 Manipulace s daty: Zásobníky a stavy

V tomto kódu jsme vytvořili seznam proměnných a poté definovali POŘADÍ, ve kterém se mají hledat. Slovo HUNT prochází každou z nich a hledá první, která obsahuje hodnotu 17. HUNT vrací buď adresu správné proměnné, nebo nulu, pokud žádná z nich tuto hodnotu nemá. Toho se dosáhne prostým pětinásobným provedením příkazu WHERE. Pokaždé WHERE vrátí jinou adresu, jak je definováno v ORDER, a nakonec nulu. Můžeme dokonce definovat slovo DOER, které přepíná své vlastní chování donekonečna: DOER ŘEČ : ALTERNATIVNÍ ZAČÍT DĚLAT ŘEČ ." AHOJ " MAKE SPEECH ." GOODBYE " O UNTIL ; 5. Pro implementaci dopředného odkazu. Odkaz dopředu je obvykle potřeba jako "háček", tj. slovo vyvolané v nízkoúrovňové definici, ale vyhrazené pro použití komponentou definovanou později ve výpisu. Chcete-li implementovat dopředný odkaz, sestavte hlavičku slova pomocí DOER, a to před vyvoláním jeho jména. DOER STILL-UNDEFINED Později ve výpisu použijte MAKE; MAKE STILL-UNDEFINED ALL THAT JAZZ ; (Nezapomeňte, že MAKE může být použito i mimo definici s dvojtečkou.) 6. V případě, že se jedná o definici s dvojtečkou, použijte MAKE. Rekurze, přímá nebo nepřímá. Přímá rekurze nastává, když slovo vyvolává samo sebe. Dobrým příkladem je rekurzivní definice největšího společného jmenovatele: GCD a, b =

a GCD z b, a mod b

pokud b = O pokud b > O

To se pěkně převede na: DOER GCD ( a b -- gcd) MAKE GCD ?DUP IF DUP ROT ROT

MOD

GCD

POTOM ;

Nepřímá rekurze nastává, když jedno slovo vyvolá druhé slovo, zatímco druhé slovo vyvolá první. To lze provést pomocí tvaru: B : A ... B ... ; MAKE B ... A ... ; 7. Ladění. Často definuji:

Použití DOER/MAKE 225

DOER SNAP (zkratka pro SNAPSHOT) a pak upravím SNAP do své aplikace v místě, kde chci vidět, co se děje. Například pomocí SNAPu vyvolaného uvnitř hlavní smyčky interpretu klávesových zkratek jej mohu nastavit tak, aby mi umožnil sledovat, co se děje s datovou strukturou při zadávání kláves. A mohu změnit, co SNAP dělá, aniž bych musel překompilovat smyčku. Situace, ve kterých je vhodnější použít přístup tick-and-execute, jsou ty, ve kterých potřebujete kontrolu nad adresou vektoru, například při vektorování přes prvek v rozhodovací tabulce nebo při pokusu o uložení/obnovení obsahu vektoru.

Shrnutí V této kapitole jsme se zabývali kompromisy mezi používáním zásobníku a používáním proměnných a jiných datových struktur. Použití zásobníku je výhodnější z hlediska testování a opakovaného použití, ale příliš mnoho hodnot, s nimiž se na zásobníku manipuluje pomocí jediné definice, poškozuje čitelnost a možnost zápisu. Prozkoumali jsme také techniky ukládání a obnovování datových struktur a na závěr jsme se věnovali studiu vektorovaného provádění pomocí DOER/MAKE.

Literatura [1] Michael Ham, "Why Novices Use So Many Variables", Forth Dimensions, roč. 5, č. 1, s. 1. 4, listopad/prosinec 1983. [2] Daniel Slater, "A State Space Approach to Robotics," The Journal of Forth Application and Research, 1, 1 (září 1983), 17.

226 Manipulace s daty: Hromady a stavy

OSM

Minimalizace řídicích struktur

Řídicí struktury nejsou ve Forthu tak důležité jako v jiných jazycích. Programátoři ve Forthu mají tendenci psát velmi složité aplikace ve smyslu krátkých slov, bez velkého důrazu na konstrukce IF THEN. Existuje několik technik pro minimalizaci řídicích struktur. Patří mezi ně např: - počítání nebo počítání - skrývání podmíněných výrazů pomocí refaktorizace - používání strukturovaných výstupů - vektorování - redesign. V této kapitole se budeme zabývat těmito technikami pro zjednodušení a odstranění řídicích struktur z kódu.

Co je na řídicích strukturách tak špatného? Než začneme odříkávat seznam tipů, zastavme se u toho, proč bychom se měli podmínkovým strukturám vyhýbat. Používání podmíněných struktur zvyšuje složitost kódu. Čím složitější je váš kód, tím hůře se čte a udržuje. Čím více částí má stroj, tím větší je pravděpodobnost, že se porouchá. A tím těžší je pro někoho jej opravit. Moore vypráví tento příběh: Nedávno jsem se vrátil do společnosti, pro kterou jsme před několika lety dělali nějakou práci. Zavolali si mě, protože jejich program je už pět let starý a velmi se zkomplikoval. Jejich programátoři do něj chodili a opravovali věci, přidávali stavové proměnné a podmínky. Každý příkaz, který si pamatuji jako jednoduchou věc před pěti lety, se nyní velmi zkomplikoval. "If this, else if this, else if this"... a pak jednoduchá věc.

228 Minimalizace řídicích struktur

Když si ten příkaz čtu teď, je pro mě nemožné přijít na to, co dělá a proč. Musel bych si pamatovat, co která proměnná indikuje, proč je v tomto případě relevantní, a pak co se děje jako její důsledek - nebo neděje. Začalo to nevinně. Měli zvláštní případ, o který se potřebovali starat. Aby tento zvláštní případ zvládli, vložili na jedno místo podmínku. Pak zjistili, že ji potřebují také tady a tady. A pak ještě několik dalších. Každý postupný krok jen přidal do programu trochu zmatku. Protože to byli programátoři, měli v tom jasno. Konečný výsledek byl katastrofální. Nakonec měli půl tuctu příznaků. Otestujte tenhle, resetujte ho, nastavte tamten a tak dále. V důsledku této podmínky jste věděli, že se objeví další podmínky, na které si musíte dávat pozor. Vytvořili logický ekvivalent špagetového kódu navzdory možnosti strukturovaného programu. Složitost šla daleko za hranice toho, co kdy zamýšleli. Ale zavázali se, že se touto cestou vydají, a přehlédli jednoduché řešení, díky němuž by to všechno bylo zbytečné - mít dvě slova místo jednoho. Buď se řekne JÍT, nebo PŘIPRAVIT. Ve většině aplikací je pozoruhodně málo případů, kdy je třeba testovat podmínku. Například ve videohře opravdu neřeknete "Pokud stiskne tlačítko A, pak udělej tohle; pokud stiskne tlačítko B, pak udělej něco jiného." Tohle je jenom jedna z možností. Takovou logiku neprovádíte. Pokud stiskne tlačítko, něco uděláte. To, co uděláte, je spojeno s tlačítkem, nikoli s logikou. Podmínky samy o sobě nejsou špatné - jsou základní konstrukcí. Ale program se spoustou kondicionálů je nepřehledný a nečitelný. Jediné, co můžete udělat, je zpochybnit každou z nich. Každá podmínka by ve vás měla vyvolat otázku: "Co dělám špatně?". To, co se snažíte podmíněnou podmínkou udělat, lze udělat i jinak. Dlouhodobé důsledky jiného způsobu jsou lepší než dlouhodobé důsledky podmínky.

Než si představíme některé podrobné techniky, podívejme se na tři přístupy k použití kondicionálu v konkrétním příkladu. Na obrázcích 8.1, 8.2 a 8.3 jsou znázorněny tři verze návrhu pro bankomat. První příklad pochází přímo ze Školy pro strukturované programátory. Logika aplikace závisí na správném vnoření příkazů IF. Snadno čitelné? Řekněte mi, za jakých podmínek dojde k sežrání uživatelovy karty. Chcete-li odpovědět, musíte buď počítat ELSE zdola a přiřazovat k nim stejný počet IF shora, nebo použít rovnítko. Druhá verze, obrázek 8.2, ukazuje zlepšení, které může mít na čitelnost použití mnoha malých pojmenovaných procedur. Karta uživatele je snědena, pokud není vlastník platný.

Co je na řídicích strukturách tak špatného? 229

Obrázek 8.1: Strukturovaný přístup. AUTOMATIC-TELLER IF karta je platná DO IF vlastník karty je platný DO IF požadavek na výběr DO IF autorizační kód je platný DO dotaz na částku IF požadavek ≤ aktuální zůstatek DO IF výběr ≤ dostupná hotovost DO prodej měny debetní účet ELSE zpráva ukončit relaci ELSE zpráva ukončit relaci ELSE zpráva ukončit relaci ELSE IF autorizační kód je platný DO dotaz na částku přijmout obálku přes poklop kreditní účet ELSE zpráva ukončit relaci ELSE sníst kartu ELSE zpráva END

Ale i s tímto vylepšením závisí návrh každého slova zcela na pořadí, v jakém musí být testy provedeny. Údajně "nejvyšší" úroveň postupu je zatížena eliminací nejhoršího, nejtriviálnějšího druhu události. A každý test se stává odpovědným za vyvolání dalšího testu. Třetí verze se nejvíce blíží příslibu jazyka Forth. Slovo nejvyšší úrovně vyjadřuje přesně to, co se děje konceptuálně, a ukazuje pouze hlavní cestu. Každé z podřízených slov má svůj vlastní chybový výstup, který nezatěžuje čtení hlavního slova. Jeden test nemusí vyvolat další test. Také TRANSACT je navržen s ohledem na to, že uživatel bude zadávat požadavky stisknutím tlačítek na klávesnici. Nejsou nutné žádné podmínky. Jedno tlačítko zahájí výběr, jiné vklad. Tento přístup se snadno přizpůsobí pozdějším změnám návrhu, například přidání funkce pro převod peněz. (A tento přístup se tak nestává závislým na hardwaru.

230 Minimalizace řídicích struktur

Obrázek 8.2: Vnořování podmíněných procedur v rámci pojmenovaných procedur. AUTOMATIC-TELLER PROCEDURE READ-CARD IF card is readable THEN ELSE eject card END PROCEDURE CHECK-OWNER IF owner is valid THEN ELSE eat card END

CHECK-OWNER

CHECK-CODE

PROCEDURE CHECK-CODE IF zadaný kód odpovídá vlastníkovi THEN ELSE zpráva, ukončení relace PROCEDURE TRANSACT IF žádost o výběr ELSE DEPOSIT END

POTOM

PROCEDURE WITHDRAW Dotaz If request ≤ current balance

TRANSACT END

WITHDRAW

THEN

PROCEDURE DISBURSE IF disbursement ≤ available cash vend currency debet account ELSE message END

DISBURSE

KONEC

POTOM

POSTUP DEPOSIT přijmout obálku připsat na účet

Podrobnosti rozhraní ke klávesnici mohou být skryty v lexikonu klávesnice, READ-BUTTON a BUTTON). Forth vám samozřejmě umožní použít kterýkoli z těchto tří přístupů. Kterému dáváte přednost?

Jak eliminovat řídicí struktury V této části se budeme zabývat četnými technikami, jak zjednodušit podmíněné struktury nebo se jim vyhnout. Většina z nich povede k vytvoření kódu, který bude čitelnější, lépe udržovatelný a efektivnější. Některé z technik vedou ke kódu, který je efektivnější, ale ne vždy tak čitelný. Pamatujte si proto: Ne všechny tipy budou použitelné ve všech situacích.

Jak odstranit řídicí struktury 231

Obrázek 8.3: Refaktorizace a/nebo odstranění podmíněných struktur. AUTOMATICKÝ PŘÍKAZ : SPUSTIT READ-CARD

CHECK-OWNER

CHECK-CODE

: READ-CARD platná sekvence kódů NENÍ čitelná THEN ; : CHECK-OWNER vlastník není platný

IF

sníst kartu

TRANSACT IF

vysunout kartu

QUIT

: CHECK-CODE zadaný kód se neshoduje s kódem vlastníka POTÉ ;

; QUIT

POTÉ ; IF

zpráva

QUIT

: READ-BUTTON ( -- adr-of-button's-function) ( primitiv závislý na zařízení) ; : TRANSACT READ-BUTTON

EXECUTE ;

1 BUTTON WITHDRAW 2 BUTTON DEPOSIT : WITHDRAW Žádost o dotaz ≤ aktuální zůstatek

IF

: DISBURSE výplata ≤ dostupná hotovost prodej měna debetní účet ELSE zpráva THEN ;

DISBURSE

THEN ;

IF

: DEPOSIT přijmout obálku kreditní účet ;

Použití slovníku Tip 8.1

Každé funkci přiřaďte vlastní definici.

Správným používáním slovníku Forthu ve skutečnosti neeliminujeme podmiňovací způsoby; pouze je z našeho aplikačního kódu vyřadíme. Forthovský slovník je obrovský řetězcový příkaz case. Funkce match a execute jsou skryty v systému Forth.

232 Minimalizace řídicích struktur

Moore: V mém účetním balíku, pokud od někoho obdržíte šek, zadáte částku, číslo šeku, slovo OD a jméno osoby: 200,00 127 OD VŠECHNY Slovo OD se o tuto situaci postará. Pokud chcete někomu vystavit fakturu, zadáte částku, číslo faktury, slovo BILL a jméno osoby: 1000,00 280 BILL TECHNITECH

. . . Pro každou situaci jedno slovo. Rozhoduje slovník. Toto pojetí prostupuje i samotný Forth. Pro sečtení dvojice čísel o jedné délce použijeme příkaz +. Pro sečtení dvojice čísel dvojí délky použijeme příkaz D+. Méně efektivním a složitějším přístupem by byl jediný příkaz, který by nějakým způsobem "věděl", jaký typ čísel se sčítá. Forth je efektivní, protože všechna tato slova - FROM a BILL a + a D+ - lze implementovat bez nutnosti testování a větvení. Tip Používejte hloupá slova.

8.2

Toto není rada pro televizní autory. Je to další případ používání slovníku. "Hloupé" slovo je takové, které není závislé na stavu, ale naopak má stále stejné chování ("referenčně transparentní"). Hloupé slovo je jednoznačné, a proto důvěryhodnější. Několik běžných slov jazyka Forth bylo v poslední době zdrojem sporů o tuto otázku. Jedním z takových slov je .", které vypisuje řetězec. Ve své nejjednodušší podobě je povoleno pouze uvnitř definice dvojtečky: : TEST

." TOTO JE ŘETĚZEC " ;

Ve skutečnosti tato verze slova nevytiskne řetězec. Sestaví řetězec spolu s adresou jiné definice, která provede tisk za běhu. Jedná se o hloupou verzi slova. Pokud ji použijete mimo definici s dvojtečkou, zbytečně zkompiluje řetězec, což vůbec není to, co by začátečník mohl očekávat. Aby se tento problém vyřešil, přidal model FIG test uvnitř .", který určuje, zda systém právě kompiluje, nebo interpretuje. V prvním případě by ." zkompilovalo řetězec a adresu primitivů, v druhém případě by jej TYPOVALO. ." se stalo dvěma zcela odlišnými slovy umístěnými společně v jedné definici se strukturou IF ELSE THEN. Příznak, který udává, zda má Forth

Používání slovníku 233

se kompiluje nebo interpretuje, se nazývá STATE. Protože ." závisí na STATE, říká se, že je doslova "závislý na STATE". Zdálo se, že příkaz se chová stejně uvnitř i vně definice dvojtečky. Tato duplicita se ukázala jako užitečná při odpoledním seznamování s jazykem Forth, ale seriózní student brzy zjistil, že jde o víc. Předpokládejme, že student chce napsat nové slovo s názvem B". (pro "bright-dotquote"), aby se na jejím displeji zobrazil řetězec v jasných znacích, který se bude používat takto: ." VLOŽIT DISK DO "

B." LEVÝ "

." DRIVE "

Mohla by očekávat, že definuje B." jako : B."

BRIGHT

."

NORMÁLNÍ ;

to znamená, že změní režim videa na jasný, vypíše řetězec a pak obnoví režim na normální. Vyzkouší to. Okamžitě je iluze zničena; podvod je odhalen; definice nebude fungovat. Aby programátorka vyřešila svůj problém, bude muset prostudovat definici (.") ve svém vlastním systému. Nehodlám se zde pouštět do vysvětlování, jak (.") funguje - jde mi o to, že chytrost není všechno, co se zdá být. Mimochodem, existuje i jiný syntaktický přístup k problému naší studentky, který nevyžaduje mít dvě samostatná slova ." a B." pro tisk řetězců. Změňte systémové (.") tak, aby po napsání vždy nastavilo režim na normální, i když většinu času již bude normální. S touto syntaxí stačí, aby programátor před zvýrazněný řetězec vložil jednoduché slovo BRIGHT. .". VLOŽIT DISK DO "

BRIGHT ." LEVÝ "

." DRIVE "

Norma '83 nyní uvádí němý ." a pro případy, kdy je požadována výkladová verze, bylo přidáno nové slovo .(. Naštěstí v této nové normě používáme k rozhodování slovník tak, že máme dvě samostatná slova. Podobnou historii má i slovo ' (zaškrtávací). Ve FigForthu bylo STATEčně závislé a v normě '83 je nyní němé. Tick má s dot-quote společnou vlastnost, že programátor může chtít znovu použít kterékoli z těchto slov v definici vyšší úrovně a nechat je chovat se stejně jako normálně. Tip 8.3

Slova by neměla záviset na STATE, pokud by je programátor někdy chtěl vyvolat z definice vyšší úrovně a očekávat, že se budou chovat stejně jako při interpretaci.

ASCII funguje dobře jako slovo závislé na STATE a stejně tak MAKE. (Viz dodatek C.)

234 Minimalizace řídicích struktur

Vnořování a kombinování podmínek Tip Netestujte něco, co již bylo vyloučeno.

8.4

Vezměte si prosím tento příklad: : PROCES-KLÍČ DUP LEVÁ ŠIPKA DUP PRAVÁ ŠIPKA DUP NAHORU-ŠIPKA DOLŮ-ŠIPKA

= = = =

IF IF IF IF

KURZOR-LEVÝ KURZOR-PRAVÝ KURZOR-NAHORU KURZOR-DOLŮ

PAK PAK PAK PAK ;

Tato verze je neefektivní, protože je nutné provést všechny čtyři testy bez ohledu na výsledek kteréhokoli z nich. Pokud byla stisknuta klávesa se šipkami vlevo, není třeba zjišťovat, zda to byla nějaká jiná klávesa. Místo toho můžete podmínky vnořit takto: : KLÁVESY DUP LEVÁ-ŠIPKA = DUP PRAVÁ-ŠIPKA = DUP ŠIPKA NAHORU = PAK THEN THEN THEN

IF KURZOR-LEVÁ ELSE IF KURZOR-PRAVÁ ELSE IF KURZOR-HORNÍ ELSE KURZOR-DOLNÍ DROP ;

Tip Kombinujte logické příkazy podobné váhy.

8.5

Mnoho případů dvojnásobně vnořených struktur IF THEN lze zjednodušit kombinací příznaků s logickými operátory před provedením rozhodnutí. Zde je dvojnásobně vnořený test: : ?PLAY SATURDAY? POKUD PRÁCE SKONČILA? IF GO PARTY THEN THEN ; Výše uvedený kód používá vnořené IF, aby se ujistil, že je sobota i že jsou práce hotové, než se spustí. Místo toho spojme podmínky logicky a udělejme jediné rozhodnutí: : ?PLAY SATURDAY? JDI SE BAVIT, PAK ;

PRÁCE UKONČENA? A

IF

Je to jednodušší a čitelnější. Logická situace "nebo", pokud je implementována pomocí IF THEN, je ještě neohrabanější:

Vnořování a kombinování podmínek 235

: ?RISE PHONE RINGS? IF UP GET THEN ALARM-CLOCK RINGS? IF UP GET THEN ; To je mnohem elegantněji zapsáno jako : ?RISE

PHONE RINGS?

ALARM RINGS? NEBO

IF

NAHORU VSTUPTE POTÉ ;

Výjimka z tohoto pravidla nastává v případě, kdy je postih za rychlost při kontrole některé z podmínek příliš velký. Můžeme napsat: ?CHOW-MEIN BEAN-SPROUTS? CHOW-MEIN RECEPT? CHOW-MEIN PŘIPRAVIT PAK ;

AND IF

Předpokládejme však, že nám bude trvat dlouho, než budeme lovit v našem souboru receptů, abychom zjistili, zda tam není něco o chow meinu. Je zřejmé, že nemá smysl se do hledání pouštět, pokud nemáme v lednici fazolové klíčky. Efektivnější by bylo napsat: ?CHOW-MEIN BEAN-SPROUTS? POKUD RECEPT NA CHOW-MEIN? IF CHOW-MEIN PREPARE THEN THEN ; Neobtěžujeme se s hledáním receptu, pokud nemáme klíčky. Další výjimka nastává, pokud některý výraz pravděpodobně není pravdivý. Tím, že takovou podmínku vyloučíme jako první, se vyhneme nutnosti zkoušet ostatní podmínky. Tip 8.6

Pokud má více podmínek nestejnou váhu (z hlediska pravděpodobnosti nebo času výpočtu), vnořte podmínky s podmínkou, která je nejméně pravděpodobná jako pravdivá nebo nejjednodušší na výpočet zvenčí.

Snaha o zlepšení výkonu tímto způsobem je obtížnější u konstrukce OR. Například v definici : ?RISE

TELEFON ZVONÍ?

ALARM ZVONÍ? NEBO

IF

NAHORU ZÍSKAT POTÉ ;

testujeme telefon a alarm, i když pro vstávání stačí, aby zazvonil jen jeden z nich. Nyní předpokládejme, že by bylo mnohem obtížnější určit, že zvoní budík. Mohli bychom napsat : ?RISE PHONE RINGS? KDYŽ VSTANU, JINAK ZVONÍ BUDÍK? IF UP GET THEN THEN

;

Pokud je první podmínka pravdivá, neztrácíme čas vyhodnocováním druhé podmínky. Stejně musíme vstát, abychom zvedli telefon. Opakování UP GET je ošklivé - není zdaleka tak čitelné jako řešení pomocí OR, ale v některých případech je žádoucí.

236 Minimalizace řídicích struktur

Výběr řídicích struktur Tip Nejelegantnější kód je ten, který nejvíce odpovídá zadání problému. Zvolte takovou řídicí strukturu, která nejvěrněji odpovídá problému toku řízení.

8.7

Případové věty Zvláštní třída problémů zahrnuje výběr jedné z několika možných cest provádění podle číselného argumentu. Například chceme, aby příkaz .SUIT vzal číslo představující barvu hracích karet 0 až 3 a zobrazil název této barvy. Toto slovo můžeme definovat pomocí vnořených IF ELSE THEN, například takto: : .SUIT ( suit -- ) DUP O= IF ." HEARTS " ELSE DUP 1 = IF ." PIKY " ELSE DUP 2 = IF ." KÁRA " ELSE ." KLUBY " KDYŽ TAK DROP ; Tento problém můžeme vyřešit elegantněji pomocí "příkazu případu". Zde je stejná definice, přepsaná pomocí formátu "Eaker case statement", pojmenovaného po Dr. Charlesi E. Eakerovi, pánovi, který jej navrhl [1]. : .SUIT ( suit -- ) CASE O OF ." SRDCE " 1 Z ." PIKY " 2 Z ." KÁRA " 3 Z ." KLUBY "

ENDOF ENDOF ENDOF ENDOF ENDOF

KONEC ;

Hodnota příkazu case spočívá výhradně v jeho čitelnosti a možnosti zápisu. Nedochází k žádnému zvýšení efektivity ani v objektové paměti, ani v rychlosti provádění. Ve skutečnosti se příkaz case kompiluje v podstatě stejně jako vnořené příkazy IF THEN. Příkaz case je dobrým příkladem faktorizace při kompilaci. Měly by všechny systémy Forth obsahovat takový příkaz case? To je předmětem sporů. Problém je dvojí. Zaprvé, případy, kdy je příkaz case skutečně potřeba, jsou dost vzácné - dost vzácné na to, aby se dalo pochybovat o jeho hodnotě. Pokud je případů jen několik, bude vnořená konstrukce IF ELSE THEN fungovat stejně dobře, i když možná ne tak čitelně. Pokud je případů mnoho, je rozhodovací tabulka flexibilnější.

Výběr řídicích struktur 237

Za druhé, mnoho problémů podobných případům není pro případovou strukturu zcela vhodných. Eakerův příkaz case předpokládá, že testujete rovnost proti číslu na zásobníku. V případě .SUIT máme k dispozici souvislá celá čísla od nuly do tří. Efektivnější je použít celé číslo k výpočtu offsetu a přímo přejít na správný kód. V případě našeho drobného editoru, který najdete dále v této kapitole, máme ne jednu, ale dvě dimenze možností. Příkaz case neodpovídá ani tomuto problému. Osobně považuji příkaz case za elegantní řešení chybného problému: pokus o algoritmické vyjádření toho, co je vhodněji popsáno v rozhodovací tabulce. Příkaz case by měl být součástí aplikace, pokud je užitečný, ale ne součástí systému. Smyčkové struktury Správná smyčková struktura může eliminovat dodatečné podmínky. Moore: Mnohokrát se podmíněné příkazy používají k tomu, aby se člověk dostal ze smyček. Tomuto konkrétnímu použití se lze vyhnout tím, že smyčky mají více výstupních bodů. To je živé téma kvůli vícenásobné konstrukci WHILE, která je v polyForthu, ale do Forthu '83 nepronikla. Je to jednoduchý způsob, jak definovat více WHILE v jednom REPEAT. Také Dean Sanderson [z Forth, Inc.] vymyslel novou konstrukci, která zavádí dva výstupní body do DO LOOP. Vzhledem k této konstrukci budete mít méně testů. Velmi často nechávám na zásobníku pravdivostní hodnotu, a pokud opouštím smyčku předčasně, změním pravdivostní hodnotu, abych si připomněl, že jsem smyčku opustil předčasně. Později pak budu mít IF, abych zjistil, zda jsem smyčku opustil dříve, a to je prostě nešikovné. Jakmile jednou uděláte rozhodnutí, neměli byste ho dělat znovu. Se správnými konstrukcemi smyček si nebudete muset pamatovat, odkud jste vyšli, takže další podmíněné příkazy půjdou stranou. To není úplně populární, protože je to poměrně nestrukturované. Nebo je možná složitě strukturovaná. Hodnota je v tom, že získáte jednodušší programy. A nic to nestojí.

Skutečně je to živé téma. V době psaní tohoto článku je příliš brzy na to, abychom podávali nějaké konkrétní návrhy na nové konstrukce smyček. Podívejte se do dokumentace svého systému, co nabízí za exotické smyčkové konstrukce. Nebo, v závislosti na potřebách vaší aplikace, zvažte přidání vlastních podmíněných konstrukcí. Ve Forthu to není tak těžké. Nejsem si ani jistý, zda toto použití vícenásobných výstupů neporušuje doktrínu strukturovaného programování. Ve smyčce BEGIN WHILE REPEAT s více WHILE vás všechny výstupy přivedou do společného bodu "pokračování": REPEAT.

238 Minimalizace řídicích struktur

V případě Sandersonovy konstrukce však můžete smyčku opustit skokem za její konec a pokračovat v bodě ELSE. Existují dva možné body "pokračování". To je "méně strukturované", pokud to tak můžeme říci. A přesto definice vždy skončí na svém středníku a vrátí se ke slovu, které ji vyvolalo. V tomto smyslu je dobře strukturovaná; modul má jeden vstupní a jeden výstupní bod. Pokud chcete provést speciální kód pouze v případě, že jste smyčku neopustili předčasně, zdá se tento přístup jako nejpřirozenější struktura. (Příklad si ukážeme v pozdější části "Použití strukturovaných výstupů".) Tip Dávejte přednost počtům před terminátory.

8.8

Forth zpracovává řetězce tak, že délku řetězce uloží do prvního bajtu. To usnadňuje psaní, přesouvání nebo prakticky jakoukoli činnost s řetězcem. S adresou a počtem na zásobníku lze zakódovat definici TYPE: : TYPE

( a #)

OVER + SWAP DO

I C@ EMIT

LOOP ;

(Ačkoli TYPE by měl být skutečně zapsán ve strojovém kódu.) Tato definice nepoužívá žádnou zjevnou podmínku. LOOP vlastně podmínku skrývá, protože každá smyčka kontroluje index a vrací se do DO, pokud ještě nedosáhla limitu. Pokud by byl použit oddělovač, řekněme ASCII null (nula), musela by být definice zapsána: : TYPE ( a) BEGIN DUP C@ REPEAT DROP ;

?DUP WHILE

EMIT

1+

Při každém průchodu smyčkou je třeba provést další test. (WHILE je podmíněný operátor.) Poznámka k optimalizaci: Použití ?DUP v tomto řešení je časově nákladné, protože samo o sobě obsahuje další rozhodnutí. Rychlejší definice by byla: : TYPE ( a) BEGIN DUP C@ REPEAT 2DROP ;

DUP WHILE EMIT 1+

Norma '83 použila tento princip pro INTERPRET, který nyní akceptuje počet, místo aby hledal terminátor. Odvrácenou stranou této mince jsou některé datové struktury, ve kterých je nejjednodušší propojit struktury dohromady. Každý záznam ukazuje na další (nebo předchozí) záznam. Poslední (nebo první) záznam v řetězci lze označit nulou v jeho odkazovém poli. Pokud máte odkazové pole, musíte ho stejně načíst. Stejně tak můžete testovat, zda je v něm nula. Nemusíte si vést počítadlo, kolik záznamů existuje.

Výběr řídicích struktur 239

Pokud dekrementujete čítač, abyste se rozhodli, zda ukončit, přiděláváte si práci. (Tato technika se používá při implementaci slovníku jazyka Forth jako spojového seznamu.) Výpočet výsledků Tip 8.9

Nerozhodujte se, ale počítejte.

Mnohokrát se podmíněné řídicí struktury chybně aplikují na situace, kdy rozdíl ve výsledku vyplývá z rozdílu čísel. Pokud se jedná o čísla, můžeme je vypočítat. (Ve čtvrté kapitole viz oddíl "Výpočty vs. datové struktury vs. logika"). Tip 8.10

Jako hybridní hodnoty používejte booleany.

Toto je fascinující důsledek předchozího tipu "Nerozhodujte, ale počítejte". Myšlenka spočívá v tom, že booleany, které počítač reprezentuje jako čísla, lze efektivně použít k číselným rozhodnutím. Zde je jeden příklad, který se vyskytuje v mnoha systémech Forth: : S>D ( n -- d) \ znaménko rozšířit s na d DUP O< IF -1 ELSE O THEN ; (Účelem této definice je převést číslo o jedné délce na číslo o dvojnásobné délce. Dvojnásobně dlouhé číslo je reprezentováno jako dvě 16bitové hodnoty na zásobníku, část vyššího řádu nahoře. Převod kladného celého čísla na dvojnásobnou délku znamená pouze přidání nuly na zásobník, která bude reprezentovat jeho část vyššího řádu. Převod záporného celého čísla na dvojnásobnou délku však vyžaduje "rozšíření znaménka", to znamená, že část vyššího řádu by měla být samé jedničky.) Výše uvedená definice testuje, zda je číslo o jedné délce záporné. Pokud ano, vloží na zásobník zápornou jedničku, jinak nulu. Všimněte si však, že výsledkem je pouhá aritmetika; nedochází k žádné změně procesu. Tuto skutečnost můžeme využít tak, že použijeme samotný boolean: : S>D ( n -- d) DUP O< ;

\ znaménko rozšíří s na d

V této verzi se na zásobník bez (ne)rozhodování strčí nula nebo záporná jednička. (V systémech před rokem 1983 by definice zněla: : S>D ( n -- d) \ sign extend s to d DUP O< NEGATE ; Viz příloha C.)

240 Minimalizace řídicích struktur

S "hybridními hodnotami" toho můžeme udělat ještě více: Tip Chcete-li provést rozhodnutí s číselným výsledkem, použijte AND.

8.11

V případě rozhodnutí, jehož výsledkem je buď nula, nebo nenulové "n", se používá tradiční věta ( ? ) IF.

n

ELSE

O

THEN

je ekvivalentní jednoduššímu výroku ( ? )

n AND

Tajemství opět spočívá v tom, že v systémech Forth z roku '83 je "true" reprezentováno hodnotou -1 (všechny jedničky). Při AND "n" s příznakem se získá buď "n" (všechny bity nedotčené), nebo "0" (všechny bity vymazané). Zopakujme si to na příkladu: ( ? )

IF

200

ELSE

O

POTÉ

je stejný jako ( ? )

200 AND

Podívejte se na tento příklad: n

a b <

IF

45 +

POTÉ

Tato věta buď přičte 45 k "n", nebo nepřičte, v závislosti na relativní velikosti "a" a "b". Protože "přidat 45 nebo nepřidat" je totéž jako "přidat 45 nebo přidat 0", rozdíl mezi oběma výsledky je čistě číselný. Můžeme se zbavit rozhodování a jednoduše spočítat: n

a b <

45 AND

+

Moore: Postup "45 AND" je rychlejší než IF a rozhodně elegantnější. Je jednodušší. Pokud si vytvoříte zvyk hledat případy, kdy počítáte tuto hodnotu z této hodnoty, pak většinou aritmetickým výpočtem na logice získáte stejný výsledek čistěji. Nevím, jak se tomu říká. Nemá to žádnou terminologii, je to jen provádění aritmetiky s pravdivostními hodnotami. Ale je to naprosto správné a jednou se tomu přizpůsobí i booleovská algebra a aritmetické výrazy. V knihách se často setkáte se spoustou kusých lineárních aproximací, které nedokážou věci jasně vyjádřit. Například výraz

Výběr řídicích struktur 241

x = O pro t < O x = 1 pro t ≥ O To by bylo ekvivalentní t

O<

1 A

jako jediný výraz, nikoliv jako výraz po částech.

Těmto příznakům říkám "hybridní hodnoty", protože se jedná o booleany (pravdivostní hodnoty), které jsou aplikovány jako data (číselné hodnoty). Také nevím, jak jinak je nazvat. Numerické klauzule ELSE (kde jsou oba výsledky nenulové) můžeme eliminovat také tak, že rozdíl mezi oběma výsledky vynásobíme. Například : STEPPERS 'TESTING? @

IF 150 ELSE 151

THEN

LOAD ;

lze zjednodušit na : STEPPERS

150

'TESTOVÁNÍ? @

1 AND +

LOAD ;

Tento přístup zde funguje, protože koncepčně chceme načíst buď obrazovku 150, nebo, pokud se jedná o testování, další obrazovku za ní.

Poznámka k trikům Tento druh přístupu se často označuje jako "trik". V počítačovém průmyslu mají triky obecně špatnou pověst. Trik je jednoduše využití určitých vlastností operace. Triky se hojně používají v technických aplikacích. Komíny odstraňují kouř tím, že využívají skutečnosti, že teplo stoupá vzhůru. Automobilové pneumatiky zajišťují trakci využitím gravitace. Aritmeticko-logické jednotky (ALU) využívají toho, že odečítání čísla je stejné jako sčítání jeho dvojkového doplňku. Tyto triky umožňují jednodušší a efektivnější návrhy. Jejich použití ospravedlňuje to, že předpoklady určitě zůstanou pravdivé. Použití triků se stává nebezpečným, pokud trik závisí na něčem, co se pravděpodobně změní, nebo pokud věc, na které závisí, není chráněna skrytím informace. Triky se také stávají obtížně čitelnými, když předpoklady, na nichž jsou založeny, nejsou pochopeny nebo vysvětleny. V případě nahrazení podmíněk pomocí AND, jakmile se tato technika stane součástí slovníku každého programátora, může se kód stát čitelnějším. V případě triku, který je specifický pro konkrétní aplikaci, například pořadí, v jakém jsou data uspořádána v tabulce, musí výpis jasně dokumentovat předpoklad, který tento trik používá. Tip 8.12

Pro ořezávání použijte MIN a MAX.

242 Minimalizace řídicích struktur

Předpokládejme, že chceme dekrementovat obsah proměnné VALUE, ale nechceme, aby hodnota klesla pod nulu: -1 VALUE +!

VALUE @

-1 = IF

O VALUE !

THEN

Jednodušeji se zapíše: VALUE @

1-

O MAX

VALUE !

V tomto případě je podmínka zformulována v rámci slova MAX.

Použití rozhodovacích tabulek Tip Použití rozhodovacích tabulek.

8.13

Ty jsme si představili ve druhé kapitole. Rozhodovací tabulka je struktura, která obsahuje buď data ("datová tabulka"), nebo adresy funkcí ("tabulka funkcí") uspořádané podle libovolného počtu dimenzí. Každá dimenze představuje všechny možné, vzájemně se vylučující stavy určitého aspektu problému. V průsečíku "pravých" stavů každé dimenze leží požadovaný prvek: část dat nebo funkce, kterou je třeba provést. Rozhodovací tabulka je jednoznačně lepší volbou než podmíněná struktura, pokud má problém více dimenzí. Jednorozměrná datová tabulka Zde je příklad jednoduché jednorozměrné datové tabulky. Naše aplikace má příznak nazvaný "FREEWAY?", který je pravdivý, když se jedná o dálnice, a nepravdivý, když se jedná o městské ulice. Zkonstruujme slovo SPEED-LIMIT, které vrací rychlostní limit v závislosti na aktuálním stavu. Pomocí IF THEN bychom napsali: : SPEED-LIMIT ( -- speed-limit) 'FREEWAY? @ IF 55 ELSE 25

THEN ;

IF THEN bychom mohli eliminovat použitím hybridní hodnoty s AND: : SPEED-LIMIT

25

'FREEWAY? @

30 AND + ;

Tento přístup však neodpovídá našemu koncepčnímu modelu problému, a proto není příliš čitelný. Zkusme datovou tabulku. Jedná se o jednorozměrnou tabulku s pouhými dvěma prvky, takže toho v ní není mnoho: VYTVOŘIT LIMITS

25 ,

55 ,

Použití rozhodovacích tabulek 243

Slovo SPEED-LIMIT? nyní musí použít boolean pro odsazení do datové tabulky: : SPEED-LIMIT ( -- speed-limit) LIMITS 'FREEWAY? @ 2 AND +

@ ;

Získali jsme něco oproti přístupu IF THEN? U tak jednoduchého problému pravděpodobně ne. Co jsme však dokázali, je vyjmout rozhodovací proces ze samotných dat. To se stává nákladově efektivnější, když máme více než jednu sadu dat vztahujících se ke stejnému rozhodnutí. Předpokládejme, že bychom měli také CREATE #LANES

4 ,

10 ,

představující počet jízdních pruhů na městské ulici a na dálnici. K výpočtu aktuálního počtu jízdních pruhů můžeme použít totožný kód: : #LANES? ( -- #lanes) #LANES 'FREEWAY? @

2 AND

+

@ ;

Použitím technik faktoringu to zjednodušíme na: : ROAD ( for-freeway for-city ) CREATE , , DOES> ( -- data ) 'FREEWAY? @ 2 AND + 55 25 ROAD SPEED-LIMIT? 10 4 ROAD #LANES?

@ ;

Dalším příkladem jednorozměrné datové tabulky je "superřetězec" (Začínáme Forth, kapitola deset). Dvourozměrná datová tabulka Ve druhé kapitole jsme představili problém s rychlostí telefonování. Na obrázku 8.4 je uvedeno jedno z řešení tohoto problému pomocí dvourozměrné datové struktury. V tomto problému se každá dimenze datové tabulky skládá ze tří vzájemně se vylučujících stavů. Proto je jednoduchá logická hodnota (pravda/nepravda) nedostatečná. Každá dimenze tohoto problému je realizována jiným způsobem. Aktuální sazba, která závisí na denní době, je uložena jako adresa, která představuje jednu ze tří dílčích tabulek struktury sazeb. Můžeme říci PLNÁ SÁZBA ! nebo NÍZKÁ SÁZBA ! atd.

244 Minimalizace řídicích struktur

0 1 2 3 4 5 6 7 8 9 10 11

0 1 2 3 4 5 6 7 8 9

Obrázek 8.4: Řešení problému telefonní sazby. Obrazovka č. 103 \ Telefonní sazby CREATE FULL 30 , 20 , 12 , CREATE LOWER 22 , 15 , 10 , CREATE LOWEST 12 , 9 , 6 , VARIABLE RATE \ ukazuje na FULL, LOWER nebo LOWEST \ v závislosti na denní době FULL RATE ! \ například : CHARGE ( o -- ) CREATE , DOES> ( -- rate ) @ RATE @ + @ ; O CHARGE 1MINUTE \ sazba za první minutu 2 CHARGE +MINUTES \ sazba za každou další minutu 4 CHARGE /MILES \ sazba za každých 100 mil.

03/30/84

Okénko č. 104 \ Telefonní sazby 03/30/84 VARIABILNÍ OPERÁTOR? \ 90 pokud asistuje operátor; jinak O VARIABLE #MILES \ stovky mil : ?ASISTENCE ( poplatek za přímou volbu -- celkový poplatek) OPERÁTOR? @ + ; : MILEAGE ( -- poplatek ) #MILES @ /MILES * ; : FIRST ( -- poplatek ) 1MINUTE ?ASSISTANCE MILEAGE + ; : ADDITIONAL ( -- poplatek) +MINUTES MILEAGE + ; : TOTAL ( #minut -- celkový poplatek) 1- ADDITIONAL * FIRST + ;

Aktuální poplatek, buď za první minutu, za další minutu nebo za kilometr, je vyjádřen jako posun do tabulky (0, 2 nebo 4). Poznámka k optimalizaci: dvourozměrnou tabulku jsme implementovali jako sadu tří jednorozměrných tabulek, z nichž na každou ukazuje RATE. Tento přístup eliminuje potřebu násobení, které by jinak bylo nutné k implementaci dvourozměrné struktury. Násobení může být v některých případech neúměrně pomalé. Dvourozměrná rozhodovací tabulka Pro ilustraci dvourozměrné rozhodovací tabulky se vrátíme k našemu příkladu Tiny Editor ve třetí kapitole. Na obrázku 8.5 konstruujeme tabulku funkcí, které se mají provést po stisknutí různých kláves. Efekt je podobný jako u příkazu case, ale jsou zde dva režimy, Normální režim a Vložený režim. Každá klávesa má jiné chování v závislosti na aktuálním režimu. První obrazovka implementuje změnu režimů. Pokud vyvoláme NORMÁLNÍ REŽIM# ! přejdeme do normálního režimu.

Použití rozhodovacích tabulek 245

INSERTING MODE# ! přejde do režimu vkládání. Další obrazovka konstruuje tabulku funkcí nazvanou FUNCTIONS. Tabulka se skládá z ASCII hodnoty klávesy, za níž následuje adresa rutiny, která se provede v Normálním režimu, a za ní adresa rutiny, která se provede ve Vkládacím režimu při stisknutí dané klávesy. Pak následuje druhá klávesa, za ní další dvojice adres atd. Na třetí obrazovce slovo "FUNCTION" přijme hodnotu klíče, vyhledá v tabulce FUNCTIONS shodu a poté vrátí adresu buňky obsahující shodu. (Proměnnou MATCHED jsme přednastavili tak, aby ukazovala na poslední řádek tabulky - funkce, které chceme při stisknutí libovolného znaku.) Slovo ACTION vyvolá 'FUNCTION a přidá obsah proměnné MODE#. Protože MODE# bude obsahovat buď 2, nebo 4, přidáním tohoto offsetu nyní ukazujeme do tabulky na adresu rutiny, kterou chceme provést. Jednoduchým příkazem @ EXECUTE provedeme danou rutinu (nebo @EXECUTE, pokud ji máte k dispozici). Ve Fig-Forthu změňte definici IS na: : IS

[COMPILE] '

CFA , ;

V 79-Standard Forths použijte: : IS

[COMPILE] '

, ;

Neredundanci jsme použili také při kompilaci v definici hned pod tabulkou funkcí: ZDE /KEY -

KONSTANTA 'NOMATCH

\

adr klíče no-match

Z posledního řádku tabulky funkcí vytvoříme konstantu. (V okamžiku, kdy voláme HERE, ukazuje na další volnou buňku po vyplnění poslední položky tabulky. Šest bajtů zpět je poslední řádek.) Nyní máme dvě slova: FUNCTIONS ( adr začátku tabulky funkcí ) 'NOMATCH ( adr řádku "no-match"; to jsou rutiny pro jakýkoli klíč, který není v tabulce) Tato jména použijeme k dodání adres předávaných DO: 'NOMATCH FUNCTION DO k nastavení smyčky, která běží od prvního řádku tabulky k poslednímu. Nemusíme vědět, kolik řádků v tabulce leží. Mohli bychom dokonce smazat řádek nebo

246 Minimalizace řídicích struktur

0 1 2 3 4 5 6 7

Obrázek 8.5: Implementace drobného editoru. Obrazovka č. 30 \ Tiny Editor 2 KONSTANT NORMAL \ offset ve FUNKCÍCH 4 KONSTANT INSERTING \ " 6 KONSTANT /KEY \ bajty v tabulce pro každý klíč VARIABILNÍ MODE# \ aktuální offset do tabulky NORMAL MODE# ! : INSERT-OFF NORMÁLNÍ REŽIM# ! ; : INSERT-ON VKLÁDACÍ REŽIM# ! ;

8 9 10

PROMĚNNÁ ESCAPE? \ t=time-to-leave-loop : ESCAPE TRUE ESCAPE? ! ;

11 12 13 14 15

0 1 2 3 4 5 6 7 8 9 10 11

Okénko č. 31 \ Tiny Editor tabulka funkcí 07/29/83 : IS ' , ; \ funkce ( -- ) ( pro '83 standard) CREATE FUNCTIONS \ klávesy normální režim režim vkládání 4 , ( ctrl-D) IS DELETE IS INSERT-OFF 9 , ( ctrl-I) IS INSERT-ON IS INSERT-OFF 8 , ( backspace) IS BACKWARD IS INSERT< 60 , ( šipka vlevo) IS BACKWARD IS INSERT-OFF 62 , ( šipka vpravo) IS FORWARD IS INSERT-OFF 27 , ( return) IS ESCAPE IS INSERT-OFF O , ( bez shody) IS OVERWRITE IS INSERT HERE /KEY - CONSTANT 'NOMATCH \ adr klávesy bez shody

12 13 14 15

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15

Okénko # 32 \ Tiny Editor pokračování 29.7.1983 VARIABLE MATCHED : 'FUNCTION ( key -- adr-of-match ) 'NOMATCH MATCHED ! 'NOMATCH FUNCTIONS DO DUP I @ = IF I MATCHED ! LEAVE THEN /KEY +LOOP DROP MATCHED @ ; : ACTION ( key -- ) 'FUNCTION MODE# @ + @ EXECUTE ; : GO FALSE ESCAPE? ! BEGIN KEY ACTION ESCAPE? @ UNTIL ;

přidá řádek do tabulky, aniž by musel měnit jakoukoli jinou část kódu, dokonce i kód, který prohledává tabulku. Podobně konstanta /KEY skrývá informaci o počtu sloupců v tabulce. Mimochodem, přístup k 'FUNCTION použitý ve výpisu je rychlý a špinavý; používá lokální proměnnou pro zjednodušení manipulace se zásobníkem. Jednodušší řešení, které nepoužívá žádnou lokální proměnnou, je: : 'FUNCTION ( key -- adr of match ) 'NOMATCH SWAP 'NOMATCH FUNCTIONS DO I @ = IF SWAP DROP I SWAP LEAVE /KEY +LOOP DROP ;

DUP THEN

(Další řešení nabídneme později v této kapitole v části "Použití strukturovaných výstupů").

Rozhodovací tabulky pro rychlost Uvedli jsme, že pokud můžete hodnotu vypočítat, místo abyste ji hledali v tabulce, měli byste tak učinit. Výjimkou jsou případy, kdy požadavky na rychlost ospravedlňují dodatečnou složitost tabulky. Zde je příklad, který počítá mocniny dvou s 8bitovou přesností: TWOS 1 C, 2 C, 4 C, 8 C, 16 C, : 2** ( n -- 2-do-n) TWOS + C@ ;

32 C,

Namísto výpočtu odpovědi vynásobením dvojnásobku sebe sama "n" krát jsou všechny odpovědi předpočítány a umístěny do tabulky. Pomocí jednoduchého sčítání můžeme do tabulky odsadit a získat odpověď. Obecně je sčítání mnohem rychlejší než násobení.

Moore uvádí další příklad: Pokud chcete počítat trigonometrické funkce, například pro grafické zobrazení, nepotřebujete velké rozlišení. Sedmibitová trigonometrická funkce pravděpodobně postačí. Vyhledávání v tabulce 128 čísel je rychlejší než cokoli jiného, co budete schopni udělat. Pro výpočty funkcí s nízkou frekvencí jsou skvělé rozhodovací tabulky. Pokud ale musíte interpolovat, musíte funkci spočítat tak jako tak. Pravděpodobně je lepší spočítat trochu složitější funkci a vyhnout se vyhledávání v tabulce.

248 Minimalizace řídicích struktur

Redesigning Tip Jedna změna dole může ušetřit deset rozhodnutí nahoře.

8.14

V rozhovoru s Moorem na začátku kapitoly se zmínil, že by se z aplikace dalo odstranit mnoho podmíněných testů, kdyby se přepracovala tak, aby v ní byla dvě slova místo jednoho: "Buď řekneš GO, nebo PRETEND." V tomto případě by se jednalo o dvě slova. Je jednodušší provádět jednoduchý, konzistentní algoritmus a zároveň měnit kontext prostředí než vybírat z několika algoritmů při zachování pevného prostředí. Vzpomeňte si na náš příklad z první kapitoly se slovem APPLES. To bylo původně definováno jako proměnná; v průběhu aplikace se na něj mnohokrát odkazovalo slovy, která inkrementovala počet jablek (při příchodu zásilek), dekrementovala počet (při prodeji jablek) a kontrolovala aktuální počet (pro kontrolu zásob). Když bylo nutné zpracovávat druhý typ jablek, bylo by nesprávným přístupem přidat tuto složitost ke všem slovům zásilky/prodej/inventura. Správný přístup byl ten, který jsme zvolili my: přidat složitost "dole", tedy k samotnému slovu APPLES. Tento princip lze realizovat mnoha způsoby. V sedmé kapitole (v části "Stavová tabulka") jsme použili stavové tabulky k realizaci slov PRACOVNÍ a PŘÍPRAVNÝ, která změnila význam skupiny proměnných. Později v téže kapitole jsme použili vektorové provádění k definici slov VISIBLE a INVISIBLE, ke změně významu slov TYPE', EMIT', SPACES' a CR' a tím ke snadné změně celého formátovacího kódu, který je používá. Tip Netestujte něco, co se nemůže stát.

8.15

Mnozí současní programátoři si potrpí na kontrolu chyb. Není třeba, aby funkce kontrolovala argument předaný jinou komponentou systému. Volající program by měl nést odpovědnost za to, že nepřekročí limity volané komponenty. Tip Přezkoumejte algoritmus.

8.16

Moore: V případě, že se jedná o funkci, která je v rozporu se zákonem, je nutné, aby se na ni vztahoval zákon:

Přepracování 249

Spousta podmínek vzniká z nejasného uvažování o problému. V teorii servořízení si mnoho lidí myslí, že algoritmus pro servo by měl být jiný, když je vzdálenost velká, než když je blízká. Ve velké vzdálenosti jste v režimu otáčení, blíže k cíli jste v režimu zpomalování, velmi blízko jste v režimu lovu. Musíte vyzkoušet, jak daleko jste, abyste věděli, který algoritmus použít. Vypracoval jsem nelineární algoritmus servořízení, který zvládne celý rozsah. Tento přístup eliminuje závady v bodech přechodu mezi jedním a druhým režimem. Odstraňuje logiku nutnou k rozhodnutí, který algoritmus použít. Eliminuje nutnost empiricky určovat body přechodu. A samozřejmě máte mnohem jednodušší program s jedním algoritmem místo tří. Místo toho, abyste se snažili zbavit se podmíněk, uděláte nejlépe, když zpochybníte základní teorii, která vedla ke vzniku podmínek.

Tip 8.17

Vyhněte se nutnosti speciální manipulace.

Jeden příklad jsme zmínili již dříve v knize: pokud udržíte uživatele mimo potíže, nebudete muset neustále testovat, zda se uživatel dostal do potíží. Moore: Dalším dobrým příkladem je psaní assemblerů. Velmi často se stává, že i když opkód nemusí mít přiřazený registr, předstírání, že má registr - řekněme registr 0 - může kód zjednodušit. Provádění aritmetiky zavedením bitových vzorů, které nemusí existovat, zjednodušuje řešení. Stačí nahradit nuly a pokračovat v aritmetice, které jste se mohli vyhnout tím, že byste testovali, zda je nula, a neprováděli ji. Je to další příklad "nestarej se". Pokud je vám to jedno, dejte jí fiktivní hodnotu a stejně ji použijte.

Kdykoli narazíte na speciální případ, pokuste se najít algoritmus, pro který se speciální případ stane normálním případem. Tip 8.18

Používejte vlastnosti komponenty.

Dobře navržená komponenta - hardwarová nebo softwarová - vám umožní implementovat odpovídající lexikon čistým a efektivním způsobem. Dobře to ilustruje grafická sada znaků ze staré tiskárny Epson MX-80 (ačkoli je dnes již zastaralá). Obrázek 8.6 ukazuje grafické znaky vytvořené kódy ASCII 160 až 223.

250 Minimalizace řídicích struktur

Obrázek 8.6: Grafická znaková sada tiskárny Epson MX-80.

Každý grafický znak je jinou kombinací šesti malých políček, která jsou buď vyplněna, nebo ponechána prázdná. Předpokládejme, že v naší aplikaci chceme tyto znaky použít k vytvoření návrhu. Pro každý znak víme, co chceme na každé ze šesti pozic - musíme vytvořit příslušný znak ASCII pro tiskárnu. Při troše hledání zjistíte, že jde o velmi rozumný vzorec. Předpokládejme, že máme šestibajtovou tabulku, v níž každý bajt představuje pixel vzoru: PIXELY

0 2 4

1 3 5

a za předpokladu, že každý bajt obsahuje hexadecimální FF, pokud je pixel "zapnutý"; nulu, pokud je "vypnutý", pak zde vidíme, jak málo kódu je potřeba k výpočtu znaku: PIXELY 6 ALLOT : PIXEL ( i -- a ) PIXELS + ; : CHARACTER ( -- grafický znak) 160 6 O DO I PIXEL C@ I 2** AND

+

LOOP ;

(Před několika tipy jsme si představili 2**.) Při definici CHARACTERU není třeba rozhodovat. Grafický znak se jednoduše vypočítá. Poznámka: chceme-li použít stejný algoritmus pro překlad sady šesti sousedících pixelů ve velké mřížce, můžeme pouze předefinovat PIXEL. To je příklad zpětného přidání indirekce a dobrého rozkladu. Bohužel vnější komponenty nejsou vždy dobře navrženy. Například The IBM Personal Computer používá podobné schéma pro grafické znaky na svém videodisplejích, ale bez zřetelné korespondence mezi

Přepracování 251

hodnotami ASCII a vzorem pixelů. Jediným způsobem, jak vytvořit hodnotu ASCII, je porovnání vzorů ve vyhledávací tabulce. Moore: Asembler 68000 je dalším příkladem, nad kterým si můžete zlomit srdce, když hledáte dobrý způsob, jak vyjádřit tyto op-kódy s minimálním počtem operátorů. Vše nasvědčuje tomu, že žádné dobré řešení neexistuje. Lidé, kteří navrhovali 68000, neměli assemblery na mysli. A mohli to udělat mnohem jednodušeji, aniž by je to něco stálo.

Tím, že takto používáte vlastnosti komponenty, se váš kód stává závislým na těchto vlastnostech, a tedy i na komponentě samotné. To je však omluvitelné, protože veškerý závislý kód je omezen na jediný lexikon, který lze v případě potřeby snadno změnit.

Použití strukturovaných výstupů Tip 8.19

Používejte strukturovaný exit.

V kapitole o faktorizaci jsme si ukázali možnost faktorizace řídicí struktury pomocí této techniky: : PODMÍNĚNĚ A B NEBO C A POKUD NE R> DROP : AKTIVNĚ PODMÍNĚNĚ TUMBLE JUGGLE JUMP ; : LÍNĚ PODMÍNĚNĚ SIT EAT SLEEP ;

POTÉ ;

Forth nám umožňuje měnit tok řízení přímou manipulací s návratovým zásobníkem. (Pokud máte pochybnosti, podívejte se do kapitoly Starting Forth, kapitola devět.) Nerozvážné použití tohoto triku může vést k nestrukturovanému kódu s nepříjemnými vedlejšími efekty. Disciplinované používání strukturovaného výstupu však může ve skutečnosti kód zjednodušit, a tím zlepšit jeho čitelnost a udržovatelnost. Moore: Stále více dávám přednost R> DROP pro změnu toku řízení. Je to podobné efektu ABORT", který má v sobě zabudované IF THEN. Ale to je jen jedno IF THEN v systému, ne při každé chybě. Buď přeruším, nebo nepřeruším. Pokud nepřeruším, pokračuji dál. Pokud přeruším, nemusím si cestu proklestit. Celou věc zkrátím. Alternativou je zatěžovat zbytek aplikace kontrolou, zda došlo k chybě. To je nepříjemné.

252 Minimalizace řídicích struktur

"Cesta přerušení" obchází běžné cesty toku řízení za zvláštních podmínek. Forth tuto možnost poskytuje pomocí slov ABORT" a QUIT. "Strukturované ukončení" rozšiřuje tento koncept tím, že umožňuje okamžité ukončení jediného slova, aniž by došlo k ukončení celé aplikace. Tato technika by neměla být zaměňována s použitím GOTO, které je extrémně nestrukturované. Pomocí GOTO můžete přejít kamkoli, uvnitř nebo vně aktuálního modulu. Pomocí této techniky efektivně skočíte přímo do konečného bodu ukončení modulu (středník) a pokračujete ve vykonávání volajícího slova. Slovo EXIT ukončuje definici, ve které se vyskytuje. Výraz R> DROP ukončuje definici, která volala definici, v níž se výraz objevuje; má tedy stejný účinek, ale lze jej použít o úroveň níže. Zde je několik příkladů obou přístupů. Pokud máte frázi IF ELSE THEN, ve které za THEN nenásleduje žádný kód, jako například tato: ... Hlad?

IF

EAT-IT

ELSE

FREEZE-IT

THEN ;

ELSE můžete eliminovat pomocí EXIT: ... HUNGRY?

IF EAT-IT EXIT

THEN

FREEZE-IT ;

(Pokud je podmínka pravdivá, jíme a běžíme; EXIT funguje jako středník. Pokud je podmínka nepravdivá, přeskočíme na THEN a FREEZE-IT.) Použití EXIT je zde efektivnější, ušetří dva bajty a další kód k provedení, ale není tak čitelné. Moore komentuje hodnotu a nebezpečí této techniky: Zejména pokud jsou vaše podmínky stále propracovanější, je vhodné vyskočit uprostřed, aniž byste museli na konci porovnávat všechny THEN. V jedné aplikaci jsem měl slovo, které vypadalo takto: : TESTOVÁNÍ JEDNODUCHÉ

1PODMÍNKA IF ... EXIT THEN 2PODMÍNKA IF ... EXIT THEN 3PODMÍNKA IF ... EXIT THEN ;

SIMPLE zpracovává jednoduché případy. SIMPLE skončil s R> DROP. Tyto další podmínky byly ty složitější. Všichni skončili ve stejném bodě, aniž by museli bolestně porovnávat všechny IF, ELSE a THEN. Konečným výsledkem, pokud se žádná z podmínek neshodovala, byla chybová podmínka. Byl to špatný kód, který se obtížně ladil. Ale odrážel podstatu problému. Neexistovalo žádné lepší schéma, jak ho řešit. EXIT a R> DROP alespoň udržovaly věci zvládnutelné.

Použití strukturovaných exitů 253

Programátoři někdy používají EXIT také k tomu, aby se elegantním způsobem dostali ze složité smyčky BEGIN. Nebo můžeme použít příbuznou techniku v cyklu DO LOOP, který jsme napsali pro 'FUNCTION v našem drobném editoru dříve v této kapitole. V tomto slově prohledáváme řadu míst a hledáme shodu. Pokud nalezneme shodu, chceme vrátit adresu místa, kde jsme ji našli; pokud shodu nenalezneme, chceme adresu posledního řádku tabulky funkcí. Můžeme zavést slovo LEAP (viz příloha C), které bude fungovat stejně jako EXIT (bude simulovat středník). Nyní můžeme napsat: : 'FUNCTION ( key -- adr-of-match ) 'NOMATCH FUNCTIONS DO DUP I @ = IF THEN /KEY +LOOP DROP 'NOMATCH ;

DROP I LEAP

Pokud nalezneme shodu, provedeme LEAP, nikoliv do +LOOP, ale přímo z definice, přičemž I (adresa, na které jsme ji nalezli) zůstane na zásobníku. Pokud shodu nenajdeme, propadneme smyčkou a provedeme DROP

'NOMATCH

která zahodí hledaný klíč# a ponechá adresu posledního řádku! Jak jsme viděli, mohou nastat situace, kdy je vhodné předčasné ukončení, a to i v případě více bodů ukončení a více bodů "pokračování". Pamatujte však, že toto použití EXIT a R> DROP neodpovídá strukturovanému programování v tom nejpřísnějším slova smyslu a vyžaduje velkou opatrnost. Například na začátku definice můžete mít na zásobníku hodnotu, která je na konci spotřebována. Předčasný EXIT ponechá na zásobníku nechtěnou hodnotu. Hrát si s návratovým zásobníkem je jako hrát si s ohněm. Můžete se spálit. Ale jak je výhodné mít oheň.

Nasazení správného načasování Tip 8.20

Proveďte akci, když víte, že ji potřebujete, ne později.

Pokaždé, když nastavujete příznak, zeptejte se sami sebe, proč ho nastavujete. Pokud odpověď zní: "Abych věděl, že mám později udělat to a to," pak se zeptejte sami sebe, zda můžete to a to udělat hned. Malá restrukturalizace může výrazně zjednodušit váš návrh. Tip 8.21

Neodkládejte na dobu běhu to, co můžete zkompilovat již dnes.

254 Minimalizace řídicích struktur

Kdykoli se můžete rozhodnout před kompilací aplikace, udělejte to. Předpokládejme, že jste měli dvě verze pole: jednu, která prováděla kontrolu hranic pro vaši ochranu během vývoje, a druhou, která běžela rychleji, i když bez ochrany pro skutečnou aplikaci. Obě verze uchovávejte v různých obrazovkách. Při kompilaci aplikace načtěte pouze tu verzi, kterou potřebujete. Mimochodem, pokud se budete řídit tímto návrhem, můžete se zbláznit při úpravách závorek v a mimo bloky načítání, abyste změnili, která verze se pokaždé načte. Místo toho si napište vyhozené definice, které budou rozhodovat za vás. Například (jak již bylo předvedeno v jiném kontextu): : .

150

'TESTOVÁNÍ? @

1 AND +

LOAD ;

Tip DUP příznak, nevytvářejte jej znovu.

8.22

Někdy potřebujete příznak, abyste zjistili, zda byla nebo nebyla vyvolána předchozí část kódu. Následující definice ponechává příznak, který indikuje, že byl proveden DO-IT: : DID-I? ( -- t=I-did) SHOULD-I? IF DO-IT

TRUE

ELSE

FALSE

POTOM ;

To lze zjednodušit na: : DID-I? ( -- t=I-did) SHOULD-I? DUP IF

DO-IT

POTOM ;

Tip Nenastavujte příznak, nastavte data.

8.23

Pokud je jediným účelem nastavení příznaku to, aby se později nějaký kód mohl rozhodnout mezi jedním a druhým číslem, je lepší uložit samotné číslo. Tento bod ilustruje příklad "barvy" v části šesté kapitoly nazvané "Faktorová kritéria". Účelem slova LIGHT je nastavit příznak, který udává, zda chceme, aby byl nastaven bit intenzity, nebo ne. Mohli jsme sice napsat : LIGHT

TRUE "LIGHT? ! ;

abychom nastavili příznak, a 'LIGHT? @ IF

8 OR

THEN ...

Správné načasování 255

k použití příznaku, není tento přístup tak jednoduchý jako vložení samotné bitové masky intenzity do proměnné: : LIGHT

8 'LIGHT? ! ;

a pak jednoduše zapsat 'LIGHT? @

NEBO ...

pro jeho použití. Tip 8.24

Nenastavujte příznak, ale funkci. (Vektor.)

Tento tip je podobný předchozímu a žije se stejným omezením. Pokud je jediným účelem nastavení příznaku to, aby se později nějaký kód mohl rozhodnout mezi jednou a druhou funkcí, je lepší uložit adresu samotné funkce. Například kód pro přenos znaku na tiskárnu je jiný než pro plácnutí znaku na displej videa. Špatná implementace by definovala: To je špatně, protože se při každém zadání řetězce rozhodujete, kterou funkci provést. Vhodnější implementace by používala vektorované provádění. Například: To je lepší, protože TYPE se nemusí rozhodovat, který kód má použít, už to ví. (Ve víceúlohovém systému by úlohy tiskárny a monitoru měly každá svou vlastní kopii vektoru provádění pro TYPE uloženou v uživatelské proměnné). Výše uvedený příklad také ilustruje omezení tohoto tipu. V naší druhé verzi nemáme žádný jednoduchý způsob, jak zjistit, zda je naším aktuálním zařízením tiskárna nebo obrazovka videa. Mohli bychom to potřebovat vědět, například abychom se mohli rozhodnout, zda vyčistit obrazovku, nebo vydat formulářový příkaz. Pak provádíme další použití stavu a naše pravidlo již neplatí.

256 Minimalizace řídicích struktur

Příznak by ve skutečnosti umožnil nejjednodušší implementaci dalších operací závislých na stavu. V případě TYPE nám však jde o rychlost. Řetězce zadáváme tak často, že si nemůžeme dovolit ztrácet při tom čas. Nejlepším řešením by zde mohlo být nastavení funkce TYPE a také nastavení příznaku: DOER TYPE : VIDEO O ZAŘÍZENÍ ! MAKE TYPE ( ...kód pro video...) ; : PRINTER 1 DEVICE ! MAKE TYPE ( ...kód pro tiskárnu...) ; TYPE tedy již ví, který kód má provést, ale další definice se budou odkazovat na příznak. Další možností je napsat slovo, které načte parametr DOER slova TYPE (ukazatel na aktuální kód) a porovná jej s adresou PRINTER. Pokud je menší než adresa PRINTER, použijeme rutinu VIDEO, v opačném případě použijeme rutinu PRINTER. Pokud změna stavu zahrnuje změnu malého počtu funkcí, můžete ještě použít DOER/MAKE. Zde jsou definice tří operátorů pro přesun paměti, které lze vypnout společně. DOER !' ( vektorovatelný ! ) DOER CMOVE' ( vektorovatelný CMOVE ) DOER FILL' ( vektorovatelný FILL ) : STORING MAKE !' ! ;AND MAKE CMOVE' CMOVE ;AND MAKE FILL' FILL ; : -STORING MAKE !' 2DROP ;AND MAKE CMOVE' 2DROP DROP ;AND MAKE FILL' 2DROP DROP ; Pokud je však třeba vektorovat velký počet funkcí, byla by vhodnější stavová tabulka. Důsledek tohoto pravidla zavádí "strukturovaný výstupní háček", slovo DOER vektorované tak, aby provedlo strukturovaný výstup. DOER HESITATE ( výstupní háček) : DISSOLVE HESITATE FILE-DIVORCE ; (. . . Mnohem později ve výpisu:) : RELENT

MAKE HESITATE

SEND-FLOWERS R> DROP ;

Ve výchozím nastavení HESITATE nedělá nic. Pokud vyvoláme DISSOLVE, skončíme u soudu. Pokud však před DISSOLVE pošleme RELENT, pošleme květiny a pak jasně přeskočíme na středník, čímž zrušíme tento soudní příkaz dříve, než se to náš partner dozví.

Dobré načasování 257

Tento přístup je vhodný zejména tehdy, když zrušení musí provést funkce definovaná mnohem později ve výpisu (rozklad podle sekvenční složitosti). Zvýšená složitost dřívějšího kódu se omezuje pouze na definování háčku a jeho vyvolání na správném místě.

Zjednodušování Tento tip jsem si nechal na konec, protože je příkladem toho, jak se vyplatí zvolit jednoduchost. Zatímco ostatní tipy se týkají udržovatelnosti, výkonnosti, kompaktnosti atd., tento tip souvisí s druhem uspokojení, které hledal Thoreau u rybníka Walden. Tip 8.25

Snažte se zcela vyhnout ukládání příznaků do paměti.

Příznak na zásobníku je něco zcela jiného než příznak v paměti. Příznaky na zásobníku lze jednoduše určit (čtením hardwaru, výpočtem nebo čímkoli jiným), posunout na zásobník a poté spotřebovat řídicí strukturou. Krátký život bez komplikací. Ale uložte příznak do paměti a sledujte, co se stane. Kromě toho, že máte samotný příznak, máte nyní složitost s umístěním příznaku. Umístění musí být: - vytvořit - inicializovat (ještě předtím, než se něco skutečně změní) - resetovat (jinak předání příznaku příkazu ponechá příznak v tomto aktuálním stavu). Protože příznaky v paměti jsou proměnné, nejsou reentrantní. Příkladem případu, kdy bychom mohli přehodnotit potřebu příznaku, je ten, se kterým jsme se již několikrát setkali. V našem příkladu "barvy" jsme vycházeli z předpokladu, že nejlepší syntaxe bude následující: LIGHT BLUE, tedy přídavné jméno LIGHT před barvou. V pořádku. Ale vzpomínáte si na kód pro implementaci této verze? Porovnejte jej s jednoduchostí tohoto přístupu: O 3 6 :

STEJNÁ ČERNÁ 1 STEJNÁ MODRÁ STEJNÁ CYANOVÁ 4 STEJNÁ ČERVENÁ STEJNÁ HNĚDÁ 7 STEJNÁ ŠEDÁ SVĚTLÁ ( barva -- barva ) 8 NEBO ;

2 KONSTANTNÍ ZELENÁ 5 KONSTANTNÍ PURPUROVÁ

V této verzi jsme obrátili syntaxi, takže nyní říkáme MODRÉ SVĚTLO.

258 Minimalizace řídicích struktur

Stanovíme barvu a poté ji upravíme. Odstranili jsme potřebu proměnné, kódu pro načítání z proměnné a dalšího kódu pro vynulování proměnné, když skončíme. A kód je tak jednoduchý, že mu nelze nerozumět. Když jsem tyto příkazy psal poprvé, zvolil jsem přístup podobný angličtině. "BLUE LIGHT" znělo obráceně, vůbec ne přijatelně. To bylo před mými rozhovory s Chuckem Moorem. Moorova filozofie je přesvědčivá: rozlišoval bych mezi pěkným čtením v angličtině a pěkným čtením. V jiných jazycích, například ve španělštině, přídavná jména následují za podstatnými jmény. Měli bychom být nezávislí na takových detailech, jako v jakém jazyce přemýšlíme. Záleží na záměru: jednoduchost, nebo napodobení angličtiny. Angličtina není tak vynikající jazyk, abychom ji otrocky následovali.

Kdybych prodával svá "barevná" slova v balíčku pro grafiky, dal bych si práci s vytvořením vlajky. Ale kdybych psal tato slova pro vlastní potřebu, kdybych to měl dělat znovu, dal bych přednost Moorovu vlivu a použil bych "BLUE LIGHT".

Shrnutí Používání logických a podmíněných příkazů jako významného strukturního prvku v programování vede k příliš komplikovanému, obtížně udržovatelnému a neefektivnímu kódu. V této kapitole jsme probrali několik způsobů, jak minimalizovat, optimalizovat nebo odstranit zbytečné podmíněné struktury. Závěrem dodejme, že zlehčování podmiňovacích způsobů ve Forthu nesdílí většina současných jazyků. Ve skutečnosti Japonci zakládají svůj projekt počítače páté generace na jazyce zvaném PROLOG - PROgramming in LOGic -, v němž se programuje výhradně v logice. Bude zajímavé sledovat, jak se při úvahách o této otázce budou formovat bojové linie: To IF or not to IF

V této knize jsme se zabývali prvními šesti kroky cyklu vývoje softwaru a zkoumali jsme jak filozofické otázky návrhu softwaru, tak praktické úvahy o implementaci robustního, efektivního a čitelného softwaru. Nezabývali jsme se optimalizací, validací, laděním, dokumentací, řízením projektu, vývojovými nástroji jazyka Forth, definicemi assembleru, využitím a zneužitím rekurze, vývojem víceprogramových aplikací ani cílovou kompilací. Ale to už je jiný příběh.

Odkazy [1] Charles Eaker, "Just in Case", Forth Dimensions II/3, str. 37.

Shrnutí 259

K dalšímu zamyšlení Definujte slovo DIRECTION, které vrací buď 1, -1, nebo 0 podle toho, zda je vstupní argument nenulový kladný, záporný, respektive nulový.

260 Minimalizace řídicích struktur

EPILOG

Vliv jazyka Forth na myšlení

Forth je jako Tao: je to Cesta, která se realizuje, když ji následujeme. V jeho křehkosti je jeho síla, v jeho jednoduchosti je jeho směr (Michael Ham, vítězný příspěvek v soutěži nakladatelství Mountain View Press o popis Forthu v maximálně pětadvaceti slovech).

Abych pomohl vytěžit něco z filozofie Forthu, provedl jsem mezi několika uživateli Forthu anketu, v níž jsem se zeptal: "Jak Forth ovlivnil vaše myšlení? Zjistili jste, že principy podobné Forthu uplatňujete i v jiných oblastech?". Zde jsou některé z odpovědí: Mark Bernstein je prezidentem společnosti Eastgate Systems Inc. v Cambridge ve státě Massachusetts a má doktorát z katedry chemie na Harvardově univerzitě. Poprvé jsem se s Forthovým systémem setkal, když jsem pracoval v oblasti laserové chemie. Snažil jsem se sestavit poměrně složitý řídicí systém pro nový laserový spektrometr. Původní plány počítaly s velkou zelenou krabicí plnou elektroniky, The Interface. Nikdo předtím tento konkrétní typ přístroje nestavěl - proto jsme to dělali - a seznam věcí, které jsme chtěli, aby počítač zvládal, se měnil každých pár týdnů. Po několika měsících jsem měl stovky stránek rutin v assembleru, tři velké desky plošných spojů plné integrovaných obvodů a sedmdesátipinovou systémovou sběrnici. Den za dnem bylo všechno křehčí a hůř opravitelné. Vodiče na deskách plošných spojů se roztřepily, konektory se uvolnily, kód v assembleru byl stále zamotanější. Forth byl zřejmým řešením softwarového problému, protože poskytoval slušné prostředí, v němž bylo možné sestavit a udržovat složitý a rychle se měnící program. Podstatou dobrého programování ve Forthu je však umění rozdělit procedury do užitečných, volných slov. Myšlenka slova Forth měla nečekané důsledky pro návrh laboratorního hardwaru. Místo abych stavěl velké, monolitické, univerzální rozhraní, zjistil jsem, že stavím hromady jednoduchých malých krabiček, které fungují podobně jako slova Forth: mají pevně danou sadu standardních vstupů a standardních výstupů, vykonávají jen jednu funkci, jsou navrženy tak, aby se daly bez větší námahy vzájemně propojit,

262 Vliv Forthu na myšlení

a byly natolik jednoduché, že jste mohli zjistit, co krabička dělá, pouhým pohledem na její popisek. . . . Myšlenka "lidského měřítka" je, myslím, dnešním stěžejním konceptem v oblasti návrhu softwaru. To není specificky vývoj Forthu; velkou radostí UNIXu, přinejmenším v jeho mládí, bylo, že se dal číst (protože byl napsán v C), rozumět mu (protože byl malý) a upravovat ho (protože byl jednoduchý). Forth má tyto přednosti stejné, i když je určen k řešení jiného druhu problémů. Protože je Forth malý a protože Forth dává svým uživatelům kontrolu nad jejich stroji, umožňuje Forth lidem ovládat jejich aplikace. Je prostě hloupé očekávat, že vědci budou sedět před laboratorním počítačem a hrát "dvacet otázek" se zabaleným softwarem. Správně použitý jazyk Forth umožňuje vědci instruovat počítač, místo aby počítač instruoval vědce. Ve stejném smyslu, v jakém má v baseballu pálkař cítit pálku jako prodloužení sebe sama, je Forth lidský a pomáhá vás přesvědčit, že úspěchy počítače i jeho neúspěchy jsou také vaše vlastní.

Raymond E. Dessy je profesorem chemie na Virginia Polytechnic Institute and State University v Blacksburgu ve Virginii. Když jsem se snažil pochopit podstatu a strukturu jazyka C, zjistil jsem, že čerpám ze znalostí, které jsem měl o organizaci a přístupu jazyka Forth. To mi umožnilo pochopit spletité nebo vysoce mlhavé úseky popisující jazyk C. Zjistil jsem, že přístup jazyka Forth je ideální platformou, na níž lze budovat porozumění a výukový rámec pro další jazyky a koncepty operačních systémů.

Jerry Boutelle je majitelem společnosti Nautilus Systems v kalifornském Santa Cruz, která prodává křížový kompilátor Nautilus. Forth změnil mé myšlení v mnoha ohledech. Od doby, kdy jsem se naučil Forth, jsem programoval v jiných jazycích, včetně assembleru, BASICu a FORTRANu. Zjistil jsem, že jsem používal stejný druh dekompozice, jaký používáme ve Forthu, ve smyslu vytváření slov a jejich seskupování. Například při manipulaci s řetězci bych definoval podprogramy analogické CMOVE, -TRAILING, FILL atd. Co je však podstatnější, Forth mě utvrdil v mé víře v jednoduchost. Většina lidí se pouští do řešení problémů pomocí složitých nástrojů. Ale jsou k dispozici i jednodušší nástroje a jsou užitečnější. Snažím se zjednodušit všechny aspekty svého života. Mám rád jeden citát z Tao te ťingu od čínského filozofa Lao-c': "Chcete-li dosáhnout poznání, každý den něco přidávejte, chcete-li získat moudrost, každý den něco ubírejte."

Forthův vliv na myšlení 263
