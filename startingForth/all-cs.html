<!DOCTYPE html>
<!-- uloženo z url=(0054)https://www.forth.com/starting-forth/0-starting-forth/ -->
<html lang="cs-CZ">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>Začínáme s jazykem Forthem</title>
   </head>
   <style>
   @font-face {
	font-family: TeleType;
	src: local("TeleType"), url('teletype.ttf');
	font-weight: normal;
	font-style: normal;
}
   body {
		line-height: 1.8em!important;
		overflow-wrap: break-word;
		margin-block-start: 1em;
		margin-block-end: 1em;
		margin-inline-start: 0px;
		margin-inline-end: 0px;
		font-family: "Open Sans", sans-serif;
	    font-weight: 400;
		text-transform: none;
		font-size: 20px;
	}
	h1 {
		font-size: 3em;
	}
	p {
		text-align: justify;
	}
	.wp-block-preformatted {
    font-size: .9em;
    margin-bottom: 1em;
    margin-left: 3em;
    line-height: 1.25em;
    font-family: 'Courier New';
    padding: 0;		
	font-weight: bold;
	}
	span.output {
	background-color: rgba(211,214,194,.4);
	padding-left: 0.2em;
	font-family: 'Courier New';
	}
	
	.site-content {
	padding-left: 50px;
	padding-right: 50px;
	max-width: 50em;
	margin: auto;
	}
	.defined {
		border: 1px solid black;
		padding: 1px;
		border-radius: 3px;
	}
	
   </style>
   <body>
      <div class="site grid-container container hfeed grid-parent" id="page">
         <div class="site-content" id="content">
            <div class="content-area grid-parent mobile-grid-100 grid-70 tablet-grid-70" id="primary">
               <main class="site-main" id="main">
                  <article id="post-309" class="post-309 page type-page status-publish" itemtype="https://schema.org/CreativeWork" itemscope="">
                     <div class="inside-article">
                        <h1>Začínáme s jazykem Forth</h1>
						<header class="entry-header" aria-label="Content">
                           <h2 class="entry-title" itemprop="headline">Představení</h2>
                        </header>
                        <div class="entry-content" itemprop="text">
                           <h3><span id="O_autoru">O autorovi</span></h3>
                           <figure id="attachment_355" aria-describedby="caption-attachment-355" style="width: 120px; float: right" class="wp-caption alignleft">
                              <img class="size-full wp-image-355" src="img/leo-brodie.jpg" alt="Leo Brodie, autor" width="130" height="146">
                              <figcaption id="caption-attachment-355" class="wp-caption-text">Leo Brodie</figcaption>
                           </figure>
                           <p>Neschopnost Lea Brodieho vyjádřit i ty nejsložitější technické koncepty bez přidání špetky humoru vychází z jeho rané lásky ke komediím. Specializoval se na psaní divadelních her na Kalifornské univerzitě v Los Angeles. Tam i v místním divadle bylo několik jeho komedií bylo uvedeno. Psal také články do časopisů na volné noze a pracoval jako copywriter v reklamní agentuře. Když společnost, pro kterou pracoval, instalovala počítač, inspirovalo ho to k tomu, aby zkusil navrhnout hračku na bázi mikroprocesoru. Přestože hračku nikdy nezprovoznil, naučil se hodně o počítačích a programování. Nyní pracuje ve společnosti FORTH, Inc. jako technický a marketingový spisovatel, kde si může hrát s počítači, jak mu určí múza, aniž by musel být fanatickým počítačovým džokejem, a může psát knihy, jako je tato.</p>
                           <p>Mezi Leovy další zájmy patří zpěv, řízení klasických Volv a tanec na hudbu 50. let.</p>
                           <h3><span id="Předmluva">Předmluva</span></h3>
                           <figure id="attachment_357" aria-describedby="caption-attachment-357" style="width: 242px; float: right" class="wp-caption alignleft">
                              <img loading="lazy" class="size-medium wp-image-357" src="img/Charles-H-Moore_nraos-252x300.jpg" alt="Charles H. Moore, vynálezce Forthu&#39;na obrázku při práci na Národní radioastronomické observatoři. " width="252" height="300" srcset="img/Charles-H-Moore_nraos-252x300.jpg 252w, https://www.forth.com/wp-content/uploads/2015/03/Charles-H-Moore_nraos.jpg 286w" sizes="(max-width: 252px) 100vw, 252px">
                              <figcaption id="caption-attachment-357" class="wp-caption-text">Charles H. Moore</figcaption>
                           </figure>
                           <p>Komunita jazyka Forth může oslavit významnou událost, kterou je vydání knihy <em>Začínáme s jazykem Forth</em> (Starting Forth). Do této knihy bylo vloženo větší úsilí, talent a nasazení než do kterékoli předchozí úvodní příručky. Zejména mě to těší jako důkaz rostoucí popularity jazyka Forth.</p>
                           <p>Jazyk Forth jsem vyvíjel několik let jako rozhraní mezi mnou a počítači, které jsem programoval. Tradiční jazyky neposkytovaly výkon, jednoduchost ani flexibilitu, kterou jsem chtěl. Nebral jsem ohled na mnoho tradičních názorů, abych do něj zahrnul přesně ty možnosti, které produktivní programátor potřebuje. Nejdůležitější z nich je možnost přidat jakékoli schopnosti, které se později stanou nezbytnými.</p>
                           <p>Poprvé jsem myšlenky, které jsem vyvíjel, spojil do jednoho celku, když jsem pracoval na počítači IBM 1130, počítači "třetí generace". Výsledek se mi zdál tak výkonný, že jsem jej považoval za "počítačový jazyk čtvrté generace". Nazval bych ho FOURTH (čtvrtý), až na to, že 1130 umožňoval pouze pětiznakové identifikátory. Takže z FOURTH se stal FORTH, což je stejně hezčí slovní hříčka (toto slovo v angličtině znamená "vpřed").</p>
                           <p>Jednou ze zásad, která řídila vývoj jazyka Forth a nadále řídí jeho používání, je přímočaré: udržujte to jednoduché. Jednoduché řešení má eleganci. Je výsledkem náročného úsilí o pochopení <em>skutečného</em> problému a pozná se podle přesvědčivého pocitu správnosti. Tento bod zdůrazňuji proto, že je v rozporu s tradičním názorem, že se složitostí roste výkon. Jednoduchost poskytuje jistotu, spolehlivost, kompaktnost a rychlost.</p>
                           <p>Knihu <em>Začínáme s jazykem Forth</em> napsal a ilustroval Leo Brodie, pozoruhodně schopný člověk, jehož vhled a představivost se vám záhy ukáže. Tato kniha je originálním a podrobným receptem na učení. Obratně vede začátečníka přes prahy porozumění, které musí překročit všichni programátoři ve Forthu.</p>
                           <p>Ačkoli jsem jediný člověk, který se Forth nikdy nemusel učit, vím, že jeho studium může být skličující. Stejně jako u lidského jazyka je třeba si zapamatovat použití mnoha slov. Zdá se, že pro začátečníky je toto studium díky Leovým vtipným komentářům a skvěle obsazeným postavám snadné a příjemné. Těm, kteří jako já již Forth znají, poskytne rychlé čtení příjemnou exkurzi a nové pohledy na známý terén. Doufám však, že tato kniha není tak snadná a příjemná, aby se zdála triviální. Upozorňujeme, že je zde těžký obsah a že se zde můžete dozvědět mnoho nového o počítačích a překladačích i o programování.</p>
                           <p>Forth poskytuje přirozený prostředek komunikace mezi člověkem a inteligentními stroji, kterými se obklopuje. To vyžaduje, aby sdílel vlastnosti lidských jazyků včetně kompaktnosti, univerzálnosti a rozšiřitelnosti. Nedovedu si představit lepší jazyk pro psaní programů, vyjadřování algoritmů nebo porozumění počítačům. Doufám, že při čtení této knihy mi dáte za pravdu.</p>
                           <p style="text-align: right;">Charles H. Moore<br>
                              vynálezce jazyka Forth
                           </p>
                           <h3><span id="O_této_knize">O této knize</span></h3>
                           <p>Vítejte v knize <em>Začínáme s jazykem Forth</em>, která je úvodem do vzrušujícího a výkonného počítačového jazyka Forth.</p>
                           <p>Jestliže jste začátečník, který se chce dozvědět více o počítačích, Forth je skvělý způsob učení. Psaní programů ve Forthu je zábavnější než v jakémkoli jiném jazyce, který znám. (viz "<a href="#begIntro">Úvod pro začátečníky</a>").</p>
                           <p>Jste-li zkušený profesionál, který se chce naučit Forth, je tato kniha přesně to, co potřebujete. Forth je velmi odlišný přístup k počítačům, natolik odlišný, že každý, od nováčků až po staré mazáky, se Forth naučí nejlépe od základů. Pokud jste zběhlí v jiných počítačových jazycích, vypusťte je prozatím z hlavy a pamatujte si jen to, co víte o <em>počítačích</em>. (viz "<a href="#profIntro">Úvod pro odborníky</a>")</p>
                           <p>Protože se o jazyk Forth zajímá mnoho lidí s různým vzděláním, uspořádal jsem tuto knihu tak, abyste si přečetli jen to, co potřebujete vědět, s poznámkami pod čarou určenými různým typům čtenářů. První polovina <a href="#kindsOfNumbers">kapitoly 7</a> poskytuje základy počítačové aritmetiky pouze pro začátečníky.</p>
                           <p>Tato kniha vysvětluje, jak psát jednoduché aplikace v jazyce Forth. Obsahuje všechna standardní slova jazyka Forth, která potřebujete k napsání jednoúlohové aplikace na vysoké úrovni. Tato sada slov je mimořádně silná a obsahuje vše od jednoduchých matematických operátorů až po slova ovládající překladač.</p>
                           <p>V této knize nejsou zahrnuty všechny příkazy, které se týkají assembleru, cílového kompilátoru a dalších specializovaných utilit. Tyto příkazy jsou k dispozici v některých verzích jazyka Forth, jako je eForth, a ve většině komerčních implementací.</p>
                           <p>Vybral jsem příklady, které budou skutečně fungovat na systému Forth s terminálem a diskem. Nevyvozujte z toho, že Forth je omezen na dávkové úlohy nebo na práci s řetězci, protože užitečnost Forthu ve skutečnosti není nijak omezena.</p>
                           <p>Tady jsou některé vlastnosti této knihy, které vám usnadní její používání:</p>
                           <ul>
                              <li>Všechny příkazy jsou uvedeny dvakrát: poprvé v kapitole, v níž je slovo uvedeno, a podruhé ve shrnutí na konci dané kapitoly.</li>
                              <li>Každá kapitola obsahuje také přehled pojmů a soubor cvičných úloh s odpověďmi.</li>
                              <li>Je zařazeno několik "šikovných rad", které odhalují tipy nebo volitelné postupy, které jsou pro studenty užitečné, ale nezaslouží si vysvětlení, jak nebo proč fungují.</li>
                           </ul>
                           <p>Osobní poznámka: Forth je velmi neobvyklý jazyk. Porušuje mnoho základních pravidel programování. Moje první reakce na Forth byla krajně skeptická, ale jak jsem se snažil vyvíjet složité aplikace, začal jsem vnímat jeho krásu a sílu. Sami sobě dlužíte, abyste si při čtení o některých jeho zvláštnostech zachovali otevřenou mysl. Hned vás varuji: jen málo programátorů, kteří se naučí Forth, se někdy vrátí k jiným jazykům.</p>
                           <p>Přeji vám hodně štěstí a příjemné učení!</p>
                           <p style="text-align: right;">Leo Brodie<br>
                              FORTH, Inc.
                           </p>
                           <h3><span id="Poděkování">Poděkování</span></h5>
                           <p>Rád bych poděkoval následujícím lidem, kteří se podíleli na vzniku této knihy:</p>
                           <p>Za konzultace ohledně techniky a stylu jazyka Forth: Ratherové, všem ze společnosti FORTH Inc.; za poskytnutí poznatků o umění výuky jazyka Forth a za napsání několika problémů v této knize: Kim Harrisové z Forth Interest Group; za korektury, redakční návrhy a obrovské množství práce při formátování stránek: Rosenberg; za pomoc při psaní na stroji a další nezbytnosti: Carolyn A: Za pomoc s grafikou: Sue Linstrotová, Carolyn Lubisichová, Kevin Weaver, Kris Cramerová a Stephanie Brown Brodieová; za pomoc s grafikou: Mgr: Za technickou pomoc: Winnie Shows, Natasha Elbert, Barbara Roberts a John Dotson z tiskárny Sunrise Printery (Redondo Beach, Kalifornie); za technickou pomoc: Bill Patterson a Gary Friendlander; za konstruktivní kritiku, velkou trpělivost a lásku: Stephanii Brown Brodieové; a za vynález Forthu: Charesu H. Mooreovi.</p>
                           
						   
						   
						   <h2><span id="Úvod">Úvody</span></h2>
                           <a id="begIntro"></a><h3><span id="Úvod_pro_začátečníky_co_je_počítačový_jazyk">Úvod pro začátečníky: Co je to počítačový jazyk?</span></h3> 
                           <p>
                              Když začátečníci uslyší pojem "počítačový jazyk", zpočátku se ptají: "Jakým jazykem by počítač mohl mluvit? To musí být pro lidi strašně těžké pochopit. Pravděpodobně vypadá takto:<br>
                              <img style="float: right; padding: 2em" loading="lazy" src="img/puppet.png" alt="Co je &#39;počítačový jazyk&#39;?">
                           </p>
                           <pre> 976#!@NX714&amp;+</pre>
                           <p>pokud to vůbec nějak vypadá.</p>
                           <p>Ve skutečnosti by počítačový jazyk neměl být obtížně srozumitelný. Jeho účelem je pouze sloužit jako pohodlný kompromis pro komunikaci mezi člověkem a počítačem.</p>
                           <p>Přemýšlejte o loutce. Marionetu můžete přimět k "chůzi" jednoduše tím, že budete pracovat s dřevěným ovladačem, aniž byste se dotkli provázků. Dalo by se říci, že kývání ovladačem znamená v jazyce marionety "chůzi". Loutkář vede marionetu způsobem, kterému marioneta rozumí a který loutkář snadno zvládne.</p>
                           <p>Počítače jsou stroje stejně jako loutka. Musí jim být přesně řečeno, co mají dělat, a to konkrétním jazykem. A tak potřebujeme jazyk, který má dvě zdánlivě protichůdné vlastnosti:</p>
                           <p>Na jedné straně musí mít pro počítač přesný význam a předávat všechny informace, které počítač potřebuje znát, aby mohl provést danou operaci. Na druhé straně musí být jednoduchý a snadno použitelný pro programátora.</p>
                           <p>Od vzniku počítačů bylo vyvinuto mnoho jazyků: Jazyk Fortran je starším představitelem této oblasti; COBOL je stále standardním jazykem pro zpracování dat; BASIC byl navržen jako jazyk pro začátečníky na cestě k jazykům jako Fortran a COBOL. Tato kniha je o jazyce zcela jiného druhu jménem Forth. Obliba jazyka Forth se v posledních několika letech udržuje na konstantní úrovni a jeho obliba je společná programátorům ve všech oborech.</p>
                           <p>Všechny výše uvedené jazyky, včetně Forthu, se nazývají "vysokoúrovňové" jazyky. Pro začátečníky je důležité uvědomit si rozdíl mezi vysokoúrovňovým jazykem a počítačem, na kterém běží. Vysokoúrovňový jazyk vypadá pro programátora stejně bez ohledu na to, na jaké značce nebo modelu počítače běží. Každá značka nebo model má však svůj vlastní interní jazyk neboli "strojový jazyk". Abychom vysvětlili, co je to strojový jazyk, vraťme se k loutce.</p>
                           <p>Představte si, že neexistuje žádné dřevěné ovládání a že loutkář musí zacházet přímo s provázky. Každý provázek odpovídá přesně jedné části těla loutky. Harmonické kombinace pohybů jednotlivých strun bychom mohli nazvat "strojovým jazykem" marionety.</p>
                           <p>Nyní provázky připoutejte k ovládacímu prvku. Ovládání je jako jazyk vysoké úrovně. Jednoduchým otočením zápěstí může loutkář pohybovat mnoha strunami současně.</p>
                           <p>Stejně tak je to s vysokoúrovňovým počítačovým jazykem, kde jednoduchý a známý symbol "+" způsobí, že se při sčítání provede mnoho vnitřních funkcí.</p>
                           <p><img loading="lazy" class="alignright size-full wp-image-359" src="img/language-hierarchy.png" alt="počítačové programy, průběh provádění"><br>
                              Počítač umí jednu velmi chytrou věc: lze jej naprogramovat tak, aby překládal symboly vysoké úrovně (například "+") do vlastního strojového jazyka počítače. Pak může přistoupit k provádění strojových instrukcí. Jazyk vysoké úrovně je počítačový program, který překládá lidsky srozumitelná slova a symboly do strojového jazyka konkrétní značky a modelu počítače.
                           </p>
                           <p>Jaký je rozdíl mezi jazykem Forth a ostatními jazyky vysoké úrovně? Velmi stručně řečeno: souvisí to s kompromisem mezi člověkem a počítačem. Jazyk by měl být navržen pro pohodlí jeho lidských uživatelů, ale zároveň pro sloučitelnost s fungováním počítače.</p>
                           <p>Jazyk Forth je mezi jazyky jedinečný, protože jeho řešení tohoto problému je jedinečné. Tato kniha vám vysvětlí jak.</p>
                        </div>
                     </div>
                  </article>
               </main>
            </div>
         </div>
      </div>
      <div class="site grid-container container hfeed grid-parent" id="page">
         <div class="site-content" id="content">
            <div class="content-area grid-parent mobile-grid-100 grid-70 tablet-grid-70" id="primary">
               <main class="site-main" id="main">
                  <article id="post-310" class="post-310 page type-page status-publish" itemtype="https://schema.org/CreativeWork" itemscope="">
                     <div class="inside-article">
					 
					 
<a id="profIntro">
<h3><span id="Úvod_pro_odborníky">Úvod pro odborníky: Forth v reálném světě</span></h5>

<p>Forth se v posledních letech těší rostoucí popularitě, která je patrně nejviditelnější mezi nadšenci a amatéry. Tento vývoj je však pouze novou epizodou v historii jazyka Forth. Forth se v kritických vědeckých a průmyslových aplikacích používá již více než deset let. Ve skutečnosti, pokud profesionálně používáte minipočítač nebo mikropočítač, je pravděpodobné, že Forth dokáže spustit vaši aplikaci - efektivněji než jazyk, který používáte v současné době.</p>

<p>Teď se pravděpodobně řečnicky zeptáte: "Když je Forth tak efektivní, jak to, že ho nepoužívám?". Odpověď zní, že stejně jako většina lidí nevíte, co Forth je.</p>

<p>Abyste Forth skutečně pochopili, měli byste si přečíst tuto knihu a pokud možno najít nějaký systém Forth a vyzkoušet si ho na vlastní kůži. Těm z vás, kteří si ještě v knihkupectví prohlížejí knihy, však tato část odpoví na dvě otázky: "Co je Forth?" a "K čemu je dobrý?".</p> 

<p>Forth je mnoho věcí:</p>

<ul>
<li>jazyk vysoké úrovně</li>
<li>jazyk assembleru</li>
<li>operační systém</li>
<li>sada vývojových nástrojů</li>
<li>filozofie návrhu softwaru</li>
</ul>

<p>Forth jako jazyk začíná výkonnou sadou standardních příkazů a poté poskytuje mechanismus, pomocí kterého můžete definovat vlastní příkazy. Strukturovaný proces vytváření definic na základě předchozích definic je ve Forthu ekvivalentem vysokoúrovňového kódování. Alternativně lze slova definovat přímo v mnemotechnice assembleru pomocí assembleru jazyka Forth. Všechny příkazy jsou interpretovány stejným interpretem a kompilovány stejným kompilátorem, což dává jazyku obrovskou flexibilitu.</p>

<p>Nejvyšší úroveň vašeho kódu se bude podobat popisu aplikace v anglickém jazyce. Forth byl nazván "metaaplikačním jazykem" - jazykem, který můžete použít k vytvoření problémově orientovaných jazyků.</p>

<p>Jako operační systém dělá Forth vše, co tradiční operační systémy, včetně interpretace, kompilace, sestavování, práce s virtuální pamětí, I/O, editace textu atd.</p> 

<p>Protože je však operační systém Forth díky své konstrukci mnohem jednodušší než jeho tradiční protějšky, běží mnohem rychleji, pohodlněji a v mnohem menším objemu paměti.</p> 

<p>K čemu je Forth dobrý? Forth nabízí jednoduchý prostředek k maximalizaci efektivity procesoru. Například:</p>

<p>Forth je rychlý. Vysokoúrovňový jazyk Forth se spouští rychleji než jiné vysokoúrovňové jazyky a o 20 až 75 % pomaleji než ekvivalentní programy v assembleru, zatímco časově kritický kód lze napsat v assembleru, aby běžel plnou rychlostí procesoru. Bez tradičního operačního systému eliminuje Forth redundanci a zbytečné kontroly chyb za běhu.</p> 

<p>Zkompilovaný kód jazyka Forth je kompaktní. Aplikace v jazyce Forth potřebují méně paměti než jejich ekvivalentní programy v assembleru! Celý operační systém napsaný v jazyce Forth a jeho standardní sada slov se nacházejí v méně než 8KB. Podpora cílové aplikace může vyžadovat méně než 1KB.</p>

<p>Forth je přenosný. Byl implementován téměř na všech známých minipočítačích a mikropočítačích. Je známo, že Forth zkracuje dobu vývoje programu desetkrát oproti programování v jazyce assembleru a dvakrát oproti vysokoúrovňovému programování. Produktivita se zvyšuje, protože Forth je ztělesněním "strukturovaného programování" a protože je interaktivní a modulární. Zde je několik ukázek použití jazyka Forth v reálném světě:</p>

<ul>
<li><em>Řízení procesů</em> -- Forth se používá k řízení pohyblivých kamer robotů, které vytvářejí speciální efekty použité ve filmu "Sador, vládce vesmíru". Jazyk Forth byl vybrán kvůli své rychlosti a flexibilitě při poskytování rozhraní, pomocí kterého může operátor popisovat pohyb kamery. Další aplikace pro řízení procesů sahají od odbavovače zavazadel pro velkou americkou leteckou společnost až po třídič broskví pro kalifornskou konzervárnu.</li>

<li><em>Přenosná inteligentní zařízení</em> -- mezi nejrůznější aplikace, které interně využívají Forth, patří monitor srdce pro ambulantní pacienty, analyzátor zapalování v automobilech, ruční přístroj pro měření relativní vlhkosti různých druhů obilí a Craigův jazykový překladač.</li>

<li><em>Zdravotnictví</em> -- Na jediném počítači PDP-11 ve velké nemocnici Forth současně spravuje rozsáhlou databázi pacientů; řídí dvaatřicet terminálů a optickou čtečku; provádí statistickou analýzu databáze, aby koreloval tělesné typy, nemoci, léčbu a výsledky; a analyzuje vzorky krve a monitoruje srdeční tep v reálném čase.</li>

<li><em>Sběr a analýza dat</em> -- jediný počítač PDP-11/34 běžící pod systémem Forth řídí celou observatoř včetně mimořádně přesného dalekohledu, kopule, několika CRT, hodin, řádkové tiskárny a disketové jednotky -- a ještě stihne pořizovat data o infračervených emisích z vesmíru, analyzovat data a zobrazovat výsledky na grafickém monitoru. Aplikace tohoto typu často využívají rychlé Fourierovy a Walshovy transformace, numerickou integraci a další matematické rutiny napsané v jazyce Forth.</li>				 
</ul>

<p>Musíme přiznat, že to má jeden háček. Spočívá v tom, že Forth vás činí zodpovědnými za efektivitu vašeho počítače. Abychom použili analogii: manuální převodovka je náročnější na zvládnutí než automatická, přesto pro mnoho řidičů nabízí lepší kontrolu nad vozidlem.</p> 

<p>Podobně je Forth náročnější na zvládnutí než tradiční vysokoúrovňové jazyky, které se v podstatě podobají jeden druhému (tj. po naučení jednoho není obtížné naučit se další). Po zvládnutí však Forth poskytuje možnost minimalizovat čas procesoru a paměťový prostor a také organizační filozofii, díky níž můžete výrazně zkrátit dobu vývoje projektu.</p> 

<p>A nezapomeňte, že všechny prvky jazyka Forth využívají stejný protokol, včetně operačního systému, překladače, interpretu, textového editoru, virtuální paměti, assembleru a multiprogramátoru. Křivka učení se jazyku Forth je mnohem kratší než křivka učení se všem těmto samostatným prvkům dohromady.</p> 

<p>Pokud vám něco z toho připadá vzrušující, otočte stránku a začněte používat Forth.</p> 					 
					 
                        <header class="entry-header" aria-label="Content">
                           <h2 class="entry-title" itemprop="headline">1. Základy Forthu</h2>
                        </header>
                        <div class="entry-content" itemprop="text">
                           <p>V této kapitole vás seznámíme s některými jedinečnými vlastnostmi jazyka Forth. Po několika úvodních stránkách vás posadíme k terminálu jazyka Forth.</p>
                           <h3 id="h-a-živý-jazyk"><span id="A_Živý_jazyk">Živý jazyk</span></h3>
                           <p>Představte si, že jste vedoucí kanceláře a právě jste přijali novou horlivou asistentku. Hned první den naučíte asistentku správný formát psaní korespondence (asistentka už umí psát na klávesnici). Na konci dne už stačí říct: "Prosím, napište to."</p>
                           <p>Druhý den vysvětlíte systém archivace. Celé dopoledne trvá, než vysvětlíte, kam co patří, ale odpoledne už stačí jen říct: "Prosím, založte to."</p>
                           <p>Koncem týdne už dokážete komunikovat v jakési zkratce, kdy "Prosím, pošlete tento dopis" znamená "Napište to, dejte mi to podepsat, okopírujte to, kopii založte a originál pošlete". Vy i vaše asistentka můžete příjemněji a efektivněji vykonávat svou práci.</p>
                           <p>Dobrá organizace a efektivní komunikace vyžadují, abyste</p>
                           <ol>
                              <li>definoval užitečné úkoly a každý úkol pojmenoval, poté</li>
                              <li>související úkoly seskupil do větších úkolů a každému z nich dal jméno atd.</li>
                           </ol>
                           <p>Příkaz Forth umožňuje uspořádat vlastní postupy a sdělit je počítači právě tímto způsobem (až na to, že nemusíte říkat "prosím").</p>
                           <p>Pro příklad si představte mikroprocesorem řízenou pračku naprogramovanou ve Forthu. Konečný příkaz ve vašem příkladu se jmenuje WASHER (pračka). Zde je definice příkazu WASHER zapsaná v jazyce Forth:</p>
                           <pre class="wp-block-preformatted">: WASHER   WASH SPIN RINSE  SPIN ;</pre>
                           <p>V jazyce Forth dvojtečka označuje začátek nové definice. První slovo za dvojtečkou, WASHER, je název nové procedury. Zbývající slova, WASH (vyprat), SPIN (ždímat), RINSE (opláchnout) a SPIN (ždímat), tvoří "definici" nového postupu. Nakonec středník označuje konec definice.</p>
                           <figure class="wp-block-image"><img width="200" height="52" src="img/ch1-washer.gif" alt="Definice dvojtečky Forth - příklad pračky" class="wp-image-365"></figure>
                           <p>Každé ze slov tvořících definici WASHER již bylo definováno v našem programu řízení pračky. Podívejme se například na naši definici slova pro opláchnutí, RINSE:</p>
                           <pre class="wp-block-preformatted">: RINSE   FILL AGITATE DRAIN ; </pre>
                           <p>Jak vidíte, definice RINSE se skládá ze skupiny slov: FILL (naplnit), AGITATE (promíchat) a DRAIN (odvést vodu). Opět platí, že každé z těchto slov již bylo definováno na jiném místě naší aplikace pračky. Definice slova FILL by mohla znít:</p>
                           <pre class="wp-block-preformatted">: FILL   FAUCETS OPEN TILL-FULL FAUCETS CLOSE ; </pre>
                           <p>V této definici máme na mysli <em>věci</em> (FAUCETS - kohoutky) i <em>akce</em> (OPEN - otevřít a CLOSE - zavřít). Slovo TILL-FULL (dokud není plná) bylo definováno tak, aby vytvořilo "zpožďovací smyčku", která nedělá nic jiného než značí čas, dokud nebude aktivován spínač hladiny vody, což znamená, že je vana pračky plná.</p>
                           <p>Pokud bychom tyto definice sledovali zpětně, nakonec bychom zjistili, že jsou všechny definovány v termínech skupiny velmi užitečných příkazů, které tvoří základ všech systémů Forth. Například kompletní ANS Forth se všemi rozšířeními obsahuje 371 takových příkazů. Mnohé z těchto příkazů jsou samy o sobě "dvojtečkové definice" stejně jako naše příkladová slova; jiné jsou definovány přímo ve strojovém jazyce konkrétního počítače. Ve Forthu se definovaný příkaz nazývá "<abbr title="Pro staré mazáky: Tento význam &#39;slova&#39; nelze spojovat s 16bitovou hodnotou.">slovo</abbr>" (pokud si tuto knihu čtete na počítači, vězte, že tečkovaně podtržená slova jako toto mají přidruženou poznámku).</p>
                           <p>Možnost definovat slovo ve smyslu jiných slov se nazývá "rozšiřitelnost". Rozšiřitelnost vede ke stylu programování, který je extrémně jednoduchý, přirozeně přehledný a tak výkonný, jak jen chcete.</p>
                           <p>Ať už vaše aplikace spouští montážní linku, získává data pro vědecké prostředí, udržuje obchodní aplikaci nebo hraje hru, můžete si vytvořit vlastní "živý jazyk" slov, která se vztahují k vaší konkrétní potřebě.</p>
                           <p>V této knize se budeme zabývat nejužitečnějšími standardními příkazy jazyka Forth.</p>
                           <h3 id="h-all-this-and-interactive"><span id="All_This_and_Interactive">To vše a navíc interaktivní!</span></h3>
                           <div class="wp-block-image">
                              <figure class="alignleft"><img loading="lazy" width="100" height="125" src="img/ch1-man-sitting.gif" alt="Jazyk Forth lze používat interaktivně na klávesnici." class="wp-image-366"></figure>
                           </div>
                           <p>Jednou z mnoha jedinečných vlastností jazyka Forth je, že umožňuje "<abbr title="Pro začátečníky: vykonat slovo znamená přikázat počítači, aby provedl příkaz">vykonat</abbr>" slovo prostým pojmenováním slova. Pokud pracujete na terminálové klávesnici, může to být tak jednoduché, že zadáte slovo a stisknete klávesu RETURN.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="125" src="img/ch1-woman-sitting.gif" alt="Interaktivní režim poskytuje způsob, jak testovat kód postupně, v průběhu jeho vývoje." class="wp-image-367"></figure>
                           </div>
                           <p>Stejné slovo můžete samozřejmě použít i v definici jakéhokoli jiného slova, stačí do definice uvést jeho název.</p>
                           <p>Jazyk Forth se nazývá "interaktivní" jazyk, protože provádí vaše příkazy v okamžiku, kdy je zadáte.</p>
                           <p>Uvedeme příklad, který si můžete sami vyzkoušet a který ukazuje postup kombinování jednoduchých příkazů do výkonnějších příkazů. Použijeme několik jednoduchých slov jazyka Forth, která ovládají obrazovku terminálu. Nejprve se však seznámíme s mechanikou "komunikace" s jazykem Forth prostřednictvím klávesnice terminálu.</p>
                           <p>Posaďte se ke svému skutečnému nebo imaginárnímu terminálu Forth. Budeme předpokládat, že někdo byl tak laskav a vše pro vás připravil, nebo že jste se řídili všemi instrukcemi uvedenými pro nahrání jazyka Forth na váš konkrétní počítač.</p>
                           <p>Nyní stiskněte klávesu <abbr title="Pro lidi u terminálů: RETURN může mít na vašem terminálu jiný název. Další možné názvy jsou NEW LINE a ENTER.">označenou</abbr>:</p>
                           <pre class="wp-block-preformatted">RETURN</pre>
                           <p>Počítač odpoví slovy</p>
                           <pre class="wp-block-preformatted"><span class="output">ok</span></pre>
                           <p>Klávesou RETURN sdělujete jazyku Forth, aby potvrdil váš požadavek. <span class="output">ok</span> je způsob, jakým Forth říká, že provedl vše, o co jste ho požádali, bez jakýchkoli zádrhelů. V tomto případě jste ho o nic nepožádali, takže Forth poslušně nic neudělal a řekl <span class="output">ok</span>.</p>
                           <p>Nyní zadejte toto:</p>
                           <pre class="wp-block-preformatted">15 SPACES</pre>
                           <p>Pokud uděláte překlep, můžete jej opravit stisknutím <abbr title="Většina Forthů podporuje mnohem sofistikovanější editaci příkazového řádku. Experimentujte.">"backspace"</abbr>. Vraťte se zpět k chybě, zadejte správné písmeno a pokračujte. Po správném zadání řádku stiskněte klávesu RETURN. (Jakmile stisknete klávesu RETURN, je na opravu řádku pozdě).</p>
                           <p>V této knize používáme symbol ↵ pro označení místa, kde musíte stisknout klávesu RETURN. Takto jsme také formátovali výstup počítače (i když počítač to nedělá), abychom naznačili, kdo co píše.</p>
                           <p>Zde je, co se stalo:</p>
                           <pre class="wp-block-preformatted">15 mezer↵<span class="output">               ok </span></pre>
                           <p>Jakmile jste stiskli klávesu RETURN, Forth vypsal patnáct prázdných mezer a poté, co zpracoval váš požadavek, odpověděl ok (na konci patnácté mezery).</p>
                           <p>Nyní zadejte toto:</p>
                           <pre class="wp-block-preformatted"> 42 EMIT↵<span class="output">*ok </span></pre>
                           <p>Výraz "42 EMIT" říká jazyku Forth, aby vytiskl hvězdičku (o tomto příkazu budeme hovořit později v knize). Zde Forth vytiskl hvězdičku a poté odpověděl ok (kód ASCII pro hvězdičku je 42. Podívejte se do <a href="http://www.asciitable.com/" target="_blank" rel="noopener noreferrer">ASCII tabulky</a>,  pokud mi nevěříte).</p>
                           <p>Na jeden řádek můžeme umístit více než jeden příkaz. Například:</p>
                           <pre class="wp-block-preformatted">15 SPACES 42 EMIT 42 EMIT↵<span class="output">               **ok </span></pre>
                           <p>Tentokrát Forth vypsal patnáct mezer a dvě hvězdičky. Poznámka k zadávání slov a/nebo čísel: můžeme je pro přehlednost oddělit od sebe libovolným počtem mezer. Musí však být odděleny <em>alespoň jednou mezerou</em>, aby je Forth dokázal rozpoznat jako slova a/nebo čísla.</p>
                           <p>Místo zadání výrazu</p>
                           <pre class="wp-block-preformatted">42 EMIT</pre>
                           <p>pořád dokola jej definujme jako slovo "STAR".<br>Zadejte toto:</p>
                           <pre class="wp-block-preformatted">: STAR   42 EMIT ;↵<span class="output">ok </span></pre>
                           <p>Tady STAR je název; "42 EMIT" je definice. Všimněte si, že dvojtečku a středník od sousedních slov oddělujeme mezerou. Také proto, aby se definice jazyka Forth lidem dobře četly, oddělujeme konvenčně název definice od jejího obsahu třemi mezerami.</p>
                           <p>Po zadání výše uvedených definic a stisknutí klávesy RETURN odpoví jazyk Forth ok, což znamená, že vaši definici rozpoznal a zapamatuje si ji. Nyní zadejte</p>
                           <pre class="wp-block-preformatted">STAR↵<span class="output">*ok </span></pre>
                           <p>Voila! Forth provede vaši definici "STAR" a vypíše hvězdičku.</p>
                           <p>Není rozdíl mezi slovem jako STAR, které si sami definujete, a slovem jako <span class="defined">EMIT</span>, které je již definováno. V této knize však budeme umisťovat ta slova, která jsou již definována, do rámečků, abyste je mohli snadněji rozlišovat.</p>
                           <p>Dalším systémově definovaným slovem je <span class="defined">CR</span>, které provádí <abbr title="Pro začátečníky: Nezapomeňte rozlišovat mezi klávesou označenou RETURN a forthovským slovem CR">odřádkování</abbr> na terminálu<abbr>. Zadejte například toto:</p>
                           <pre class="wp-block-preformatted">CR↵<span class="output"></span><br><span class="output">ok </span></pre>
                           <p>Jak vidíte, Forth provedl odřádkování a poté vypsal ok (na dalším řádku).</p>
                           <p>Nyní zkuste toto:</p>
                           <pre class="wp-block-preformatted">CR STAR CR STAR CR STAR↵<span class="output"><br>*<br>*<br>* ok </span></pre>
                           <p>Vložíme <span class="defined">CR</span> do definice, například takto:</p>
                           <pre class="wp-block-preformatted">: MARGIN   CR 30 SPACES ;↵<span class="output">ok </span></pre>
                           <p>Nyní můžeme zadat</p>
                           <pre class="wp-block-preformatted">MARGIN STAR MARGIN STAR MARGIN STAR↵</pre>
                           <p>a získáme tři hvězdy seřazené svisle, třicet mezer zleva.</p>
                           <p>Naše kombinace slov MARGIN STAR bude užitečná pro to, co hodláme dělat, takže definujme</p>
                           <pre class="wp-block-preformatted">: BLIP   MARGIN STAR ;↵<span class="output">ok </span></pre>
                           <p>Budeme také potřebovat vypsat vodorovnou řadu hvězdiček. Zadejme tedy následující definici (její fungování si vysvětlíme v některé z dalších kapitol):</p>
                           <pre class="wp-block-preformatted">: STARS 0 DO STAR LOOP ;↵<span class="output">ok </span></pre>
                           <p>Nyní můžeme říci</p>
                           <pre class="wp-block-preformatted"> 5 STARS↵<span class="output">*****ok </span></pre>
                           <p>nebo</p>
                           <pre class="wp-block-preformatted">35 STARS↵<span class="output">***********************************ok </span></pre>
                           <p>nebo jakýkoli počet hvězdiček, který si lze představit!</p>
                           <p>Budeme potřebovat slovo, které provede proceduru MARGIN a poté vypíše pět hvězdiček. Definujme jej takto:</p>
                           <pre class="wp-block-preformatted">: BAR   MARGIN 5 STARS ;↵<span class="output">ok </span></pre>
                           <p>Nyní můžeme zadat</p>
                           <pre class="wp-block-preformatted">BAR BLIP BAR BLIP BLIP CR</pre>
                           <p>a získáme písmeno "F" (jako Forth) složené z hvězdiček. Mělo by vypadat takto:</p>
                           <pre class="wp-block-preformatted"> *****<br> *<br> *****<br> *<br> *</pre>
                           <p>Závěrečným krokem je vytvořit z tohoto nového postupu slovo. Nazvěme toto slovo "F":</p>
                           <pre class="wp-block-preformatted">: F   BAR BLIP BAR BLIP BLIP CR ;↵<span class="output">ok </span></pre>
                           <p>Právě jste viděli příklad toho, jak se jednoduché příkazy jazyka Forth mohou stát základem složitějších příkazů. Výpis programu ve Forthu se skládá spíše z řady stále výkonnějších definic než z posloupnosti instrukcí, které se mají postupně vykonat.</p>
                           <p>Pro ukázku toho, jak aplikace Forth skutečně vypadá, uvádíme výpis naší experimentální aplikace:</p>
                           <pre class="wp-block-preformatted">( LARGE LETTER-F )<br>: STAR   42 EMIT ;<br>: STARS   0 DO STAR LOOP ;<br>: MARGIN   CR 30 SPACES ;<br>: BLIP   MARGIN STAR ;<br>: BAR   MARGIN 5 STARS ;<br>: F   BAR BLIP BAR BLIP BLIP CR ;</pre>
                           <h3 id="h-slovník"><span id="The_Dictionary">Slovník</span></h3>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="192" height="102" src="img/ch1-dictionary.gif" alt="Slovník Forth obsahuje názvy a definice všech slov (funkcí) jazyka Forth." class="wp-image-368"></figure>
                           </div>
                           <p>Každé slovo a jeho definice jsou zapsány do "slovníku" jazyka Forth. Slovník obsahoval mnoho slov již při spuštění, ale nyní jsou ve slovníku i vaše vlastní slova.</p>
                           <p>Když definujete nové slovo, Forth vaši definici převede do slovníkové podoby a zapíše položku do slovníku. Tento proces se nazývá <abbr title="Pro začátečníky: Kompilace je obecný počítačový termín, který obvykle znamená překlad vysokoúrovňového programu do strojového kódu, kterému počítač rozumí. Ve Forthu znamená totéž, ale konkrétně jde o zápis do slovníku.">"kompilace."</abbr></p>
                           <div class="wp-block-image">
                              <figure class="alignleft"><img loading="lazy" width="187" height="115" src="img/ch1-monk-star.gif" alt="Forth kompilátor" class="wp-image-369"></figure>
                           </div>
                           <p>Příklad při zadání řádku</p>
                           <pre class="wp-block-preformatted">: STAR   42 EMIT ;↵</pre>
                           <p>překladač zkompiluje novou definici do slovníku. Překladač <em>nevypíše</em> hvězdičku.</p>
                           <p>Jakmile je slovo ve slovníku, jak je slovo provedeno? Řekněme, že zadáte následující řádek přímo v terminálu (nikoliv uvnitř definice):</p>
                           <pre class="wp-block-preformatted">STAR 30 SPACES↵</pre>
                           <p>Tím se aktivuje slovo <span class="defined">INTERPRET</span>, známé také jako "textový interpret". Textový interpret prohledává vstupní proud a hledá řetězce znaků oddělené mezerami. Když najde řetězec, vyhledá jej ve slovníku. </p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="154" src="img/ch1-interpret.gif" alt="Interpret Forth" class="wp-image-370"></figure>
                           <p>Jestliže se slovo ve slovníku nachází, ukáže jej slovu <span class="defined">EXECUTE</span>, které provede definici (v tomto případě vypíše hvězdičku). Nakonec interpret řekne, že je vše "ok".</p>
                           <div class="wp-block-image">
                              <figure class="aligncenter"><img loading="lazy" width="200" height="185" src="img/ch1-executioner.gif" alt="EXECUTE a Forth definition" class="wp-image-371"></figure>
                           </div>

                           <div class="wp-block-image">
                              <figure class="aligncenter"><img loading="lazy" width="200" height="143" src="img/ch1-execution.gif" alt="Vykonání instrukcí Forth kódu" class="wp-image-372"></figure>
                           </div>

                           <p>Pokud interpret nenajde řetězec ve slovníku, zavolá běžce s čísly (nazvaný <span class="defined">NUMBER</span>, postava odkazuje na formu ilegálního hazardu v USA). <span class="defined">NUMBER</span> pozná číslo, když ho vidí. Pokud NUMBER nějaké číslo najde, odešle ho do dočasného úložiště čísel.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="127" src="img/ch1-numbers-runner.gif" alt="Forth interpret a čísla" class="wp-image-373"></figure>
                           <p>Co se stane, když se pokusíte vykonat slovo, které není ve slovníku? Zadejte toto a podívejte se, co se stane:</p>
                           <pre class="wp-block-preformatted">XLERB↵<span class="output">XLERB ? </span></pre>
                           <p>Když interpret textu nenajde XLERB ve slovníku, pokusí se ho předat slovu <span class="defined">NUMBER</span>. Slovo <span class="defined">NUMBER</span> si na něj posvítí. Pak vám interpret vrátí řetězec s otazníkem (Některé Forthy spolu s tím vypisují různá chybová hlášení).</p>
						   
						   
						   
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="132" src="img/ch1-xlerb.gif" alt="Provedení nedefinovaného/neznámého slova/definice ve Forthu" class="wp-image-374"></figure>
                           <p>V některých verzích jazyka FORTH, včetně polyFORTHu, překladač
nezkopíruje celý název definice do souboru slovníku, ale pouze první tři znaky a počet znaků slova. Například v polyFORTHu textový překladač nedokáže rozlišit mezi slovy STAR a STAG, protože obě slova jsou
čtyři znaky a obě začínají S-T-A.</p>
						   
						   <p>ANS Forth umožňuje uložit do slovníku slova o délce až jednatřicet znaků. Jméno by mělo obsahovat pouze tisknutelné znaky.</p>
                           <p>Shrňme si to: když na terminálu napíšete předem definované slovo, bude interpretováno a poté provedeno.</p>
                           <p>Nyní si vzpomínáte, že jsme si řekli, že : (dvojtečka) je slovo? Když zadáte slovo : jako ve slově</p>
                           <pre class="wp-block-preformatted">: STAR   42 EMIT ;↵</pre>
                           <p> dojde k následujícímu:</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="144" src="img/ch1-interpret-compile.gif" alt="Forth interpretuje a pak vykoná kód" class="wp-image-375"></figure>
                           <p>Interpret textu najde ve vstupním proudu dvojtečku a odkáže na ni <span class="defined">EXECUTE</span>. <span class="defined">EXECUTE</span> řekne překladači: "Prosím, začni kompilovat". Překladač přeloží definici do slovníkové podoby a zapíše ji do slovníku. Když překladač dojde ke středníku, zastaví se a pověří zpět textový interpret, který vypíše zprávu <span class="output">ok</span>.</p>
                           <div class="wp-block-image">
                              <figure class="aligncenter"><img loading="lazy" width="400" height="126" src="img/ch1-execute-colon.gif" alt="Forth kompilátor převede definici do slovníkového tvaru " class="wp-image-376"></figure>
                           </div>
                           <div class="wp-block-image">
                              <figure class="aligncenter"><a href="./01-Data a Forth Stack_files/ch1-compile-definition.gif"><img loading="lazy" width="394" height="122" src="img/ch1-compile-definition.gif" alt="Provádění Forth se vrací do textového interpretu" class="wp-image-377"></a></figure>
                           </div>
						   <h3>Řekni co?</h3>
                           <p>V jazyce Forth je slovo znak nebo skupina znaků, které mají definici. Při pojmenování slova lze použít téměř jakýkoli znak. Jediné znaky, které nelze použít, jsou:</p>
                           <ul>
                              <li>return - protože počítač si myslí, že jste zadávání ukončili.</li>
                              <li>backspace - protože si počítač myslí, že se snažíte opravit chybu při psaní.</li>
                              <li>mezerník - protože si počítač myslí, že jde o konec slova.</li>
							  <li>stříška (^) - protože editor (pokud jej používáte) si myslí, že máte na mysli něco jiného.</li>
							  
                           </ul>
                           <p>Tady je slovo jazyka Forth, jehož název se skládá ze dvou interpunkčních znamének. Slovo se jmenuje <span class="defined">."</span> a vyslovuje se "dot-quote". Pomocí <span class="defined">."</span> uvnitř definice můžete na terminálu napsat textový řetězec. Zde je příklad:</p>
                           <pre class="wp-block-preformatted">: GREET   ." HELLO, I SPEAK FORTH " ;↵<span class="output">ok</span></pre>
                           <p>Právě jsme definovali slovo s názvem GREET (pozdrav). Jeho definice se skládá pouze z jednoho slova Forthu, <span class="defined">."</span>, za kterým následuje text, který chceme napsat. Uvozovky na <em>konci</em> textu nebudou vypsány; označují konec textu. Říká se mu "oddělovač" (delimiter).</p>
                           <p>Při zadávání definice GREET nezapomeňte na uzavírací středník, kterým definici ukončíte.</p>
                           <p>Provedeme příkaz GREET:</p>
                           <pre class="wp-block-preformatted">GREET↵<span class="output">Hello, I speak Forth ok </span></pre>
                          

						  <h3 id="h-zásobník_forth-s-pracovním_prostorem_pro_aritmetiku"><span id="Zásobník_forth8217s_pracovním_prostorem_pro_aritmetiku">Zásobník: Pracovní prostor jazyka Forth pro aritmetiku</span></h3>
                           <p>Počítač by nebyl moc užitečný, kdyby neuměl aritmetiku. Pokud jste nikdy předtím nestudovali počítače, může vám připadat docela úžasné, že počítač (nebo dokonce kapesní kalkulačka) vůbec umí aritmetiku. V této knize nemůžeme citovat všechny mechanismy, ale věřte, že to není žádný zázrak.</p>
                           <p>Obecně počítače provádějí své operace tak, že vše, co dělají, rozdělují na směšně malé kousky informací a směšně jednoduché věci. Pro nás dva je "3 + 4" prostě "7", aniž bychom se nad tím zamysleli. Pro počítač je "3 + 4" ve skutečnosti velmi dlouhý seznam věcí, které je třeba udělat a zapamatovat.</p>
                           <p>Aniž bychom byli příliš konkrétní, řekněme, že máte kapesní kalkulačku, která očekává, že její tlačítka budou stisknuta v tomto pořadí:</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="65" src="img/ch1-eq1.gif" alt="příklad kalkulačky ve Forth" class="wp-image-378"></figure>
                           <p>aby bylo možné provést sčítání a zobrazit výsledek. Zde je zobecněný obrázek toho, co může nastat:</p>
                           <p>Když stisknete...</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="84" src="img/ch1-eq2.gif" alt="příklad kalkulačky ve Forth" class="wp-image-379"></figure>
                           <p>- číslo 3 půjde na jedno políčko (nazvané políčko A).</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="81" src="img/ch1-eq3.gif" alt="příklad kalkulačky ve Forth" class="wp-image-380"></figure>
                           <p>- zamýšlená operace (sčítání) je nějak zapamatována.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="87" src="img/ch1-eq4.gif" alt="příklad kalkulačky ve Forth" class="wp-image-381"></figure>
                           <p>- číslo 4 je uloženo na druhé políčko (nazvané políčko B).</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="91" src="img/ch1-eq5.gif" alt="příklad kalkulačky ve Forth" class="wp-image-382"></figure>
                           <p>- kalkulačka provede operaci, která je uložena v poli "následující operace", nad obsahem políček s čísly a výsledek ponechá v poli A.</p>
                           <p>Mnoho kalkulaček a počítačů přistupuje k aritmetickým úlohám podobným způsobem, jaký jsme právě popsali. Možná si to neuvědomujete, ale tyto stroje ve skutečnosti ukládají čísla na různá místa a pak s nimi provádějí operace.</p>
                           <p>V jazyce Forth existuje <em>jedno</em> centrální místo, kde jsou čísla dočasně uložena, než se s nimi začne pracovat. Toto umístění se nazývá "zásobník". Čísla se "strkají na zásobník" a <em>poté se s čísly na zásobníku provádějí operace</em>.</p>
                           <p>Nejlépe se zásobník vysvětlí, když se znázorní. Pokud do terminálu zadáte následující řádek:</p>
                           <pre class="wp-block-preformatted">3 4 + .↵<span class="output">7 ok </span></pre>
                           <p>Tady je popis toho, co se stane, klávesa po klávese.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="146" src="img/ch1-stack-push-three.gif" alt="Interpret Forthu vkládá čísla na zásobník dat" class="wp-image-383"></figure>
                           <p>Připomeňme si, že když na terminálu zadáte číslo, textový interpreter ho předá číslu <span class="defined">NUMBER</span>, které se spustí na nějaké místo. Tímto místem, jak lze nyní říci, je zásobník. Stručně řečeno, když z terminálu zadáte číslo tři, vložíte ho na zásobník.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="145" src="img/ch1-stack-push-four.gif" alt="Interpret Forthu umístí čísla na zásobník dat" class="wp-image-384"></figure>
                           <p>Nyní čtyřka půjde na "vrchol" zásobníku a zatlačí trojku směrem dolů.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="151" src="img/ch1-stack-pop-four.gif" alt="Interpret Forth používá čísla ze zásobníku dat" class="wp-image-385"></figure>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="136" src="img/ch1-stack-pop-three.gif" alt="ch1-stack-pop-three" class="wp-image-386"></figure>
                           <p>Další slovo ve vstupním proudu <em>může</em> být nalezeno ve slovníku. <span class="defined">+</span> bylo dříve definováno jako "vezmi dvě horní čísla ze zásobníku, sečti je a výsledek strč zpět na zásobník". </p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="137" src="img/ch1-stack-print-top.gif" alt="Sčítání: Interpret Forthu umístí výsledek na zásobník dat" class="wp-image-387"></figure>
                           <p>Další slovo, <span class="defined">.</span>, se rovněž nachází ve slovníku. Předtím bylo definováno tak, aby se číslo odebralo ze zásobníku a vypsalo se na terminál.</p>
                           <h3 id="h-postfix-power"><span id="Postfix_Power">Síla postfixu</span></h5>
                           <p>Teď počkejte, řeknete si. Proč po vás Forth chce, abyste psali</p>
                           <pre class="wp-block-preformatted">3 4 +</pre>
                           <p>namísto</p>
                           <pre class="wp-block-preformatted">3 + 4</pre>
                           <p>co je většině lidí známější?</p>
                           <p>Forth používá "postfixový" zápis (tak se nazývá proto, že operátor je připojen <em>za</em> čísly), nikoli "infixový" zápis (tak se nazývá proto, že operátor je připojen <em>mezi</em> čísly), aby všechna slova, která "potřebují" čísla, je mohla získat ze <abbr title="Pro znalce kapesních kalkulaček: Kalkulátory Hewlett-Packard vyšší třídy jsou vybaveny zásobníkem a postfixovou aritmetikou.">zásobníku</abbr>."</p>
                           <p>Například:</p>
                           <ul>
                              <li>slovo <span class="defined">+</span> vezme dvě čísla ze zásobníku a sečte je;</li>
                              <li>slovo <span class="defined">.</span> vezme ze zásobníku jedno číslo a vypíše je;</li>
                              <li>slovo <span class="defined">SPACES</span> vezme jedno číslo ze zásobníku a vypíše tolik mezer;</li>
                              <li>slovo <span class="defined">EMIT</span> vezme číslo, které představuje znak, a vypíše tento znak;</li>
                              <li>dokonce slovo STARS, které jsme si sami definovali, vezme číslo ze zásobníku a vypíše tolik hvězdiček.</li>
                           </ul>
                           <p>Když jsou <em>všechny</em> operátory definovány tak, aby pracovaly s hodnotami, které jsou již na zásobníku, zůstává interakce mezi mnoha operacemi jednoduchá, i když se program stane složitým.</p>
                           <p>Předtím jsme upozornili, že Forth umožňuje provést slovo jedním ze dvou způsobů: prostým pojmenováním, nebo vložením do definice jiného slova a pojmenováním <em>tohoto slova</em>. Postfix je součástí toho, co to umožňuje.</p>
                           <p>Předpokládejme jako příklad, že chceme slovo, které vždy přičte číslo 4 k jakémukoli číslu na zásobníku (pouze pro ilustraci naší myšlenky). Nazvěme toto slovo</p>
                           <pre class="wp-block-preformatted">FOUR-MORE</pre>
                           <p>Mohli bychom ho definovat takto:</p>
                           <p>a otestovat ho takto:</p>
                           <pre class="wp-block-preformatted">: FOUR-MORE 4 + ;↵</pre>
                           <p>a otestovat pomocí:</p>
                           <pre class="wp-block-preformatted">3 FOUR-MORE .↵<span class="output">7 ok </span></pre>
                           <p>a ještě jednou:</p>
                           <pre class="wp-block-preformatted">-10 FOUR-MORE .↵<span class="output">-6 ok </span></pre>
                           <p>Číslo "4" <em>uvnitř</em> definice přejde na zásobník, stejně jako kdyby byla mimo definici. Pak <span class="defined">+</span> sečte obě čísla na zásobníku. Protože <span class="defined">+</span> pracuje vždy na zásobníku, je mu jedno, že "4" pochází zevnitř definice a trojka zvenčí.</p>
                           <p>Jakmile začneme uvádět složitější příklady, bude vám hodnota zásobníku a postfixové aritmetiky stále zřejmější. Čím více operátorů je zapojeno, tím důležitější je, aby spolu všechny dokázaly "komunikovat".</p>
                           <h3 id="h-keep-track-of-your-stack"><span id="Keep_Track_of_Your_Stack">Hleďte si svého zásobníku</span></h3>
                           <p>Právě jsme začali demonstrovat filozofii zásobníku a postfixového zápisu. Než však budeme pokračovat, podívejme se blíže na zásobník v akci a zvykněme si na jeho zvláštnosti.</p>
                           <p>Forthovský zásobník je popsán jako poslední dovnitř, první ven - "last-in, first-out" (LIFO). Z předchozího obrázku je patrné, proč tomu tak je. Nejdříve byla na zásobník vložena trojka, poté na něj byla vložena čtyřka. Později sčítací stroj čtyřku nejdříve odebral, protože byla nahoře. Odtud "poslední dovnitř, první ven".</p>
                           <p>Všeobecně platí, že jedinou dostupnou hodnotou v daném okamžiku je horní hodnota. Pro další demonstraci použijme jinou operaci, a to <span class="defined">.</span>. Pamatujte si, že každé <span class="defined">.</span> odstraní ze zásobníku jedno číslo a vypíše ho. Čtyři tečky tedy odstraní čtyři čísla a vytisknou je.</p>
                           <pre class="wp-block-preformatted">2 4 6 8 . . . .↵<span class="output">8 6 4 2 ok </span></pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="128" src="img/ch1-push-2468.gif" alt="Forth vkládá hodnoty na zásobník dat" class="wp-image-388"></figure>
                           </div>
                           <p>Systém čte vstup zleva doprava a postupně provádí jednotlivá slova.</p>
                           <ul>
                              <li>Při vstupu skončí nejpravější hodnota na obrazovce na <em>vrcholu</em> zásobníku.</li>
                              <li>Pro výstup se nejpravější hodnota na obrazovce dostala ze <em>spodku</em> zásobníku.</li>
                           </ul>
                           <p>Podívejme se, do jakých problémů se můžeme dostat. Typ:</p>
                           <pre class="wp-block-preformatted">10 20 30 . . . .</pre>
                           <p>(to jsou <em>čtyři</em> tečky) a pak RETURN. Zobrazí se:</p>
                           <pre class="wp-block-preformatted">10 20 30 . . . .↵<span class="output">30 20 10 0 Stack empty </span></pre>
                           <p>Každá <abbr title="Pro zvídavé: Tečka vlastně vždy vypíše to, co je nahoře, takže pokud na zásobníku nic není, vypíše to, co je těsně pod zásobníkem, což je obvykle nula. Teprve pak je zjištěna chyba; na obrazovku je vráceno chybné slovo (v tomto případě tečka) a následuje &#39;chybové hlášení.&#39;">tečka</abbr> odstraní jednu hodnotu. Čtvrtá tečka zjistila, že na zásobníku nezbyla žádná hodnota, kterou by bylo možné poslat do terminálu, a sdělila to.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="220" height="130" src="img/ch1-stack-empty.gif" alt="stack underflow in Forth - empty stack, underflow" class="wp-image-389"></figure>
                           </div>
                           <p>Tato chyba se nazývá "podtečení zásobníku". (Všimněte si, že podtečení zásobníku <em>není</em> "ok")</p>
                           <p>Opačný stav, kdy se zásobník zcela zaplní, se nazývá "přetečení zásobníku". Zásobník je však tak hluboký, že by tento stav neměl nikdy nastat, s výjimkou případů, kdy jste udělali něco strašně špatného.</p>
                           <p>Důležité je sledovat "zásobníkový efekt" nových slov, tj. druh čísel, která musí mít slovo na zásobníku, než ho provedete, a druh čísel, která po něm na zásobníku zůstanou.</p>
                           <p>Pokud si budete průběžně vést seznam nově vytvořených slov s jejich významy, můžete vy nebo kdokoli jiný snadno pochopit operace se slovy. Ve Forthu se takový seznam nazývá "glosář".</p>
                           <p>Pro vizuální sdělení zásobníkových efektů používají programátoři jazyka Forth ve svých glosářích nebo tabulkách slov tradičně speciální zápis. Zápis zásobníku vám nyní představíme, abyste jej měli zažitý, až začnete číst další kapitolu.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="220" height="160" src="img/ch1-comment.gif" alt="Přidávání komentářů ke kódu ve Forthu" class="wp-image-390"></figure>
                           </div>
                           <p>Tady je základní formát:</p>
                           <pre class="wp-block-preformatted">( před -- po )</pre>
                           <p>Pomlčka odděluje věci, které mají být na zásobníku (před provedením slova), od věcí, které tam zůstanou po něm. Například zde je zápis zásobníku pro slovo <span class="defined">.</span>:</p>
                           <pre class="wp-block-preformatted">.   ( n -- )</pre>
                           <p>(Písmeno "n" znamená "číslo".) To ukazuje, že . očekává jedno číslo na zásobníku (před) a ponechává <em>žádné</em> číslo na zásobníku (po).</p>
                           <p>Tady je zápis zásobníku pro slovo <span class="defined">+</span>.</p>
                           <pre class="wp-block-preformatted">+ ( n1 n2 -- sum )</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="260" height="124" src="img/ch1-comment-stack-top.gif" alt="Zápis zásobníkového diagramu ve Forthu" class="wp-image-391"></figure>
                           </div>
                           <p>Pokud je n více než jedno, číslujeme je postupně n1, n2, n3 atd. Čísla 1 a 2 se <em>nevztahují</em> k pozici na zásobníku. Pozice na zásobníku je označena pořadím, v jakém jsou položky zapsány; <em>nejpravější</em> položka na obou stranách pomlček&nbsp;je <em>nejvyšší</em> položkou na zásobníku. Například v zápisu zásobníku <span class="defined">+</span> je n2 nahoře:</p>
                           <p>Protože už to asi máte v malíčku, můžeme někdy vynechat symbol ↵. Většinou poznáte, kde máte stisknout "return", protože odpověď počítače je vždy formátována <span class="output">takto</span>.</p>
                           <h3 id="h-souhrn kapitoly"><span id="Souhrn kapitoly">Souhrn kapitoly</span></h3>
                           <h4 id="h-slovy-na-úvod"><span id="Slova-na-úvod">Slovy na úvod</span></h4>
                           <p>Tady je seznam slov jazyka Forth, která jste se dosud naučili, včetně jejich zásobníkového zápisu ("n" znamená číslo; "c" znamená znak):</p>
                           <div class="table-responsive">
                              <table style="width:100%; " class="easy-table easy-table-default stack">
                                 <thead>
                                    <tr>
                                       <th style="width:30%;"><code>: xxxx yyy ;</code></th>
                                       <th><code>( -- )</code></th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr>
                                       <td colspan="2">Vytvoří novou definici s názvem <em>xxx</em> a skládající se ze slova nebo slov <em>yyy</em>.</td>
                                    </tr>
                                    <tr>
                                       <td><code>CR</code></td>
                                       <td><code>( -- )</code></td>
                                    </tr>
                                    <tr>
                                       <td colspan="2">Provede odřádkování na terminálu.</td>
                                    </tr>
                                    <tr>
                                       <td><code>SPACES</code></td>
                                       <td><code>( n -- )</code></td>
                                    </tr>
                                    <tr>
                                       <td colspan="2">Vytiskne daný počet mezer na terminálu.</td>
                                    </tr>
                                    <tr>
                                       <td><code>SPACE</code></td>
                                       <td><code>( -- )</code></td>
                                    </tr>
                                    <tr>
                                       <td colspan="2">Vytiskne jednu mezeru na terminálu.</td>
                                    </tr>
                                    <tr>
                                       <td><code>EMIT</code></td>
                                       <td><code>( c -- )</code></td>
                                    </tr>
                                    <tr>
                                       <td colspan="2">Přenáší znak na výstupní zařízení.</td>
                                    </tr>
                                    <tr>
                                       <td><code>." xxx"</code></td>
                                       <td><code>( -- )</code></td>
                                    </tr>
                                    <tr>
                                       <td colspan="2">Vytiskne řetězec znaků <em>xxx</em> na terminálu. Znak " ukončuje řetězec.</td>
                                    </tr>
                                    <tr>
                                       <td><code>+</code></td>
                                       <td><code>( n1 n2 -- sum )</code></td>
                                    </tr>
                                    <tr>
                                       <td colspan="2">Sčítá.</td>
                                    </tr>
                                    <tr>
                                       <td><code>.</code></td>
                                       <td><code>( n -- )</code></td>
                                    </tr>
                                    <tr>
                                       <td colspan="2">Vytiskne číslo, za kterým následuje jedna mezera.</td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <p></p>
                           <p>V příští kapitole si povíme o tom, jak přimět počítač, aby prováděl některé náročnější aritmetické operace.</p>
                           <h4 id="h-review-of-terms"><span id="Review_of_Terms">Přehled pojmů</span></h4>
                           <dl>
                              <dt>Kompilovat</dt>
                              <dd>vytvoření slovníkového hesla v paměti počítače ze zdrojového textu (zapsané podoby definice). Odlišuje se od "provést". </dd>
                              <dt>Slovník</dt>
                              <dd>ve Forthu seznam slov a definic zahrnující jak "systémové" definice (předdefinované), tak "uživatelské" definice (které si vymyslíte). Slovník se nachází v paměti počítače ve zkompilované podobě.</dd>
                              <dt>Vykonat</dt>
                              <dd>provádět. Konkrétně provést slovo znamená provést operace uvedené ve zkompilované definici slova.</dd>
                              <dt>Rozšiřitelnost</dt>
                              <dd>vlastnost počítačového jazyka, která umožňuje programátorovi přidávat nové funkce nebo upravovat stávající.</dd>
                              <dt>Glosář</dt>
                              <dd>seznam slov definovaných v jazyce Forth s uvedením jejich zásobníkových efektů a vysvětlením, co dělají, který slouží jako reference pro programátory.</dd>
                              <dt>Infixový zápis</dt>
                              <dd>způsob zápisu operátorů mezi operandy, které ovlivňují, jako například "2 + 5". </dd>
                              <dt>Vstupní proud</dt>
                              <dd>text, který má být přečten textovým interpretem. Může to být text, který jste právě zadali na terminálu nebo text uložený na disku. </dd>
                              <dt>Interpretovat</dt>
                              <dd>(pokud se jedná o textový interpret Forthu) přečíst vstupní proud a pak najít každé slovo ve slovníku, nebo pokud to nejde, převést ho na číslo.</dd>
                              <dt>LIFO</dt>
                              <dd>(last-in, first-out) typ zásobníku, který Forth používá. Plechovka s tenisovými míčky je struktura LIFO; poslední vhozený míček je ten, který musíte odstranit jako první.</dd>
                              <dt>Postfixový zápis</dt>
                              <dd>způsob zápisu operátorů za operandy, které ovlivňují, jako například "2 5 +" pro "2 + 5". Známý také jako obrácená polská notace.</dd>
                              <dt>Stack</dt>
                              <dd>ve Forthu oblast paměti, která je řízena tak, že data mohou být ukládána nebo odstraňována způsobem "poslední dovnitř, první ven" (LIFO).</dd>
                              <dt>Přetečení zásobníku</dt>
                              <dd>chybový stav, který nastane, když je celá oblast paměti povolená pro zásobník zcela zaplněna daty.</dd>
                              <dt>Podtečení zásobníku</dt>
                              <dd>chybový stav, který nastane, když operace očekává hodnotu na zásobníku, ale na zásobníku nejsou žádná platná data.</dd>
                              <dt>Slovo</dt>
                              <dd>ve Forthu název definice.</dd>
                           </dl>
                           <h3 id="h-problems-chapter-1"><span id="Problems_Chapter_1">Problémy - kapitola 1</span></h3>
                           <p>Poznámka: než začnete řešit tyto úlohy, zapamatujte si tato jednoduchá pravidla:</p>
                           <ul>
                              <li>Každé <span class="defined">:</span> potřebuje <span class="defined">;</span></li>
                              <li>Každé <span class="defined">."</span> potřebuje <span class="defined">"</span></li>
                           </ul>
                           <h4 id="h-problem-1">Problém 1: </h4>
                           <p>Definujte slovo GIFT, které po spuštění vypíše název nějakého dárku. Můžete například zkusit:</p>
                           <pre class="wp-block-preformatted">: GIFT   ." Bookends  " ;</pre>
                           <p>Nyní definujte slovo jménem GIVER, které vypíše křestní jméno nějaké osoby. Nakonec definujte slovo s názvem THANKS, které obsahuje nová slova Forth GIFT a GIVER a vypíše zprávu přibližně takto:</p>
                           <pre class="wp-block-preformatted"><span class="output">Dear Stephanie,</span> <span class="output">thanks for the Bookends. ok</span></pre>
                           <h4 id="h-problém-2">Problém 2: </h4>
                           <p>Zdefinujte slovo s názvem TEN.LESS, které vezme číslo na zásobníku, odečte deset a vrátí odpověď na zásobník. (Nápověda: můžete použít <span class="defined">+</span>).</p>
                           <h4 id="h-problem-3">Problém 3:</h4>
                           <p>Po zadání slov v Problému 1 zadejte novou definici pro GIVER, abyste vypsali jméno někoho jiného, a poté znovu spusťte příkaz THANKS. Můžete vysvětlit, proč THANKS stále vypisuje jméno prvního dárce?</p>
                           <div class="wp-block-genesis-blocks-gb-accordion gb-font-size-18 gb-block-accordion">
                              <details>
                                 <summary class="gb-accordion-title">Odpovědi<br></summary>
                                 <div class="gb-accordion-text">
                                    <p>Odpověď na problém 1:</p>
                                    <pre class="wp-block-preformatted">: GIFT   ." chocolate" ;: GIVER   ." Mum" ;<br>: THANKS   CR  ." Dear " GIVER ." ,"   CR  ."    Thanks for the " GIFT ." . " ;</pre>
                                    <p>Odpověď na problém 2:</p>
                                    <pre class="wp-block-preformatted">: TEN-LESS ( n -- n-10 ) -10 + ;<br>: TEN-LESS ( n -- n-10 ) 10 - ;</pre>
                                    <p>Odpověď na problém 3:</p>
                                    <p>Protože staré THANKS má již ve slovníku zkompilováno staré GIVER.<br></p>
                                 </div>
                              </details>
                           </div>
                        </div>
                     </div>
                  </article>
               </main>
            </div>
         </div>
      </div>
      <div class="site grid-container container hfeed grid-parent" id="page">
         <div class="site-content" id="content">
            <div class="content-area grid-parent mobile-grid-100 grid-70 tablet-grid-70" id="primary">
               <main class="site-main" id="main">
                  <article id="post-313" class="post-313 page type-page status-publish" itemtype="https://schema.org/CreativeWork" itemscope="">
                     <div class="inside-article">
                        <header class="entry-header" aria-label="Content">
                           <h2 class="entry-title" itemprop="headline">2. Jak získat výsledky</h2>
                        </header>
                        <div class="entry-content" itemprop="text">
                           <p>V této kapitole se vrhneme rovnou na některá specifika, která potřebujete znát, než budeme pokračovat. Konkrétně si představíme některé aritmetické instrukce, abyste byli schopni psát matematické rovnice v jazyce Forth.</p>
                           <h3><span id="Forth_Arithmetic_Calculator_Style">Aritmetika Forth - styl kalkulačky</span></h3>
                           <p>Na rozdíl od kalkulaček nemají počítačové terminály speciální klávesy pro násobení nebo dělení. Místo toho používáme * a /.</p>
                           <p>Tady jsou čtyři nejjednodušší <abbr title="Pokud matematika není vaše parketa: Rádi bychom vám připomněli, že celá čísla jsou celá čísla, například ... -3, -2, -1, 0, 1, 2, 3, ... Celočíselná aritmetika (logicky vzato) je aritmetika, která se zabývá pouze celými čísly, nikoli čísly s desetinnou čárkou, například 2.71.">operátory celočíselné aritmetiky</abbr> v jazyce Forth:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>+</td>
                                    <td>( n1 n2 - sum )</td>
                                    <td>Sčítá</td>
                                 </tr>
                                 <tr>
                                    <td>-</td>
                                    <td>( n1 n2 - diff )</td>
                                    <td>Odčítá (n1-n2)</td>
                                 </tr>
                                 <tr>
                                    <td>*</td>
                                    <td>( n1 n2 - prod )</td>
                                    <td>Násobí</td>
                                 </tr>
                                 <tr>
                                    <td>/</td>
                                    <td>( n1 n2 - quot )</td>
                                    <td>Dělí (n1/n2)</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>V první kapitole jsme se dozvěděli, že můžeme sečíst dvě čísla tak, že je obě vložíme na zásobník, pak provedeme slovo <span class="defined">+</span> a nakonec provedeme slovo <span class="defined">.</span> (tečka), aby se nám výsledek vypsal na terminál.</p>
                           <pre class="wp-block-preformatted">17 5 + .↵<span class="output">22 ok </span>

</pre>
                           <p>Tuto metodu můžeme použít se všemi aritmetickými operátory jazyka Forth. Jinými slovy, jazyk Forth můžeme používat jako kalkulačku k získání odpovědí, a to i bez psaní "programu". Vyzkoušejte si úlohu na násobení:</p>
                           <pre class="wp-block-preformatted">7 8 * .↵<span class="output">56 ok </span>

</pre>
                           <p>Již jsme viděli, že operátor se nachází za čísly. V případě odčítání a dělení však musíme brát v úvahu také <em>pořadí čísel</em> ("7 - 4" není totéž jako "4 - 7").</p>
                           <p>Zapamatujte si toto pravidlo: <em>Chcete-li převést na postfix, jednoduše přesuňte operátor na konec výrazu.</em></p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td><strong>Infix</strong></td>
                                    <td><strong>Postfix</strong></td>
                                 </tr>
                                 <tr>
                                    <td>3 + 4</td>
                                    <td>3 4 +</td>
                                 </tr>
                                 <tr>
                                    <td>500 - 300</td>
                                    <td>500 300 -</td>
                                 </tr>
                                 <tr>
                                    <td>6 x 5</td>
                                    <td>6 5 *</td>
                                 </tr>
                                 <tr>
                                    <td>20 / 4</td>
                                    <td>20 4 /</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Takže k řešení úlohy na odčítání:</p>
                           <pre class="wp-block-preformatted">7 - 4 =
</pre>
                           <p>jednoduše zadejte</p>
                           <pre class="wp-block-preformatted">7 4 - .↵<span class="output">3 ok </span>
</pre>
                           <div class="sc-info-box normal">
                              <h3><span id="Pro_dobrodružné_nováčky_sedící_na_terminálu">Pro dobrodružné nováčky sedící u terminálu</span></h5>
                              Pokud patříte k lidem, kteří rádi blbnou a přicházejí na věci sami, aniž by si přečetli tuto knihu, pak určitě objevíte pár podivností. Zaprvé, jak jsme si řekli, tyto operátory jsou <em>celočíselné operátory</em>. To znamená nejen to, že nemůžete provádět výpočty s desetinnými hodnotami, jako např.
                              <pre>10.00 2.25 +</pre>
                              znamená to také, že můžete získat pouze celočíselné výsledky, jako v
                              <pre>21 4 / .↵<span class="output">5 ok</span> místo <span class="output">5.25 ok </span>
</pre>
                              Další věcí je, že pokud se pokusíte násobit:
                              <pre>10000 10 *
</pre>
                              nebo nějaká podobně velká čísla, dostanete šílenou odpověď. Předem vám tedy říkáme, že s dosud představenými operátory a s <span class="defined">.</span> pro vypisování výsledků nemůžete mít žádná čísla větší než +32767 nebo menší než -32768 (tyto rozsahy se mohou lišit podle implementace). Čísla v tomto rozsahu se nazývají "single-length zaménková čísla".
                              Všimněte si, že v seznamu slov jazyka Forth o několik stránek zpět je písmeno "n", které znamená "číslo". Protože jazyk Forth používá čísla o jedné délce častěji než jiné typy čísel, znamená písmeno "n", že číslo musí být jednočíselné. A ano, existují i další operátory, které tento rozsah rozšiřují ("double-length" operátory, které jsou označeny písmenem "d").
                              Všechny tyto záhady budou časem vysvětleny, takže zůstaňte naladěni.
                           </div>
                           <p>Pořadí čísel zůstává stejné. Zkusíme si úlohu s dělením:</p>
                           <pre class="wp-block-preformatted">20 4 / .↵<span class="output">5 ok </span>

</pre>
                           <p>Slovo <span class="defined">/</span> je definováno tak, že dělí druhé číslo na zásobníku číslem horním.</p>
                           <figure class="wp-block-image"><img width="400" height="330" src="./02-Stack-Manipulation Operators_files/ch2-samurai-divider.gif" alt="Aritmetika Forth - dělení pomocí zásobníku" class="wp-image-393"></figure>
                           <p>Co uděláte, když máte ve výrazu více než jeden operátor, například:</p>
                           <pre class="wp-block-preformatted">4 + (17 * 12)
</pre>
                           <p>Vezměme to krok za krokem: závorky vám říkají, že máte nejprve vynásobit sedmnáct dvanácti, <em>poté</em> přičíst čtyři. Ve Forthu byste tedy napsali:</p>
                           <pre class="wp-block-preformatted">17 12 * 4 + .↵<span class="output">208 ok </span>
</pre>
                           <p>a tady je důvod:</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="139" src="./02-Stack-Manipulation Operators_files/ch2-bunny-multiply.gif" alt="Aritmetika v programátoru Forth - reverzní polština" class="wp-image-394"></figure>
                           <p>17 a 12 přejdou na zásobník. <span class="defined">*</span> je vynásobí a vrátí výsledek.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="145" src="./02-Stack-Manipulation Operators_files/ch2-stack-add.gif" alt="Sčítání v jazyce Forth - zásobník" class="wp-image-395"></figure>
                           <p>Poté se čtyřka dostane na zásobník nad číslo 204. <span class="defined">+</span> vytlačí z garáže sčítací stroj, který je sečte dohromady, přičemž vrátí pouze výsledek.</p>
                           <p>Nebo předpokládejme, že chcete sečíst pět čísel. Ve Forthu to můžete udělat takto:</p>
                           <pre class="wp-block-preformatted">17 20 + 132 + 3 + 9 + .↵<span class="output">181 ok </span>
</pre>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="212" src="./02-Stack-Manipulation Operators_files/ch2-stack-add-2.gif" alt="Sčítání ve Forthu - pomocí zásobníku dat" class="wp-image-396"></figure>
                           <p>Tady je zajímavý problém:</p>
                           <pre class="wp-block-preformatted">(3 + 9) * (4 + 6)
</pre>
                           <p>Pro její vyřešení musíme nejprve přičíst tři k devíti, pak přičíst čtyři k šesti a nakonec oba součty vynásobit. Ve Forthu můžeme napsat</p>
                           <pre class="wp-block-preformatted">3 9 + 4 6 + * .↵<span class="output">120 ok </span>

</pre>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="104" src="./02-Stack-Manipulation Operators_files/ch2-stack-add-3.gif" alt="Násobení ve Forthu používá zásobník" class="wp-image-397"></figure>
                           <p>Všimněte si, že jsme velmi vhodně uložili součet dvanáct na zásobník, zatímco jsme se věnovali činnosti přičítání čtyř k šesti.</p>
                           <p>Pamatujte, že se zatím nezabýváme zápisem definic. Prostě používáme jazyk Forth jako kalkulačku.</p>
                           <p>Jestliže jste jako většina začátečníků, pravděpodobně byste si rádi vyzkoušeli několik cvičných úloh, dokud se s postfixovým zápisem nebudete cítit lépe.</p>
                           <h3><span id="Postfix_Practice_Problems_Quizzie_2-a">Postfixové cvičné úlohy (kvíz 2-a)</span></h5>
                           <p>Převeďte následující infixové rovnice na postfix "ve stylu kalkulačky". Například,</p>
                           <pre class="wp-block-preformatted">ab + c

</pre>
                           <p>by se stalo</p>
                           <pre class="wp-block-preformatted">a b * c +

</pre>
                           <ol>
                              <li><code>c(a+b)</code></li>
                              <li><code>(3a - b) / 4 + c</code></li>
                              <li><code>(0,5 ab) / 100</code></li>
                              <li><code>(n + 1) / n</code></li>
                              <li><code>x(7x + 5)</code></li>
                           </ol>
                           <p>Převeďte následující postfixové výrazy na infixové:</p>
                           <ol class="sf-numbered">
                              <li><code>a b - b a + /</code></li>
                              <li><code>a b 10 * /</code></li>
                           </ol>
                           <div class="wp-block-genesis-blocks-gb-accordion gb-block-accordion gb-font-size-18">
                              <details>
                                 <summary class="gb-accordion-title">Odpovědi ke kvízu 2-a</summary>
                                 <div class="gb-accordion-text">
                                    <p>Infix k postfixu:</p>
                                    <pre class="wp-block-preformatted">1. a b + c * nebo<br> c a b + * <br><br>2. 3 a * b - 4 / c +<br><br>3. a b * 100 / 2/ nebo<br> a b * 200 /<br><br>4. n 1 + n /<br><br>5. 7 x * 5 + x *</pre>
                                    <p>Postfix na infix:</p>
                                    <pre class="wp-block-preformatted">1. a - b<br>   -----<br>   b + a<br><br>2. a<br>   ---<br>   10b</pre>
                                 </div>
                              </details>
                           </div>
                           <h3><span id="Forth_Arithmetic_Definition_Style">Forthovská aritmetika - vytváření definic</span></h3>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="200" height="94" src="./02-Stack-Manipulation Operators_files/ch2-colon-semicolon.gif" alt="Zápis definic Forth (delimiter)" class="wp-image-398"></figure>
                           </div>
                           <p>V kapitole 1 jsme viděli, že můžeme definovat nová slova pomocí čísel a jiných předem definovaných slov. Prozkoumejme další možnosti s využitím některých nově naučených matematických operátorů.</p>
                           <p>Řekněme, že chceme převádět různé míry na palce. Víme, že</p>
                           <pre class="wp-block-preformatted">1 yard = 36 palců

</pre>
                           <p>a</p>
                           <pre class="wp-block-preformatted">1 stopa = 12 palců
</pre>
                           <p>takže můžeme definovat tato dvě slova:</p>
                           <pre class="wp-block-preformatted">: YARDS&gt;IN 36 * ;↵<span class="output">ok </span><br>: FT&gt;IN 12 * ;↵<span class="output">ok </span></pre>
                           <p>kde názvy symbolizují "yardy na palce" a "stopy na palce". Zde je jejich funkce:</p>
                           <pre class="wp-block-preformatted">10 YARDS&gt;IN .↵<span class="output">360 ok </span><br>2 FT&gt;IN .↵<span class="output">24 ok </span></pre>
                           <p>Pokud vždy chceme, aby náš výsledek byl v palcích, můžeme definovat:</p>
                           <pre class="wp-block-preformatted">: YARDS 36 * ;↵<span class="output">ok </span><br>: FEET 12 * ;↵<span class="output">ok </span><br>: INCHES ;↵<span class="output">ok </span></pre>
                           <p>Tak, abychom mohli použít větu</p>
                           <pre class="wp-block-preformatted">10 YARDS 2 FEET + 9 INCHES + .↵<span class="output">393 ok </span>

</pre>
                           <p>Všimněte si, že slovo INCHES nedělá nic jiného, než že připomíná lidskému uživateli, k čemu je devět. Pokud si chceme opravdu vymýšlet, můžeme přidat tyto tři definice:</p>
                           <pre class="wp-block-preformatted">: YARD YARDS ;↵<span class="output">ok </span><br>: FOOT FEET ;↵<span class="output">ok </span><br>: INCH ;↵<span class="output">ok </span></pre>
                           <p>takže uživatel může zadat jednotný tvar libovolného podstatného jména a stále dostane stejný výsledek:</p>
                           <pre class="wp-block-preformatted">1 YARD 2 FEET + 1 INCH + .↵<span class="output">61 ok </span><br>2 YARDS 1 FOOT + .↵<span class="output">84 ok </span></pre>
                           <p>Dosud jsme definovali pouze slova, jejichž definice obsahují jeden matematický operátor. Je však naprosto možné vložit do definice mnoho operátorů, pokud to potřebujete.</p>
                           <p>Řekněme, že chceme slovo, které vypočítá součet pěti čísel na zásobníku. O několik stránek zpět jsme pět čísel sečetli takto:</p>
                           <pre class="wp-block-preformatted">17 20 + 132 + 3 + 9 + .↵<span class="output">181 ok </span>

</pre>
                           <p>Můžeme také zadat</p>
                           <pre class="wp-block-preformatted">17 20 132 3 9 + + + + .↵<span class="output">181 ok </span>

</pre>
                           <div class="sc-info-box normal full">
                              <h3><span id="Pro_Semantic_Freaks">Pro sémantické fajnšmekry</span></h5>
                              V matematice se slovem "argument" označuje nezávislá proměnná funkce. Počítačoví lingvisté si tento termín vypůjčili pro označení čísel, s nimiž operují operátory. Vypůjčili si také slovo "parametry", aby popsali v podstatě totéž.
                           </div>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="309" src="./02-Stack-Manipulation Operators_files/ch2-stack-add-4.gif" alt="Operátory Forth - parametry" class="wp-image-399"></figure>
                           <p>Dostaneme stejnou odpověď, přestože jsme všechna čísla shlukli do jedné skupiny a všechny operátory do jiné skupiny. Naši definici můžeme zapsat takto:</p>
                           <pre class="wp-block-preformatted">: 5#SUM + + + + ;↵<span class="output"> ok </span>

</pre>
                           <p>a provést ji takto:</p>
                           <pre class="wp-block-preformatted">17 20 132 3 9 5#SUM .↵<span class="output">181 ok </span>
</pre>
                           <p>Pokud bychom si 5#SUM ponechali pro budoucí použití, mohli bychom jej zapsat do našeho stále se rozrůstajícího slovníku spolu s poznámkou, že "očekává pět argumentů" na zásobníku, které sečte.</p>
                           <h3><span id="Pro_začátečníky, kteří mají rádi slovní úlohy">Pro začátečníky, kteří mají rádi slovní úlohy</span></h5>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="200" height="160" src="./02-Stack-Manipulation Operators_files/ch2-jet-plane.gif" alt="Příklad - operátory manipulace se zásobníkem v kódu Forth" class="wp-image-400"></figure>
                           </div>
                           <p>
                              Pokud tryskové letadlo letí průměrnou rychlostí 600 km/h a pokud letí s větrem v zádech o rychlosti 25 km/h, jakou vzdálenost urazí za pět hodin?
                              Pokud definujeme
                           </p>
                           <pre class="wp-block-preformatted">: FLIGHT-DISTANCE   + * ;
</pre>
                           <p>
                              můžeme zadat
                           </p>
                           <pre class="wp-block-preformatted">5 600 25 FLIGHT-DISTANCE .↵<span class="output">3125 ok </span>
</pre>
                           <p>
                              Zkuste to s různými hodnotami, včetně protivětru (záporné hodnoty).
                           </p>
                           <p>Tady je další rovnice, pro kterou můžete napsat definici:</p>
                           <pre class="wp-block-preformatted">(a + b) * c
</pre>
                           <p>Jak jsme viděli v kvízu 2-a, tento výraz lze zapsat postfixem jako</p>
                           <pre class="wp-block-preformatted">c a b + *
</pre>
                           <p>Takto bychom mohli zapsat naši definici</p>
                           <pre class="wp-block-preformatted">: SOLUTION + * ;↵<span class="output">ok </span>
</pre>
                           <p>pokud se ujistíme, že argumenty zadáváme ve správném pořadí:</p>
                           <pre class="wp-block-preformatted">c a b SOLUTION

</pre>
                           <h3><span id="Definiční_styly_praktických_problémů_Quizzie_2-b">Praktické úlohy vytváření definic (kvíz 2-b)</span></h5>
                           <p>Převeďte následující infixové výrazy na definice jazyka Forth a ukažte pořadí zásobníku požadované vašimi definicemi. Protože se jedná o kvíz 2-b, můžete své definice pojmenovat 2B1, 2B2 atd.</p>
                           <p>ab + c by se stane <code>: 2B1 * + ;</code></p>
                           <p>který očekává toto pořadí zásobníku: <code>( c b a -- result)</code></p>
                           <ol class="sf-numbered">
                              <li><code>(a - 4b) / 6 + c</code></li>
                              <li><code>a / (8b)</code></li>
                              <li><code>0.5 ab / 100</code></li>
                              <li><code>a(2a + 3)</code></li>
                              <li><code>(a - b) / c</code></li>
                           </ol>
                           <div class="wp-block-genesis-blocks-gb-accordion gb-block-accordion gb-font-size-18">
                              <details>
                                 <summary class="gb-accordion-title">Odpovědi ke kvízu 2-b</summary>
                                 <div class="gb-accordion-text">
                                    <pre class="wp-block-preformatted">1.<br>: 2B2 ( c a b -- result ) 4 * - 6 / + ;<br><br>2.<br>: 2B3 ( a b -- result ) 8 * / ;<br><br>3.<br>: 2B4 ( a b -- result ) * 200 / ;<br><br>4.<br>: 2B5 ( a a -- result ) 2* 3 + * ;
                                    <p>5.&nbsp;Pokud jste si řekli, že tohle je nemožné, máte pravdu!
   Alespoň bez operátorů pro manipulaci se zásobníkem, 
   které si představíme velmi brzy.</p></pre>
                                 </div>
                              </details>
                           </div>
                           <h3><span id="The_Division_Operators">Operátory dělení</span></h3>
                           <p>Slovo / je nejjednodušší operátor dělení jazyka Forth. <em>Lomítko</em> dodává pouze kvocient; jakýkoli zbytek se ztrácí. Pokud zadáte:</p>
                           <pre class="wp-block-preformatted">22 4 / .↵<span class="output">5 ok </span>

</pre>
                           <p>získáte pouze kvocient pět, nikoliv zbytek dva.</p>
                           <p>Pokud máte na mysli operátor procenta kapesní kalkulačky, pak pět není úplná odpověď.</p>
                           <p>Ale / je pouze jedním z několika operátorů dělení, které poskytuje jazyk Forth, aby vám umožnil flexibilně říci počítači, co přesně chcete, aby udělal.</p>
                           <p>Řekněme například, že chcete vyřešit tento problém: "Kolik dolarových bankovek mohu dostat výměnou za 22 čtvrťáků?". Skutečná odpověď je samozřejmě přesně 5, nikoliv 5,5 mince. Počítačová směnárna by například nevěděla, jak vám dát 5,5 dolarové bankovky.</p>
                           <p>Tady jsou další dva operátory dělení ve Forthu:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>/MOD</td>
                                    <td>( n1 n2 - rem quot )</td>
                                    <td>Dělí; vrací zbytek a kvocient</td>
                                 </tr>
                                 <tr>
                                    <td>MOD</td>
                                    <td>( n1 n2 - rem )</td>
                                    <td>Dělí; vrací pouze zbytek</td>
                                 </tr>
                              </tbody>
                           </table>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="146" src="./02-Stack-Manipulation Operators_files/ch2-pronounce-2.gif" alt="Forthovo dělení a zbytky - mod, slash-mod, modulo" class="wp-image-401"></figure>
                           </div>
                           <p>Tyto operátory jsou jednak znaménkové, jednak "zkracovací". Co to znamená, si ukážeme v kapitole o počítačových číslech.</p>
                           <p>/MOD udává zbytek i kvocient; MOD (od "modulo") udává pouze zbytek. (V případě /MOD znamená zápis zásobníku v tabulce, že kvocient bude nahoře na zásobníku a zbytek dole. Nezapomeňte, že <em>nejpravější</em> představuje <em>nejvyšší</em>.)</p>
                           <p>Zkusíme první z nich:</p>
                           <pre class="wp-block-preformatted">22 4 /MOD . .↵<span class="output">5 2 ok </span>

</pre>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="169" src="./02-Stack-Manipulation Operators_files/ch2-samurai-slash-mod.gif" alt="Dělení ve Forthu, zbytky" class="wp-image-402"></figure>
                           <p>Tady /MOD provede dělení a na zásobník umístí jak kvocient, tak zbytek. První tečka vypíše kvocient, protože kvocient byl nahoře.</p>
                           <p>S tím, co jsme se dosud naučili, můžeme snadno definovat toto slovo:</p>
                           <pre class="wp-block-preformatted">: Čtvrtiny 4 /MOD . ." a "
    . ." čtvrtletí " ;

</pre>
                           <p>Takže můžete zadat:</p>
                           <pre class="wp-block-preformatted">22 QUARTERS

</pre>
                           <p>s tímto výsledkem:</p>
                           <pre class="wp-block-preformatted">22 QUARTERS↵<span class="output">5 jedniček a 2 čtvrtky ok </span>

</pre>
                           <p>Druhé slovo v tabulce, MOD, ponechává pouze zbytek. Například v:</p>
                           <pre class="wp-block-preformatted">22 4 MOD .↵<span class="output">2 ok </span>

</pre>
                           <p>dvojka je zbytek.</p>
                           <h3><span id="Stack_Maneuvers">Manévry se zásobníkem</span></h3>
                           <p>Pokud jste v minulé sadě řešili úlohu 6, zjistili jste, že infixová rovnice</p>
                           <p>(a - b) / c</p>
                           <p> nelze vyřešit pomocí definice, pokud neexistuje nějaký způsob, jak přeskládat hodnoty na zásobníku.</p>
                           <p>No, jeden způsob existuje: pomocí "operátoru manipulace se zásobníkem" zvaného SWAP.</p>
                           <h3><span id="SWAP">SWAP</span></h5>
                           <p>Slovo SWAP je definováno tak, že přepíná pořadí dvou horních položek zásobníku.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="314" src="./02-Stack-Manipulation Operators_files/ch2-swap-swap.gif" alt="stack-manipulation operators - swap" class="wp-image-403"></figure>
                           <p>Stejně jako u ostatních operátorů manipulace se zásobníkem můžete SWAP otestovat v terminálu "stylem kalkulačky"; to znamená, že nemusí být obsažen v definici.</p>
                           <p>Nejprve zadejte</p>
                           <pre class="wp-block-preformatted">1 2 . .↵<span class="output">2 1 ok </span>

</pre>
                           <p>poté znovu, tentokrát pomocí SWAP:</p>
                           <pre class="wp-block-preformatted">1 2 SWAP . .↵<span class="output">1 2 ok </span>

</pre>
                           <p>Takto lze vyřešit úlohu 6 pomocí této věty:</p>
                           <pre class="wp-block-preformatted">- SWAP /

</pre>
                           <p>s <code>( c a b -- )</code> na zásobníku.</p>
                           <p>Dáme a, b a c tyto testovací hodnoty:</p>
                           <pre class="wp-block-preformatted">a = 10

b = 4

c = 2

</pre>
                           <p>poté je vložíme na zásobník a provedeme větu takto:</p>
                           <pre class="wp-block-preformatted">2 10 4 - SWAP / .↵<span class="output">3 ok </span>

</pre>
                           <p>Zde je uveden seznam několika operátorů pro manipulaci se zásobníkem:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>SWAP</td>
                                    <td>( n1 n2 - n2 n1 )</td>
                                    <td>Převrátí dvě horní položky zásobníku</td>
                                 </tr>
                                 <tr>
                                    <td>DUP</td>
                                    <td>( n - n n )</td>
                                    <td>Duplikuje horní položku zásobníku</td>
                                 </tr>
                                 <tr>
                                    <td>OVER</td>
                                    <td>( n1 n2 - n1 n2 n1 )</td>
                                    <td>Kopíruje druhou položku na vrchol</td>
                                 </tr>
                                 <tr>
                                    <td>ROT</td>
                                    <td>( n1 n2 n3 - n2 n3 n1 )</td>
                                    <td>Otáčí třetí položku nahoru</td>
                                 </tr>
                                 <tr>
                                    <td>DROP</td>
                                    <td>( n - )</td>
                                    <td>Zruší horní položku zásobníku</td>.
                                 </tr>
                              </tbody>
                           </table>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="410" src="./02-Stack-Manipulation Operators_files/ch2-pronounce-4.gif" alt="Forth stack-manipulation operators" class="wp-image-404"></figure>
                           </div>
                           <h3><span id="DUP">DUP</span></h5>
                           <p>Další operátor manipulace se zásobníkem na seznamu, DUP, jednoduše vytvoří druhou kopii (duplikát) horní položky zásobníku.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="148" src="./02-Stack-Manipulation Operators_files/ch2-dup.gif" alt="DUP zkopíruje (duplikuje) horní položku zásobníku" class="wp-image-405"></figure>
                           <p>Příklad pokud máme na zásobníku položku "a", můžeme vypočítat:<br>a<sup>2</sup></p>
                           <p>takto:</p>
                           <pre class="wp-block-preformatted">DUP *

</pre>
                           <p>při kterém dojde k následujícím krokům:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td><strong>Operace</strong></td>
                                    <td><strong>Obsah zásobníku</strong></td>
                                 </tr>
                                 <tr>
                                    <td></td>
                                    <td>a</td>
                                 </tr>
                                 <tr>
                                    <td>DUP</td>
                                    <td>a a</td>
                                 </tr>
                                 <tr>
                                    <td>*</td>
                                    <td>a<sup>2</sup></td>
                                 </tr>
                              </tbody>
                           </table>
                           <h3><span id="OVER">OVER</span></h5>
                           <p>Nyní vám někdo řekne, abyste vyhodnotili výraz:</p>
                           <pre class="wp-block-preformatted">a * (a + b)

</pre>
                           <p>při následujícím pořadí zásobníku:</p>
                           <pre class="wp-block-preformatted">( a b -- )

</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="140" height="79" src="./02-Stack-Manipulation Operators_files/ch2-over.gif" alt="OVER - stack-manipulation operators" class="wp-image-406"></figure>
                           </div>
                           <p>Ale, říkáte, budu potřebovat nový manipulační operátor: Chci dvě kopie "a" a "a" je <em>pod</em> "b". Tady je to slovo, které potřebujete: OVER. OVER jednoduše vytvoří kopii "a" a přeskočí ji nad "b":</p>
                           <pre class="wp-block-preformatted">( a b -- a b a )

</pre>
                           <p>Nyní výraz</p>
                           <pre class="wp-block-preformatted">a * (a + b)

</pre>
                           <p>můžeme snadno zapsat</p>
                           <pre class="wp-block-preformatted">OVER + *

</pre>
                           <p>Takto se stane:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td><strong>Operace</strong></td>
                                    <td><strong>Obsah zásobníku</strong></td>
                                 </tr>
                                 <tr>
                                    <td></td>
                                    <td>a b</td>
                                 </tr>
                                 <tr>
                                    <td>OVER</td>
                                    <td>a b a</td>
                                 </tr>
                                 <tr>
                                    <td>+</td>
                                    <td>a (b+a)</td>
                                 </tr>
                                 <tr>
                                    <td>*&nbsp;</td>
                                    <td>a*(b+a)</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Při psaní rovnic ve Forthu je nejlepší je nejprve "vyfakturovat". Pokud vás například někdo požádá, abyste vyhodnotili:</p>
                           <pre class="wp-block-preformatted">a<sup>2</sup> + ab

</pre>
                           <p>ve Forthu, zjistíte, že je to poměrně komplikované (a možná i nemožné) pomocí slov, která jsme si dosud představili ... ledaže byste výraz vynásobili tak, že by zněl:</p>
                           <pre class="wp-block-preformatted">a * (a + b)

</pre>
                           <p>což je výraz, který jsme právě tak snadno vyhodnotili.</p>
                           <h3><span id="ROT">ROT</span></h5>
                           <p>Čtvrtým manipulátorem zásobníku na seznamu je ROT (vyslovuje se <em>rote</em>), což je zkratka pro "rotovat". ROT transformuje tři horní hodnoty zásobníku z ( a b c ) na ( b c a ).</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="297" src="./02-Stack-Manipulation Operators_files/ch2-rot.gif" alt="ROT (rotate) - operátory zásobníku" class="wp-image-407"></figure>
                           <p>Pokud například potřebujeme vyhodnotit výraz:</p>
                           <pre class="wp-block-preformatted">ab - bc

</pre>
                           <p>měli bychom nejprve vynásobit čísla b:</p>
                           <pre class="wp-block-preformatted">b * (a - c)

</pre>
                           <p>Nyní, pokud je naše pořadí počátečního zásobníku následující:</p>
                           <pre class="wp-block-preformatted">( c b a -- )

</pre>
                           <p>můžeme použít:</p>
                           <pre class="wp-block-preformatted">ROT - *

</pre>
                           <p>při kterém dojde k následujícím krokům:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td><strong>Operace</strong></td>
                                    <td><strong>Obsah zásobníku</strong></td>
                                 </tr>
                                 <tr>
                                    <td></td>
                                    <td>c b a</td>
                                 </tr>
                                 <tr>
                                    <td>ROT</td>
                                    <td>b a c</td>
                                 </tr>
                                 <tr>
                                    <td>-</td>
                                    <td>b (a-c)</td>
                                 </tr>
                                 <tr>
                                    <td>*</td>
                                    <td>b*(a-c)</td>
                                 </tr>
                              </tbody>
                           </table>
                           <h3><span id="DROP">DROP</span></h5>
                           <p>Závěrečným operátorem pro manipulaci se zásobníkem na seznamu je DROP. Jediné, co udělá, je, že zahodí horní hodnotu zásobníku.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="159" src="./02-Stack-Manipulation Operators_files/ch2-drop.gif" alt="DROP - Forth stack operators" class="wp-image-408"></figure>
                           <p>Pěkně jednoduché, co? Později si ukážeme několik dobrých způsobů použití DROP.</p>
                           <h3><span id="A_Handy_Hint_A_Non-destructive_Stack_Print">Šikovná nápověda:
                              Nedestruktivní tisk zásobníku</span>
                           </h5>
                           <p>
                              Začátečníci, kteří se teprve učí manipulovat s čísly na zásobníku užitečnými způsoby, se velmi často setkávají s tím, že zadávají řadu teček, aby viděli, co je na zásobníku po jejich manipulaci. Problém s tečkami však spočívá v tom, že neponechávají čísla na zásobníku pro budoucí manipulaci.
                              Forthovské slovo .S vypíše všechny hodnoty, které se náhodou na zásobníku nacházejí, "nedestruktivně"; to znamená bez jejich odstranění. Vyzkoušejme to, nejprve bez ničeho na zásobníku:
                           </p>
                           <pre class="wp-block-preformatted">.S↵<span class="output">&lt;0&gt; ok </span>

</pre>
                           <p>
                              Jak vidíte, v této verzi .S vidíme alespoň jedno číslo. Jedná se o počet položek, které jsou skutečně na zásobníku.
                              Nyní to zkusíme s čísly na zásobníku:
                           </p>
                           <pre class="wp-block-preformatted">1 2 3 .S↵<span class="output">&lt;3&gt; 1 2 3 ok </span><br>ROT .S &lt;3&gt;↵<span class="output">2 3 1 ok </span></pre>
                           <h3><span id="Manipulace se zásobníkem_a_matematické_definice_Quizzie_2-c">Manipulace se zásobníkem a matematické definice (Quizzie 2-c)</span></h5>
                           <ol class="sf-numbered">
                              <li>
                                 Napište větu, která přehodí tři položky na zásobníku a ponechá uprostřed prostřední číslo; tj,
                                 <pre>a b c</pre>
                                 <p>stane se</p>
                                 <pre>c b a</pre>
                              </li>
                              <li>Napište větu, která dělá to, co dělá OVER, aniž byste použili OVER.</li>
                              <li>
                                 Napište definici s názvem -ROT, která otočí tři horní položky zásobníku opačným směrem než ROT; tj,
                                 <pre>a b c</pre>
                                 <p>stane se</p>
                                 <pre>c a b</pre>
                              </li>
                              <li>
                                 Napište definice následujících rovnic, vzhledem k zobrazeným stohovým efektům:
                                 <pre>(n+1) / n ( n -- výsledek )</pre>
                              </li>
                              <li>
                                 <pre>x(7x + 5) ( x -- výsledek )</pre>
                              </li>
                              <li>
                                 <pre>9a<sup>2</sup> - ba ( a b -- výsledek )</pre>
                              </li>
                           </ol>
                           <div class="wp-block-genesis-blocks-gb-accordion gb-block-accordion gb-font-size-18">
                              <details>
                                 <summary class="gb-accordion-title">Odpovědi Quizzie 2-c</summary>
                                 <div class="gb-accordion-text">
                                    <pre class="wp-block-preformatted">1.<br>SWAP ROT<br><br>2.<br>SWAP DUP ROT SWAP<br><br>3.<br>: -ROT ROT ROT ; ( Váš Forth to už pravděpodobně má. )<br><br>4.<br>: 2C4 DUP 1 + SWAP / ; nebo<br>: 2C4 DUP 1+ SWAP / ;<br><br>5.<br>: 2C5 DUP 7 * 5 + * ;<br><br>6.<br>: 2C6 OVER 9 * SWAP - * ;</pre>
                                 </div>
                              </details>
                           </div>
                           <h3><span id="Hrajeme_dvojice">Hrajeme dvojice</span></h3>
                           <p>Další čtyři operátory manipulace se zásobníkem by vám měly být povědomé:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>2SWAP</td>
                                    <td>( d1 d2 - d2 d1 )</td>
                                    <td>Převrátí dvě horní dvojice čísel</td>.
                                 </tr>
                                 <tr>
                                    <td>2DUP</td>
                                    <td>( d - d d )</td>
                                    <td>Duplikuje horní dvojici čísel</td>
                                 </tr>
                                 <tr>
                                    <td>2OVER</td>
                                    <td>( d1 d2 - d1 d2 d1 )</td>
                                    <td>Duplikuje druhou dvojici čísel </td>
                                 </tr>
                                 <tr>
                                    <td>2DROP</td>
                                    <td>( d1 d2 - d1 )</td>
                                    <td>Zruší horní dvojici čísel</td>
                                 </tr>
                              </tbody>
                           </table>
                           <div class="wp-block-image">
                              <figure class="aligncenter"><img loading="lazy" width="140" height="180" src="./02-Stack-Manipulation Operators_files/ch2-guess-who.gif" alt="2DROP - dvojčíslí ve Forthu" class="wp-image-409"></figure>
                           </div>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="251" src="./02-Stack-Manipulation Operators_files/ch2-pronounce-3.gif" alt="Operátory zásobníku - dvojčíslí ve Forthu" class="wp-image-410"></figure>
                           </div>
                           <p>Předpona "2" označuje, že tyto operátory manipulace se zásobníkem <abbr title="Pro staré mazáky: ">obsluhují čísla ve dvojicích</abbr>." "Lze je použít i pro manipulaci s čísly dvojnásobné délky (64 bitů). Písmeno "d" ve sloupci zásobníkových efektů znamená "double". "Double" má zvláštní význam, který probereme, až budeme mluvit o "n" a "u" </p>.
                           <p>Výše uvedené manipulátory "2" jsou tak jednoduché, že vás ani nebudeme nudit příklady.</p>
                           <p>Ještě jedna věc: stále ještě existují manipulátory zásobníku, o kterých jsme ještě nemluvili, takže se nezblázněte a nezkoušejte na zásobníku příliš mnoho fantazie.</p>
                           <h3><span id="Chapter_Summary">Shrnutí kapitoly</span></h3>
                           <h3><span id="Předchozí_slova">Předchozí slova</span></h5>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>+</td>
                                    <td>( n1 n2 - sum )</td>
                                    <td>Přidá</td>
                                 </tr>
                                 <tr>
                                    <td>-</td>
                                    <td>( n1 n2 - diff )</td>
                                    <td>Odčítá (n1-n2)</td>
                                 </tr>
                                 <tr>
                                    <td>*</td>
                                    <td>( n1 n2 - prod )</td>
                                    <td>Násobí</td>
                                 </tr>
                                 <tr>
                                    <td>/</td>
                                    <td>( n1 n2 - quot )</td>
                                    <td>Dělí (n1/n2)</td>
                                 </tr>
                                 <tr>
                                    <td>/MOD</td>
                                    <td>( n1 n2 - rem quot )</td>
                                    <td>Dělí; vrací zbytek a kvocient</td>
                                 </tr>
                                 <tr>
                                    <td>MOD</td>
                                    <td>( n1 n2 - rem )</td>
                                    <td>Dělí; vrací pouze zbytek</td>
                                 </tr>
                                 <tr>
                                    <td>SWAP</td>
                                    <td>( n1 n2 - n2 n1 )</td>
                                    <td>Převrátí dvě horní položky zásobníku</td>
                                 </tr>
                                 <tr>
                                    <td>DUP</td>
                                    <td>( n - n n )</td>
                                    <td>Duplikuje horní položku zásobníku</td>
                                 </tr>
                                 <tr>
                                    <td>OVER</td>
                                    <td>( n1 n2 - n1 n2 n1 )</td>
                                    <td>Kopíruje druhou položku na vrchol</td>
                                 </tr>
                                 <tr>
                                    <td>ROT</td>
                                    <td>( n1 n2 n3 - n2 n3 n1 )</td>
                                    <td>Otáčí třetí položku nahoru</td>
                                 </tr>
                                 <tr>
                                    <td>DROP</td>
                                    <td>( n - )</td>
                                    <td>Zruší horní položku zásobníku</td>.
                                 </tr>
                                 <tr>
                                    <td>2SWAP</td>
                                    <td>( d1 d2 - d2 d1 )</td>
                                    <td>Přehodí dvě horní dvojice čísel</td>
                                 </tr>
                                 <tr>
                                    <td>2DUP</td>
                                    <td>( d - d d )</td>
                                    <td>Duplikuje horní dvojici čísel</td>
                                 </tr>
                                 <tr>
                                    <td>2OVER</td>
                                    <td>( d1 d2 - d1 d2 d1 )</td>
                                    <td>Duplikuje druhou dvojici čísel </td>
                                 </tr>
                                 <tr>
                                    <td>2DROP</td>
                                    <td>( d1 d2 - d1 )</td>
                                    <td>Zruší horní dvojici čísel</td>
                                 </tr>
                              </tbody>
                           </table>
                           <h3><span id="Review_of_Terms">Přehled pojmů</span></h5>
                           <dl>
                              <dt>Čísla dvojí délky</dt>
                              <dd>celá čísla, která zahrnují rozsah přes -18,446,744,073,709,551,615 do +18,446,744,073,709,551,615 (a která oficiálně představíme v <a href="https://www.forth.com/starting-forth/7-signed-double-length-numbers/">Kap. 7</a>).</dd>.
                              <dt>Čísla o jedné délce</dt>
                              <dd>celá čísla, která spadají do intervalu -2 miliardy až +2 miliardy: jediná čísla, která jsou platná jako argumenty nebo výsledky některého z operátorů, které jsme dosud probrali.</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="aligncenter"><a href="./02-Stack-Manipulation Operators_files/felix.gif"><img loading="lazy" width="230" height="100" src="./02-Stack-Manipulation Operators_files/felix.gif" alt="Programovací jazyk Forth - příklady" class="wp-image-353"></a></figure>
                           </div>
                           <h3><span id="Problems_Chapter_2">Problémy - kapitola 2</span></h5>
                           <ol class="sf-numbered">
                              <li>Jaký je rozdíl mezi DUP DUP a 2DUP?&nbsp;</li>
                              <br>
                              <li>Napište větu, která obrátí pořadí čtyř horních položek na zásobníku; to znamená,<br><code>( 1 2 3 4 -- 4 3 2 1 )</code>&nbsp;</li>
                              <br>
                              <li>
                                 Napište definici <code>3DUP</code>, která zdvojí pořadí tří horních čísel na zásobníku; například,<br><code>( 1 2 3 -- 1 2 3 1 2 3 )</code>.
                                 <p></p>
                              </li>
                              <li>
                                 Napište definice následujících infixových rovnic, vzhledem k zobrazeným efektům zásobníku:
                                 <pre>a<sup>2</sup> + ab + c ( c a b -- výsledek )<br>(a-b)/(a+b) ( a b -- výsledek)</pre>
                              </li>
                              <li>
                                 Napište soubor slov pro výpočet trestu odnětí svobody pro těžké zločince tak, aby jej mohl zadat soudce:
                                 <pre>ODSOUZENÝ-ZA ZLOČIN DOMÁCÍHO VRAŽDENÍ↵<span class="output">ok </span>VYŠETŘOVAT↵<span class="output">35 let ok </span></pre>
                                 <p>nebo jakákoli řada trestných činů začínající slovem ZLOČIN-OF a končící slovem WILL-SERVE. Použijte tyto věty:</p>
                                 <pre>VRAŽDA 20 let ZLOČIN 10 letZLODĚJSTVÍ 2 rokyTAXOVÁ VRAŽDA 5 let</pre>
                              </li>
                              <li>
                                 Jste programátorem inventury na Mariině vaječném ranči. Definujte slovo tzv.
                                 <pre>EGG.KARTONY</pre>
                                 <p>které na zásobníku očekává celkový počet vajec, která dnes slepice snesly, a vypíše počet kartonů, které lze naplnit po tuctu vajec, a také počet zbylých vajec.</p>
                              </li>
                           </ol>
                           <div class="wp-block-genesis-blocks-gb-accordion gb-block-accordion gb-font-size-18">
                              <details>
                                 <summary class="gb-accordion-title">Odpovědi</summary>
                                 <div class="gb-accordion-text">
                                    <ol>
                                       <li>DUP DUP duplikuje horní položku zásobníku dvakrát, zatímco 2DUP duplikuje dvě horní položky zásobníku jednou.</li>
                                       <li>
                                          <pre>( a b c d -- d c b a ) 1 2 3 4 SWAP 2SWAP SWAP . . . .</pre>
                                       </li>
                                       <li>
                                          <pre>: 3DUP ( a b c -- a b c a b c ) DUP 2OVER ROT ;</pre>
                                       </li>
                                       <li>
                                          <pre>: 2-4A ( c a b -- a**2+ab+c ) OVER + * + ;

: -ROT ( a b c -- c a b ) ROT ROT ;
: 2-4B ( a b -- [a-b]/[a+b] ) 2DUP - -ROT + / ;
</pre>
                                       </li>
                                       <li>
                                          <pre>: CONVICTED-OF ( -- no-sentence ) 0 ;
: ZLOČIN ( -- věta+10 ) 10 + ;
: VRAŽDA ( věta -- věta+20 ) 20 + ;
: VRAŽDA ( věta -- věta+2 ) 2 + ;
: DAŇOVÁ EKVASIONACE ( věta -- věta+5 ) 5 + ;
: VŮLE-OSVOBOZENÍ ( věta -- ) . ." let " ;
</pre>
                                       </li>
                                       <li>
                                          <pre>: EGG.CARTONS ( total-eggs -- )
   12 /MOD .." karton(y) a " .." zbytek(y) " ;
</pre>
                                       </li>
                                    </ol>
                                 </div>
                              </details>
                           </div>
                        </div>
                     </div>
                  </article>
               </main>
            </div>
         </div>
      </div>
      <div class="site grid-container container hfeed grid-parent" id="page">
         <div class="site-content" id="content">
            <div class="content-area grid-parent mobile-grid-100 grid-70 tablet-grid-70" id="primary">
               <main class="site-main" id="main">
                  <article id="post-316" class="post-316 page type-page status-publish" itemtype="https://schema.org/CreativeWork" itemscope="">
                     <div class="inside-article">
                        <header class="entry-header" aria-label="Content">
                           <h2 class="entry-title" itemprop="headline">3. Redakce (a zaměstnanci)</h2>
                        </header>
                        <div class="entry-content" itemprop="text">
                           <p>Dosud jste do slovníku zakládali nové definice tak, že jste je zadávali na terminálu. V této kapitole se seznámíte s alternativní metodou, která využívá diskové úložiště.</p>
                           <p>Začněme několika postřehy, které se týkají konkrétně slovníku.</p>
                           <h3><span id="Další_pohled_na_slovník">Jiný pohled na slovník</span></h3>
                           <p>Pokud jste experimentovali se skutečným počítačem, možná jste objevili některé věci, o kterých jsme se ještě nezmínili. V každém případě je na čase se o nich zmínit.</p>
                           <div class="sc-info-box normal full">
                              <h3><span id="Discovery_One">Objev první:</span></h5>
                              Stejné slovo můžete definovat vícekrát různými způsoby - provede se pouze poslední definice.
                           </div>
                           <p>Příklad pokud jste zadali:</p>
                           <pre class="wp-block-preformatted">: GREET ." Dobrý den, mluvím forthsky. " ;↵<span class="output">ok </span>

</pre>
                           <p>poté byste měli dostat tento výsledek:</p>
                           <pre class="wp-block-preformatted">GREET↵<span class="output">Dobrý den, mluvím forthsky. ok </span>

</pre>
                           <p>A když předefinujete:</p>
                           <pre class="wp-block-preformatted">: GREET ." Ahoj! " ;↵<span class="output">ok </span>

</pre>
                           <p>získáte nejnovější definici:</p>
                           <pre class="wp-block-preformatted">GREET↵<span class="output">Ahoj! ok </span>

</pre>
                           <p>Je první GREET vymazán? Ne, stále tam je, ale kvůli pořadí vyhledávání se provede nejnovější GREET. Textový interpret začíná vždy "vzadu ve slovníku", kde je nejnovější záznam. Definice, kterou najde jako první, je ta, kterou jste definovali jako poslední. Tuto zobrazí při EXECUTE.</p>
                           <p>Můžeme dokázat, že starý GREET je stále na místě. Zkuste to takto:</p>
                           <pre class="wp-block-preformatted">FORGET GREET↵<span class="output">ok </span>

</pre>
                           <p>a</p>
                           <pre class="wp-block-preformatted">GREET↵<span class="output">Dobrý den, mluvím Forth. ok </span>

</pre>
                           <p>(opět starý známý GREET!). <abbr title="Jednodušší Forthy nemají FORGET; místo něj můžete použít MARKER.">[?]</abbr></p>
                           <figure class="wp-block-image"><img width="400" height="131" src="./03-Code in Forth blocks_files/ch3-forget-burglar.gif" alt="FORGET odstraní slovo ze slovníku Forth" class="wp-image-411"></figure>
                           <p>Slovo FORGET vyhledá dané slovo ve slovníku a v podstatě ho odstraní ze slovníku spolu se vším, co jste od tohoto slova definovali. FORGET, stejně jako tlumočník, prohledává slovo počínaje odzadu; odstraňuje pouze naposledy definované verze slova (spolu se všemi následujícími slovy). Když tedy nyní na terminálu zadáte GREET, interpret najde původní GREET.</p>
                           <p>PŘEDEM je dobré znát slovo; pomůže vám vyčistit slovník, abyste ho nepřeplnili. (Slovník zabírá místo v paměti, takže stejně jako při jakémkoli jiném využití paměti s ním chcete šetřit)</p>.
                           <p>Některé Forthy nemají funkci FORGET. V takovém případě musíte zapomínání předem naplánovat, například:</p>
                           <pre class="wp-block-preformatted">ZNAČKA -práce

</pre>
                           <p>definuje nulovou definici -work, která za vás označí aktuální stav systému. Při pozdějším spuštění -work se obnoví stav systému platný v okamžiku definování -work. Zejména všechna slova definovaná po značkovacím slově -work jsou ze slovníku zcela odstraněna.</p>
                           <div class="sc-info-box normal full">
                              <h3><span id="Zjištění_druhé">Zjištění druhé:</span></h5>
                              Když zadáváte definice z terminálu (jak jste to dělali doposud), vaše <abbr title="Zdrojový text &#39;je původní verze definice, např: FOUR-MORE 4 + ;, kterou překladač přeloží do slovníkového hesla.">zdrojový text</abbr> se neukládá.
                           </div>
                           <p>Ve slovníku je uložena pouze zkompilovaná podoba definice. Co když tedy chcete provést drobnou změnu v již definovaném slově? V tomto případě přichází na řadu "textový editor". Pomocí tohoto editoru můžete uložit svůj zdrojový text a v případě potřeby jej upravit. V dnešní době můžeme předpokládat, že každý má přístup k textovému editoru. V dokumentaci k systému Forth by měly být popsány postupy, jak snadno používat váš oblíbený textový editor z prostředí Forth. (V moderním operačním systému poklepejte na soubor, který chcete upravit. Po dokončení své editační činnosti zadejte na příkazovém řádku jazyka Forth příkaz INCLUDE. Přidejte alespoň jednu koncovou mezeru, pak přetáhněte soubor v okně Forth a pusťte jej na příkazový řádek. Napište ↵.)</p>
                           <p>Textový editor ukládá váš zdrojový text na disk. Proto si raději představíme disk a způsob, jakým jej systém Forth používá.</p>
                           <h3><span id="Jak_Forth_využívá_disk">Jak Forth využívá disk</span></h3>
                           <p>Všechny systémy Forth používají diskovou paměť. I když disková paměť není pro systém Forth nezbytně nutná, je těžké si Forth bez ní představit.</p>
                           <p>Chcete-li pochopit, k čemu slouží disková paměť, porovnejte ji s pamětí počítače (RAM). Rozdíl je analogický rozdílu mezi kartotékou a pojízdnou kartotékou.</p>
                           <p>Dosud jste používali počítačovou paměť, která je jako kartotéka. Počítač má k této paměti přístup téměř okamžitě, takže programy uložené v paměti RAM mohou běžet velmi rychle. Bohužel tento druh paměti je někdy velmi omezený (např. ve vestavných řadičích) a poměrně drahý.</p>
                           <p>Na druhou stranu se disk nazývá "velkoobjemové paměťové zařízení", protože podobně jako kartotéka může uchovávat velké množství informací při mnohem nižší ceně za jednotku informace než paměť uvnitř počítače.</p>
                           <p>Do obou druhů paměti lze zapisovat a číst z ní.</p>
                           <p>Překladač zkompiluje všechna slovníková hesla do paměti počítače, aby byly definice rychle dostupné. Ideálním místem pro uložení zdrojového textu je však disk, což Forth dělá. Zdrojový text můžete buď posílat přímo z klávesnice do interpretu (jak jste to dělali dosud), nebo můžete zdrojový text uložit na disk a později jej z disku přečíst a poslat do textového interpretu.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="200" height="180" src="./03-Kód ve Forthových blocích_souborech/ch3-filesystem.gif" alt="Ukládání Forthova kódu do diskových bloků nebo do souborů" class="wp-image-412"></figure>
                           </div>
                           <p>Disková paměť je rozdělena na jednotky zvané "bloky". Každý blok obsahuje 1 024 znaků zdrojového textu nebo binárních dat, tradičně uspořádaných do 16 řádků po 64 znacích. Standard ANS Forth nespecifikuje, kolik bloků je. To by vám měla říct dokumentace vašeho systému Forth.</p>
                           <p>U současných systémů Forth se disková paměť nachází v souborech operačního systému. Existují způsoby, jak k "disku Forth" připojit konkrétní soubory OS. Vzhledem ke speciálnímu formátu bloků Forthu 16 x 64 je nástroje OS považují za binární data a nemohou je obecně tisknout, vypisovat, filtrovat nebo upravovat. Systémy Forth mají standardizované prostředky, které některé z těchto úloh zvládnou samy.</p>
                           <p>Používáte-li SwiftForth, pak by následující příkaz měl dávat pokyn, aby paměť disku pocházela z nějakého souboru:</p>
                           <pre class="wp-block-preformatted">USING blocks.forth↵<span class="output">ok </span></pre>
                           <p>Toto je verze iForth:</p>
                           <pre class="wp-block-preformatted">POUŽITÍ blocks.forth↵<span class="output">ok </span>

</pre>
                           <p>Chcete-li vypsat blok, jednoduše zadejte číslo bloku a slovo LIST, jako například:</p>
                           <pre class="wp-block-preformatted">1 LIST <br> 0 ( velké písmeno F) <br> 1 <br> 2 : STAR [CHAR] * EMIT ;<br> 3 : STARS 0 DO STAR LOOP ;<br> 4 : MARGIN CR 30 MEZER ;<br> 5 : BLIP MARGIN STAR ;<br> 6 : BAR MARGIN 5 STARS ;<br> 7 : F BAR BLIP BAR BLIP BLIP CR ;<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15 ok</pre>
                           <p>Výše uvedené vypadá tak, jak je blok vypsán na terminálu.</p>
                           <p>Pro lepší představu, jak by se to všechno dalo použít, budeme předpokládat, že blok 1 obsahuje výše uvedené definice. Kromě řádku 0 vypadá vše povědomě; jsou to definice, které jste použili k vypsání velkého písmene "F" na terminálu.</p>
                           <p>Nyní kdybyste napsali:</p>
                           <pre class="wp-block-preformatted">1 LOAD<br>F</pre>
                           <p>poslali byste blok 1 do vstupního proudu a pak dále do textového interpretu. Textovému interpretu je jedno, odkud jeho text pochází. Rozpozná dvojtečky, nechá zkompilovat všechny definice a pak provede nové slovo F.</p>
                           <p>Nyní k nedokončené práci: řádek 0. Slova uvnitř závorek jsou komentářem pouze pro člověka; nejsou ani zkompilována, ani provedena. Slovo ( ("levá závorka") říká interpretu textu, aby přeskočil celý následující text až po ukončující pravou závorku. Protože ( je slovo, musí být odděleno mezerou. Uzavírací závorka není slovo, je to prostě znak, který se hledá pomocí (, tzv. oddělovač. (Připomeňme, že oddělovačem pro ." je uzavírací uvozovka.)</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>LIST</td>
                                    <td>( n - )</td>
                                    <td>Vypisuje blok disku</td>
                                 </tr>
                                 <tr>
                                    <td>LOAD</td>
                                    <td>( n - )</td>
                                    <td>Naloží blok disku</td>
                                 </tr>
                                 <tr>
                                    <td>( xxx)</td>
                                    <td>( - )</td>
                                    <td>Ignoruje text až do delimitru ")"</td>
                                 </tr>
                              </tbody>
                           </table>
                           <h3><span id="Block-buffer_Basics">Základy blokové vyrovnávací paměti</span></h5>
                           <p>Bloky jsme probrali především z historických důvodů. Bloky se již téměř nepoužívají pro ukládání zdrojového textu. Upřednostňuje se práce se zdrojovými soubory ve standardních textových souborech, k jejichž načtení se používá slovo INCLUDE:</p>
                           <pre class="wp-block-preformatted">INCLUDE bloky.forth↵<span class="output">ok </span>

</pre>
                           <p>Hlavní výhodou je, že kód ze souboru lze upravovat a spravovat pomocí standardních nástrojů pro textové soubory.</p>
                           <p>Když už jsme ale u toho, zmíníme se o několika dalších slovech pro přístup k blokům na disku a jejich úpravu.</p>
                           <p>Základní slovo, které přivádí blok z disku poté, co nejprve najde volnou vyrovnávací paměť a v případě potřeby uloží její obsah na disk, je BLOK. Pokud například řeknete</p>
                           <pre class="wp-block-preformatted">1 BLOCK

</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="140" height="147" src="./03-Kód ve Forthu bloky_soubory/ch3-flush.gif" alt="FLUSH donutí Forth uložit všechny změněné bloky na disk" class="wp-image-413"></figure>
                           </div>
                           <p>Systém zkopíruje blok 1 aktuálně otevřeného souboru do jedné ze systémových vyrovnávacích pamětí. BLOCK také zanechá na zásobníku adresu začátku bufferu (1024 bajtů, nezapomeňte), který použil. Obsah tohoto bufferu zůstane zaručeně platný, dokud neprovedete slovo ze sady procedur s "dopadem na více úloh", jako je EMIT nebo TYPE. Pokud kdykoli změníte obsah vyrovnávací paměti a poté provedete slovo UPDATE, bude Forth pamatovat na to, že když bude potřebovat vyrovnávací paměť znovu použít, musí nejprve zapsat blok zpět na disk. Pokud z nějakého důvodu provedete UPDATE a pak se rozhodnete, že bloky přece jen nechcete nechat přepsat, použijte EMPTY-BUFFERS k jejich zneplatnění. Funguje to proto, že Forth po použití UPDATE neprovádí okamžitý zápis na disk. Chcete-li si vynutit vypsání vyrovnávacích pamětí <em>teď hned</em>, použijte slovo FLUSH.</p>
                           <h3><span id="Chapter_Summary">Shrnutí kapitoly</span></h3>
                           <h3><span id="Forth_Words">Slovy na závěr</span></h5>
                           <p>Tady je seznam slov Forth, která jsme probrali v této kapitole:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>Použití xxx<br>Použití xxx</td>
                                    <td>( -)</td>
                                    <td>Použít soubor xxx jako Forth "disk"</td>
                                 </tr>
                                 <tr>
                                    <td>LIST</td>
                                    <td>( n - )</td>
                                    <td>Vypisuje blok disku</td>
                                 </tr>
                                 <tr>
                                    <td>LOAD</td>
                                    <td>( n - )</td>
                                    <td>Naloží blok disku</td>
                                 </tr>
                                 <tr>
                                    <td>( xxx)</td>
                                    <td>( - )</td>
                                    <td>Ignoruje text až do delimitru ")"</td>
                                 </tr>
                                 <tr>
                                    <td>UPDATE</td>
                                    <td>( - )</td>
                                    <td>Označí poslední blok jako aktualizovaný</td>
                                 </tr>
                                 <tr>
                                    <td>EMPTY-BUFFERS</td>
                                    <td>( - )</td>
                                    <td>Označí všechny vyrovnávací paměti bloku jako prázdné</td>
                                 </tr>
                                 <tr>
                                    <td>BLOCK</td>
                                    <td>( n - addr )</td>
                                    <td>Vrátí adresu vyrovnávací paměti pro blok n</td>
                                 </tr>
                                 <tr>
                                    <td>INCLUDE xxx</td>
                                    <td>( - )</td>
                                    <td>Načíst textový soubor xxx</td>
                                 </tr>
                                 <tr>
                                    <td>FORGET xxx</td>
                                    <td>( - )</td>
                                    <td>Zapomeňte definice zpětně přes xxx</td>
                                 </tr>
                                 <tr>
                                    <td>ZNAČKA xxx</td>
                                    <td>( - )</td>
                                    <td>Definuje značku xxx pro vrácení slovníku zpět</td>
                                 </tr>
                              </tbody>
                           </table>
                           <h3><span id="Review_of_Terms">Přehled termínů</span></h5>
                           <dl>
                              <dt>Blok</dt>
                              <dd>ve Forthu rozdělení diskové paměti obsahující až 1024 znaků zdrojového textu.</dd>
                              <dt>Buffer</dt>
                              <dd>dočasná oblast pro ukládání dat.</dd>
                              <dt>Nulová definice</dt>
                              <dd>
                                 definice, která nic nedělá, zapsaná ve tvaru:
                                 <pre>: NAME ;

</pre>
                                 <p>to znamená, že do slovníku bude zakomponováno pouze jméno. Nulová definice slouží jako "záložka" ve slovníku, kterou FORGET najde.</p>
                              </dd>
                              <dt>Ukazatel</dt>
                              <dd>místo v paměti, kam lze uložit (nebo změnit) číslo jako odkaz na něco jiného.</dd>
                              <dt>Zdrojový text</dt>
                              <dd>ve Forthu vypsaná forma definice nebo definic v anglicky psaných slovech a interpunkčních znaménkách, na rozdíl od sestavené formy, která se vkládá do slovníku.</dd>
                           </dl>
                           <div class="wp-block-genesis-blocks-gb-accordion gb-block-accordion gb-font-size-18">
                              <details>
                                 <summary class="gb-accordion-title">Ukázka zdrojového souboru</summary>
                                 <div class="gb-accordion-text">
                                    <pre class="wp-block-preformatted">\ Velké písmeno F <br>: STAR [CHAR] * EMIT ;<br>: STARS 0 DO STAR LOOP ;<br>: MARGIN CR 30 MEZER ;<br>: BLIP MARGIN STAR ;<br>: BAR MARGIN 5 STARS ;<br>: F BAR BLIP BAR BLIP BLIP CR ;</pre>
                                 </div>
                              </details>
                           </div>
                        </div>
                     </div>
                  </article>
               </main>
            </div>
         </div>
      </div>
      <div class="site grid-container container hfeed grid-parent" id="page">
         <div class="site-content" id="content">
            <div class="content-area grid-parent mobile-grid-100 grid-70 tablet-grid-70" id="primary">
               <main class="site-main" id="main">
                  <article id="post-319" class="post-319 page type-page status-publish" itemtype="https://schema.org/CreativeWork" itemscope="">
                     <div class="inside-article">
                        <header class="entry-header" aria-label="Content">
                           <h2 class="entry-title" itemprop="headline">4. Rozhodnutí, rozhodnutí...</h2>
                        </header>
                        <div class="entry-content" itemprop="text">
                           <p>V této kapitole se naučíme, jak naprogramovat počítač, aby dělal "rozhodnutí". To je okamžik, kdy se z počítače stane něco víc než jen obyčejná kalkulačka.</p>
                           <h3><span id="The_Conditional_Phrase">Podmíněná věta</span></h3>
                           <p>Podívejme se, jak ve Forthu napsat jednoduchý rozhodovací příkaz. Představme si, že programujeme mechanickou baličku krabic na vejce. Nějaké mechanické zařízení spočítalo vejce na dopravním pásu a nyní máme k dispozici počet vajec na hromadě. Věta jazyka Forth:</p>
                           <pre class="wp-block-preformatted">12 = IF FILL-CARTON THEN</pre>
                           <p>testuje, zda je číslo na zásobníku <em>rovné</em> 12, a <em>pokud je</em>, provede se slovo FILL-CARTON. Pokud tomu tak není, přejde se rovnou ke slovům, která následují za slovem THEN.</p>
                           <figure class="wp-block-image"><img width="400" height="160" src="./04-Conditional - IF...THEN Statements_files/ch4-equal.gif" alt="if...then statements in Forth code" class="wp-image-414"></figure>
                           <p>Výraz = vezme dvě hodnoty zásobníku a porovná je, aby zjistil, zda se rovnají.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="91" src="./04-Conditional - IF...THEN Statements_files/ch4-if.gif" alt="Provede kód, POKUD je podmínka pravdivá, jinak přeskočí THEN" class="wp-image-415"></figure>
                           <p>Pokud je podmínka pravdivá, IF umožňuje pokračovat v toku provádění dalším slovem v definici.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="160" height="175" src="./04-Conditional - IF...THEN Statements_files/ch4-if-2.gif" alt="Příkazy IF...THEN rozhodují, zda se má provést kód po IF a před THEN." class="wp-image-416"></figure>
                           </div>
                           <p>Pokud je však podmínka nepravdivá, IF způsobí, že se tok provádění přeskočí na THEN, od kterého se bude pokračovat ve vykonávání.</p>
                           <p>Vyzkoušejme si to. Definujte toto příkladové slovo:</p>
                           <pre class="wp-block-preformatted">: ?FULL 12 = IF ." Je plný " THEN ;↵<span class="output">ok </span>11 ?FULL↵<span class="output">ok </span>12 ?FULL↵<span class="output">Je plný ok </span></pre>
                           <p>Upozornění: příkaz IF...THEN musí být obsažen v definici. Nemůžete tato slova zadávat jen tak "stylem kalkulačky" </p>.
                           <p>Nenechte se zmást tradičním anglickým významem slov IF a THEN ve Forthu. Slova, která následují za IF, se provedou <em>pokud</em> je podmínka pravdivá. Slova, která následují za THEN, se provádějí <em>vždy</em>, jako byste počítači říkali: "Až provedeš volbu, <em>tedy</em> pokračuj ve zbytku definice." V tomto případě se slova, která následují za THEN, provádějí <em>vždy</em>. (V tomto příkladu je jediným slovem po THEN ;, které ukončuje definici.)</p> <p>.
                           <p>Podívejme se na další příklad. Tato definice zjišťuje, zda je teplota laboratorního kotle příliš vysoká. Očekává, že teplotu najde na zásobníku:</p>
                           <pre class="wp-block-preformatted">: ?TOO-HOT 220 &gt; IF ." Nebezpečí -- snížit teplotu " THEN ;</pre>
                           <p>Jestliže je teplota na zásobníku <em>větší než</em> 220, vypíše se na terminálu zpráva o nebezpečí. Tu můžete provést sami tak, že zadáte definici a těsně před slovo napíšete hodnotu </p>.
                           <pre class="wp-block-preformatted">290 ?TOO-HOT↵<span class="output">Nebezpečí -- snížení tepla ok </span><br>130 ?TOO-HOT↵<span class="output">ok </span></pre>
                           <p>Pamatujte, že každé IF potřebuje THEN, aby se mohlo vrátit domů. Obě slova musí být ve stejné definici.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="160" height="250" src="./04-Conditional - IF...THEN Statements_files/ch4-pronounce-1.gif" alt="Forthova porovnání jsou true nebo false, proto operátor porovnání předchází IF...THEN" class="wp-image-417"></figure>
                           </div>
                           <p>Tady je částečný seznam operátorů porovnávání, které můžete použít před příkazem IF...THEN:</p>
                           <pre class="wp-block-preformatted">=<br>&lt;&gt;<br>&lt;<br>&gt;<br>0=<br>0&lt;<br>0&gt;</pre>
                           <p>Slova &lt; a &gt; očekávají stejné pořadí zásobníku jako aritmetické operátory, tedy:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td><strong>Infix</strong></td>
                                    <td><strong>Postfix</strong></td>
                                 </tr>
                                 <tr>
                                    <td>2 &lt; 10</td>
                                    <td>2 10 &lt;</td>
                                 </tr>
                                 <tr>
                                    <td>17 &gt; -39</td>
                                    <td>17 -39 &gt;</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Slova 0=, 0&lt; a 0&gt; očekávají na zásobníku pouze jednu hodnotu. Hodnota se porovnává s nulou.</p>
                           <p>Další slovo, INVERT, netestuje vůbec žádnou hodnotu; prostě obrátí jakoukoli podmínku, která byla právě testována. Například věta:</p>
                           <pre class="wp-block-preformatted">... = INVERT IF ...</pre>
                           <p>vykoná slova za IF, pokud se obě čísla na zásobníku <em>nerovnají</em>.</p>
                           <h3><span id="The_Alternative_Phrase">Alternativní věta</span></h5>
                           <p>Příkaz umožňuje uvést alternativní větu v příkazu IF pomocí slova ELSE.</p>
                           <p>Následující příklad je definice, která testuje, zda je dané číslo platným dnem v měsíci:</p>
                           <pre class="wp-block-preformatted">: ?DAY 32 &lt; IF ." Vypadá to dobře " ELSE ." v žádném případě " THEN ;</pre>
                           <p>Pokud je číslo na zásobníku menší než dvaatřicet, vypíše se zpráva "Vypadá to dobře". V opačném případě se vypíše zpráva "no way".</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="116" src="./04-Conditional - IF...THEN Statements_files/ch4-else.gif" alt="IF...ELSE...THEN příkazy vytvářejí rozvětvení nebo větvení v kódu Forth." class="wp-image-418"></figure>
                           <p>Představte si, že IF v závislosti na výsledku testu vytáhne výhybku na železniční trati. Provedení se pak ubírá jednou ze dvou možných cest, ale v každém případě se koleje opět spojí u slova THEN.</p>
                           <p>Mimochodem, v počítačové terminologii se celá tato záležitost s přesměrováním cesty provádění nazývá "<abbr title="Pro staré mazáky: </p> "Forth nemá příkaz GOTO.">větvení</abbr>."</p>
                           <p>Tady je <abbr title="Pro znalce: <abbr title="Pro znalce: Jak uvidíme, existují lepší způsoby.">užitečnější příklad</abbr>. Víte, že dělení libovolného čísla nulou je nemožné, takže pokud to zkusíte na počítači, dostanete nesprávnou odpověď. Mohli bychom definovat slovo, které provede dělení pouze v případě, že jmenovatel není nula. Následující definice očekává položky zásobníku v tomto pořadí:</p>
                           <pre class="wp-block-preformatted">( čitatel jmenovatel -- kvocient ) <br>: /CHECK DUP 0= IF ." invalid " DROP ELSE / THEN ;</pre>
                           <p><abbr title="Pro odborníky: Všimněte si, že</abbr> musíme nejprve DUP jmenovatele, protože věta</p>
                           <pre class="wp-block-preformatted">0= IF</pre>
                           <p> jej při tom zničíme.</p>
                           <p>Všimněte si také, že slovo DROP odstraní jmenovatele, pokud nebude provedeno dělení, takže ať už budeme dělit, nebo ne, efekt zásobníku bude stejný.</p>
                           <h3><span id="Nested_IF8230THEN_Statements">Vested IF...THEN Statements</span></h5>
                           <p>Je možné vložit příkaz IF...THEN (nebo IF...ELSE...THEN) dovnitř jiného příkazu IF...THEN. Ve skutečnosti můžete být tak komplikovaní, jak jen chcete, pokud každý IF obsahuje jedno THEN.</p>
                           <p>Přemýšlejte o následující definici, která určuje velikost komerčních vajec (extra velká, velká atd.) vzhledem k jejich hmotnosti v uncích na tucet:</p>
                           <pre class="wp-block-preformatted">: EGGSIZE<br> DUP 18 &lt; IF ." reject " ELSE<br> DUP 21 &lt; IF ." small " ELSE<br> DUP 24 &lt; IF ." medium " ELSE<br> DUP 27 &lt; IF ." large " ELSE<br> DUP 30 &lt; IF ." extra large " ELSE<br> ." error "<br> THEN THEN THEN THEN DROP ;</pre>
                           <p>Po zadání velikosti EGGSIZE se zobrazí následující výsledky:</p>
                           <pre class="wp-block-preformatted">23 EGGSIZE↵<span class="output">medium ok</span><br>29 EGGSIZE↵<span class="output">extra large ok</span><br>40 EGGSIZE↵<span class="output">error ok </span></pre>
                           <p>Rádi bychom upozornili na několik věcí týkajících se EGGSIZE:</p>
                           <p>Celá definice je sérií "vnořených" příkazů IF...THEN. Slovo "vnořený" neodkazuje na to, že máme co do činění s vejci, ale na skutečnost, že se příkazy vnořují jeden do druhého jako sada míchacích misek.</p>
                           <p>Pět příkazů THEN v dolní části uzavírá pět příkazů IF v opačném pořadí, tedy:</p>
                           <div class="wp-block-image">
                              <figure class="aligncenter"><img loading="lazy" width="200" height="135" src="./04-Conditional - IF...THEN Statements_files/ch4-five-ifthens.gif" alt="" class="wp-image-419"></figure>
                           </div>
                           <p>Všimněte si také, že na konci definice je nutné použít příkaz DROP, abyste se zbavili původní hodnoty.</p>
                           <p>Nakonec si všimněte, že definice je vizuálně uspořádána tak, aby ji člověk snadno přečetl. Většina programátorů Forthu raději vyplýtvá trochu místa, než aby nechala věci zmást víc, než je nutné.</p>
                           <h3><span id="A_Closer_Look_at_IF">Blíže k IF</span></h5>
                           <p>Jak operátor porovnání (=, &lt;, &gt; nebo kterýkoli jiný) dává IF vědět, zda je podmínka pravdivá, nebo nepravdivá? Jednoduše tím, že na zásobníku ponechá TRUE nebo FALSE. TRUE (všechny bity nahoře) znamená, že podmínka je pravdivá; FALSE (všechny bity dole) znamená, že podmínka je nepravdivá.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="159" src="./04-Conditional - IF...THEN Statements_files/ch4-if-3.gif" alt="IF očekává na zásobníku dat příznak true nebo false" class="wp-image-420"></figure>
                           <p>V počítačovém žargonu se v případě, že jedna část programu zanechá hodnotu jako signál pro jinou část programu, tato hodnota nazývá "příznak" </p>.
                           <p>Zkuste v terminálu zadat následující věty a nechte si ukázat, co je na zásobníku jako příznak.</p>
                           <pre class="wp-block-preformatted">5 4 &gt; .↵<span class="output">-1 ok </span> 5 4 &lt; .↵<span class="output">0 ok </span></pre>
                           <p>(Je v pořádku používat operátory porovnávání přímo v terminálu tímto způsobem, ale nezapomeňte, že příkaz IF...THEN musí být celý obsažen v definici, protože zahrnuje větvení)</p>.
                           <p>IF bude brát příznak TRUE jako příznak, který znamená true, a příznak FALSE jako příznak, který znamená false. Nyní se blíže podíváme na příkaz INVERT, který obrací příznak na zásobníku.</p>
                           <pre class="wp-block-preformatted">FALSE INVERT .↵<span class="output">-1 ok</span><br>TRUE INVERT .↵<span class="output">0 ok </span></pre>
                           <p>Teď vám prozradíme malé tajemství: IF bude brát <em>jakoukoli nenulovou hodnotu</em> jako hodnotu true.</p>
                           <p>Chcete-li to dokázat, zkuste zadat tento test:</p>
                           <pre class="wp-block-preformatted">: TEST IF ." non-" THEN ." zero " ;</pre>
                           <p>I když ve výše uvedené definici není žádný operátor porovnávání, stejně dostanete</p>
                           <pre class="wp-block-preformatted">0 TEST↵<span class="output">nula ok</span><br>1 TEST↵<span class="output">ne-nula ok</span><br>-400 TEST↵<span class="output">ne-nula ok </span></pre>
                           <p>Tak co, ptáte se? Inu, skutečnost, že aritmetická nula je totožná s příznakem, který znamená "false", vede k několika zajímavým výsledkům.</p>
                           <p>Předně, pokud chcete testovat pouze to, zda je číslo nulové, operátor porovnání vůbec nepotřebujete. Například o něco jednodušší verze /CHECK, kterou jsme viděli dříve, by mohla být</p>
                           <pre class="wp-block-preformatted">: /CHECK DUP IF / ELSE ." invalid " DROP THEN ;</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="200" height="191" src="./04-Conditional - IF...THEN Statements_files/ch4-two-hands.gif" alt="Testování sudých násobků čísla pomocí MOD (beze zbytku)" class="wp-image-421"></figure>
                           </div>
                           <p>Tady je další zajímavý výsledek. Řekněme, že chcete otestovat, zda je číslo sudým násobkem deseti, například 10, 20, 30, 40 atd. Víte, že věta</p>
                           <pre class="wp-block-preformatted">10 MOD</pre>
                           <p> dělí deseti a vrací pouze zbytek. Sudý násobek deseti by dal nulový zbytek, takže věta</p>
                           <pre class="wp-block-preformatted">10 MOD 0=</pre>
                           <p>dává příslušný příznak "true" nebo "false".</p>
                           <p>Dalším zajímavým výsledkem je, že můžete použít - (minus) jako operátor porovnání, který testuje, zda se dvě hodnoty "nerovnají". Když odečtete dvě stejná čísla, dostanete nulu (false); když odečtete dvě nestejná čísla, dostanete nenulovou hodnotu. Nyní si však musíme říci něco o "dobře formulovaných příznacích" </p>.
                           <p>Pokud se nad tím zamyslíte, tak 0= i INVERT dělají téměř totéž. Nicméně 0= změní číslo 0 na číslo -1 a jakékoliv nenulové číslo na 0, zatímco INVERT změní všechny nulové bity v čísle na jedničkové a jedničkové bity v tomto čísle na nulové. Pouze v případě, že číslo je "dobře utvořený příznak", tj. buď 0, nebo -1, je výsledek 0= a INVERT stejný. Všechny porovnávací operátory vracejí dobře zformované příznaky, vhodné buď pro 0=, nebo pro INVERT. Pokud však použijete - k porovnání dvou čísel, jak jsme to udělali výše, nebude příznak dobře zformovaný, pokud se obě čísla liší hodnotou, a k bezpečnému obrácení významu porovnání lze použít pouze 0=.</p>
                           <p>Konečný výsledek je popsán v následující části.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="200" height="132" src="./04-Conditional - IF...THEN Statements_files/ch4-artichoke.gif" alt="Testování více podmínek (příznaků)" class="wp-image-422"></figure>
                           </div>
                           <h3><span id="A_Little_Logic">Malá logika</span></h3>
                           <p>Je možné vzít několik příznaků z různých testů a spojit je do jednoho příznaku pro jeden příkaz IF. Můžete je kombinovat jako rozhodnutí "buď/anebo", ve kterém provedete dva srovnávací testy. Pokud je některý z testů nebo oba testy pravdivé, počítač něco provede. Pokud není pravdivý ani jeden z nich, neprovede to.</p>
                           <p>Uveďme si poněkud zjednodušený příklad, abychom vám ukázali, co máme na mysli. Řekněme, že chcete vypsat název "ARTICHOKE", pokud je vstupní číslo <em>buď</em> záporné <em>nebo</em> násobek deseti.</p>
                           <p>Jak to ve Forthu uděláte? Uvažujme větu:</p>
                           <pre class="wp-block-preformatted">DUP 0&lt; SWAP 10 MOD 0= +</pre>
                           <p>Takto se stane, když je vstupní číslo řekněme 30:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td><strong>Operace</strong></td>
                                    <td><strong>Stack</strong></td>
                                    <td><strong>Popis</strong></td>
                                 </tr>
                                 <tr>
                                    <td></td>
                                    <td>30</td>
                                    <td>Výstupní hodnota</td>
                                 </tr>
                                 <tr>
                                    <td>DUP</td>
                                    <td>30 30</td>
                                    <td>Duplikát pro test</td>
                                 </tr>
                                 <tr>
                                    <td>0&lt;</td>
                                    <td>30 0</td>
                                    <td>Je negativní? False</td>
                                 </tr>
                                 <tr>
                                    <td>SWAP</td>
                                    <td>0 30</td>
                                    <td>Swap číslo s příznakem</td>
                                 </tr>
                                 <tr>
                                    <td>10 MOD 0=</td>
                                    <td>0 -1</td>
                                    <td>Je dělitelný deseti? Pravda</td>
                                 </tr>
                                 <tr>
                                    <td>+</td>
                                    <td>-1</td>
                                    <td>Přidání příznaků</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Přidává příznaky? Co se stane, když přidáte příznaky? Zde jsou čtyři možnosti:</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="191" src="./04-Conditional - IF...THEN Statements_files/ch4-flag-or.gif" alt="Přidání příznaků true/false pro jeden výsledek" class="wp-image-423"></figure>
                           <p>Hle, příznak výsledku je pravdivý, pokud je pravdivá jedna nebo obě podmínky. V tomto příkladu je výsledek -1, což znamená "pravda". Pokud by vstupní číslo bylo -30, pak by byly pravdivé obě podmínky a součet by byl mínus dva. Mínus dva je samozřejmě nenulový součet. Pokud tedy jde o IF, -2 je stejně pravdivé jako -1.</p>
                           <p>Naše zjednodušená definice by tedy zněla:</p>
                           <pre class="wp-block-preformatted">: VEGETABLE DUP 0&lt; SWAP 10 MOD 0= + IF ." ARTICHOKE " THEN ;</pre>
                           <p>Tady je vylepšená verze předchozího příkladu s názvem ?DAY.</p>
                           <p>Starý příklad ?DAY zachycoval pouze položky starší třiceti jedna let. Ale ani záporná čísla by neměla být povolena. Co třeba toto:</p>
                           <pre class="wp-block-preformatted">: ?DAY DUP 1 &lt; SWAP 31 &gt; + IF ." V žádném případě " ELSE ." Vypadá to dobře " THEN ;</pre>
                           <p>Dva výše uvedené příklady budou vždy fungovat, protože jakýkoli příznak "true" bude vždy přesně "-1". V některých případech však může být příznakem jakákoli nenulová hodnota, nikoli pouze "-1", a v takovém případě je nebezpečné je sčítat pomocí +. Například:</p>
                           <pre class="wp-block-preformatted">1 -1 + .↵<span class="output">0 ok </span></pre>
                           <p>dá nám matematicky správnou odpověď, ale ne tu, kterou chceme, pokud jsou 1 a -1 příznaky.</p>
                           <p>Z tohoto důvodu Forth dodává slovo nazvané OR, které vrátí správný příznak i v případě 1 a -1. "Rozhodnutí nebo" je počítačový termín pro druh příznaku, o kterém jsme hovořili. Například pokud jsou otevřené buď přední dveře <em>nebo</em> zadní dveře (nebo obojí), dovnitř vletí mouchy.</p>
                           <p>Jiný druh rozhodnutí se nazývá rozhodnutí "a". V rozhodnutí "a" musí být splněny <em>obě</em> podmínky, aby byl výsledek pravdivý. Například přední dveře <em>i</em> zadní dveře musí být oboje otevřené, aby mohl vniknout vánek. Pokud jsou tři nebo více podmínek, musí být všechny pravdivé.</p>
                           <div class="sc-info-box normal">
                              <h3><span id="Pro_zvědavého_nováčka">Pro zvědavého nováčka</span></h5>
                              Použití slov jako "nebo" a "a" ke strukturování části aplikace se nazývá "logika". Formu zápisu logických výroků vyvinul v devatenáctém století George Boole; dnes se nazývá Booleova algebra. Termín "booleovský příznak" (nebo dokonce jen "booleovka") tedy jednoduše označuje příznak, který bude použit v logickém příkazu.
                           </div>
                           <p>Jak můžeme toto "a rozhodnutí" provést ve Forthu? Pomocí šikovného slova AND. Zde je uvedeno, co by AND udělalo se čtyřmi možnými kombinacemi příznaků, které jsme viděli dříve:</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="185" src="./04-Conditional - IF...THEN Statements_files/ch4-flag-and.gif" alt="Logické příkazy AND a OR pro logiku Boolean ve Forthu" class="wp-image-424"></figure>
                           <p>Jinými slovy, pouze kombinace "-1 -1 AND" dává výsledek "true". Řekněme, že hledáme kartonovou krabici, která je dostatečně velká, aby se do ní vešla disková jednotka o rozměrech:</p>
                           <pre class="wp-block-preformatted">výška 6"<br>šířka 19"<br>délka 22"</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="78" src="./04-Conditional - IF...THEN Statements_files/ch4-box.gif" alt="Testování více hodnot na pravdivost před příkazem if...then" class="wp-image-425"></figure>
                           </div>
                           <p>Podmínky výšky, šířky, <em>a</em> délky musí být splněny, aby byl box dostatečně velký. Pokud máme rozměry na zásobníku, můžeme definovat:</p>
                           <pre class="wp-block-preformatted">: BOXTEST ( délka šířka výška -- )<br> 6 &gt; ROT 22 &gt; ROT 19 &gt; AND AND IF ." Dostatečně velký " THEN ;</pre>
                           <p>Všimněte si, že jsme dovnitř definice vložili komentář, který nám připomíná efekty zásobníku. To je moudré zejména v případech, kdy je pořadí zásobníku potenciálně matoucí nebo těžko zapamatovatelné.</p>
                           <p>Boxest můžete otestovat pomocí následující věty:</p>
                           <pre class="wp-block-preformatted">23 20 7 BOXTEST↵<span class="output">Dostatečně velký ok </span></pre>
                           <p>Jakmile se vaše aplikace stanou sofistikovanějšími, budete moci psát příkazy v jazyce Forth, které vypadají jako postfixová čeština a jsou velmi snadno čitelné. Stačí definovat jednotlivá slova v rámci definice tak, aby někde kontrolovala nějakou podmínku, a pak nechat příznak na zásobníku.</p>
                           <p>Příkladem je:</p>
                           <pre class="wp-block-preformatted">: SNAPSHOT LIGHT? FILM? AND IF PHOTOGRAPH THEN ;</pre>
                           <p>který před pořízením snímku zkontroluje, zda je k dispozici světlo a zda je ve fotoaparátu film. Dalším příkladem, který by mohl být použit v počítačové aplikaci pro datování, je:</p>
                           <pre class="wp-block-preformatted">: MATCH<br> HUMORNÝ SENSITIVNÍ A<br> UMĚNÍ.MILUJÍCÍ HUDBU.MILUJÍCÍ NEBO A KOUŘENÍ 0= AŽ ." Mám někoho, s kým byste se měli seznámit " POTOM ;</pre>
                           <p>kde slova jako HUMORNÝ a SENSITIVNÍ byla definována pro kontrolu záznamu v diskovém souboru, který obsahuje informace o dalších uchazečích příslušného pohlaví.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="160" height="79" src="./04-Conditional - IF...THEN Statements_files/ch4-pronounce-2.gif" alt="?DUP podmíněné testy pro true/false jako IF" class="wp-image-426"></figure>
                           </div>
                           <h3><span id="Dvě_slova_se_zabudovaným_IF">Dvě slova se zabudovaným IF</span></h3>
                           <p><strong><code>?DUP</code></strong><br>Slovo ?DUP duplikuje horní hodnotu zásobníku pouze v případě, že je nenulová. Tím lze eliminovat několik přebytečných slov. Například definice:</p>
                           <pre class="wp-block-preformatted">: /CHECK DUP IF / ELSE DROP THEN ;</pre>
                           <p> lze zkrátit na</p>
                           <pre class="wp-block-preformatted">: /CHECK ?DUP IF / THEN ;</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="160" height="223" src="./04-Conditional - IF...THEN Statements_files/ch4-abort.gif" alt="ABORT-quote testuje true/false jako IF" class="wp-image-427"></figure>
                           </div>
                           <p><strong><code>ABORT"</code></strong><br>Může se stát, že někde ve složité aplikaci může dojít k chybě (například dělení nulou), a to hluboko v některém z nízkoúrovňových slov. Když se to stane, nechcete, aby počítač jen tak pokračoval v práci, a také nechcete, aby na zásobníku něco zanechal.</p>
                           <p>Pokud se domníváte, že by k takové chybě mohlo dojít, můžete použít slovo ABORT". ABORT" očekává příznak na zásobníku: příznak "true" mu říká, aby "přerušil", což zase vyčistí zásobník a vrátí provádění do terminálu, kde čeká, až někdo něco napíše. ABORT" také vypíše jméno posledního interpretovaného slova a libovolnou zprávu.</p>
                           <p>Představíme si to na příkladu. Doufáme, že už vás /CHECK neomrzel, protože zde je další verze:</p>
                           <pre class="wp-block-preformatted">: /CHECK DUP 0= ABORT" nulový jmenovatel " / ;</pre>
                           <p>V této verzi, pokud je jmenovatel nulový, budou všechna čísla, která se náhodou nacházejí na zásobníku, vypuštěna a terminál zobrazí:</p>
                           <pre class="wp-block-preformatted">8 0 /CHECK Chyba -2 nulový jmenovatel ?</pre>
                           <p>Jen jako experiment zkuste vložit /CHECK do jiné definice:</p>
                           <pre class="wp-block-preformatted">: ENVELOPE /CHECK ." Odpověď je " . ;</pre>
                           <p>a zkuste</p>
                           <pre class="wp-block-preformatted">8 4 ENVELOPE↵Odpověď je 2 ok <br>8 0 ENVELOPE Chyba -2 nulový jmenovatel ?</pre>
                           <p>Jde o to, že když se /CHECK přeruší, zbytek ENVELOPE se přeskočí.</p>
                           <div class="sc-info-box normal full">
                              <h3><span id="Pro_počítačové_filozofy">Pro počítačové filozofy</span></h5>
                              Forth zajišťuje určitou kontrolu chyb automaticky. Protože je však operační systém Forth velmi snadno modifikovatelný, mohou uživatelé snadno ovlivnit množství chybových kontrol, které jejich systém provede. Tato flexibilita umožňuje uživatelům vytvářet vlastní kompromisy mezi pohodlím a rychlostí provádění.
                           </div>
                           <h3><span id="Chapter_Summary">Shrnutí kapitoly</span></h3>
                           <h3><span id="Forth_Words">Slovníček</span></h5>
                           <p>Tady je slovníček slovíček jazyka Forth, kterými jsme se zabývali v této kapitole:</p>
                           <dl class="forth">
                              <dt>IF</dt>
                              <dt>( flag - )</dt>
                              <dd>
                                 Pokud je <em>flag</em> true (nenulový), provede se <em>xxx</em>; v opačném případě se provede <em>yyy</em>; pokračuje se <em>zzz</em>. Výraz ELSE <em>yyy</em> je nepovinný.
                                 <pre>IF xxx THEN zzz
IF xxx ELSE yyy THEN zzz
</pre>
                              </dd>
                              <dt>=</dt>
                              <dt>( n1 n2 - flag )</dt>
                              <dd>Vrátí true, pokud se n1 a n2 rovnají.</dd>
                              <dt>&lt;&gt;</dt>
                              <dt>( n1 n2 - flag )</dt>
                              <dd>Vrátí true, pokud se n1 a n2 nerovnají.</dd>
                              <dt>&lt;</dt>
                              <dt>( n1 n2 - flag )</dt>
                              <dd>Vrací true, pokud je n1 menší než n2.</dd>
                              <dt>&gt;</dt>
                              <dt>( n1 n2 - flag )</dt>
                              <dd>Vrací true, pokud je n1 větší než n2.</dd>
                              <dt>0=</dt>
                              <dt>( n - flag )</dt>
                              <dd>Vrátí true, pokud je n rovno nule.</dd>
                              <dt>0&lt;</dt>Překlad: 0&lt;</dt>
                              <dt>( n - flag )</dt>
                              <dd>Vrátí true, pokud je n záporné.</dd>
                              <dt>0&gt;</dt>Překlad: 0&gt;</dt>
                              <dt>( n - flag )</dt>
                              <dd>Vrací true, pokud je n kladné.</dd>
                              <dt>AND</dt>
                              <dt>( n1 n2 - n3 )</dt>
                              <dd>Vrátí logické AND.</dd>
                              <dt>OR</dt>
                              <dt>( n1 n2 - n3 )</dt>.
                              <dd>Vrací logické OR.</dd>
                              <dt>?DUP</dt>
                              <dt>( n - n n ) nebo ( 0 - 0 )</dt>.
                              <dd>Duplikuje pouze v případě, že n je nenulové.</dd>
                              <dt>ABORT" xx"</dt>
                              <dt>( flag - )</dt>
                              <dd>Pokud je příznak true, vypíše chybové hlášení, za kterým následuje text. Také vyčistí zásobníky a vrátí řízení terminálu. Pokud je false, neprovede žádnou akci.</dd>
                           </dl>
                           <h3><span id="Review_of_Terms">Přehled podmínek</span></h5>
                           <dl>
                              <dt>Přerušit</dt>
                              <dd>jako obecný počítačový termín náhle ukončit provádění programu, pokud nastane stav, na který není program navržen, aby se zabránilo vzniku nesmyslů nebo případnému poškození.</dd>
                              <dt>"A" rozhodnutí</dt>
                              <dd>dvě podmínky, které jsou kombinovány tak, že pokud jsou obě pravdivé, výsledek je pravdivý.</dd>
                              <dt>Rozdělení</dt>
                              <dd>porušení normálně přímočarého průběhu provádění v závislosti na podmínkách platných v okamžiku provádění. Větvení umožňuje počítači reagovat na různé podmínky různě.</dd>
                              <dt>Operátor porovnání</dt>
                              <dd>obecně příkaz, který porovnává jednu hodnotu s jinou (například určuje, zda je jedna větší než druhá), a podle toho nastavuje příznak, který se obvykle kontroluje podmíněným operátorem. Ve Forthu porovnávací operátor ponechává příznak na zásobníku </dd>.
                              <dt>Příznak</dt>
                              <dd>jako obecný počítačový termín, hodnota uložená v paměti, která slouží jako signál, zda je nějaká známá podmínka pravdivá nebo nepravdivá. Jakmile je "příznak nastaven", může jej podle potřeby kontrolovat (nebo resetovat) libovolný počet rutin v různých částech programu.</dd>
                              <dt>Logika</dt>
                              <dd>v počítačové terminologii systém reprezentace podmínek ve formě "logických proměnných", které mohou být buď pravdivé, nebo nepravdivé, a kombinování těchto proměnných pomocí "logických operátorů", jako jsou "a", "nebo" a "ne", za účelem vytvoření příkazů, které mohou být pravdivé nebo nepravdivé.</dd>
                              <dt>Nesting</dt>
                              <dd>umístění větvící struktury uvnitř vnější větvící struktury.</dd>
                              <dt>Rozhodnutí "nebo"</dt>.
                              <dd>dvě podmínky, které jsou zkombinovány tak, že pokud je kterákoli z nich pravdivá, výsledek je pravdivý.</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="aligncenter"><img loading="lazy" width="230" height="100" src="./04-Conditional - IF...THEN Statements_files/felix.gif" alt="Programovací jazyk Forth - příklady" class="wp-image-353"></figure>
                           </div>
                           <h3><span id="Problémy_kapitola_4">Problémy - kapitola 4</span></h5>
                           <ol class="sf-numbered">
                              <li>
                                 Jaká bude věta
                                 <pre> 0= 0=</pre>
                                 <p>zůstane na zásobníku, když argument je</p>
                                 <pre> -1?          0? 200?<br></pre>
                              </li>
                              <li>Vysvětlete, co s tím vším má společného artičok.</li>
                              <li>
                                 Definujte slovo s názvem CARD, které při zadání věku osoby na zásobníku vypíše jednu z těchto dvou zpráv (v závislosti na příslušných zákonech ve vaší oblasti):
                                 <pre> ALKOHOLICKÉ NÁPOJE POVOLENY nebo PODLE VĚKU<br></pre>
                              </li>
                              <li>
                                 Definujte slovo s názvem SIGN.TEST, které otestuje číslo na zásobníku a vypíše jednu ze tří zpráv:
                                 <pre> POZITIVNÍ nebo NULA nebo NEGATIVNÍ<br></pre>
                              </li>
                              <li>
                                 V kap. 1 jsme definovali slovo s názvem HVĚZDIČKY tak, že vždy vytiskne alespoň jednu hvězdičku, i když řeknete
                                 <pre> 0 STARS↵<span class="output">* ok </span></pre>
                                 <p>Pomocí slova STARS definujte novou verzi STARS, která tento problém odstraní.&nbsp;</p>
                              </li>
                              <li>
                                 <p><span style="font-size: inherit;">Napište definici slova WITHIN, které očekává tři argumenty:</span></p>
                                 <pre> ( n lo-limit hi-limit -- )</pre>
                                 <p>a zanechá příznak "true" pouze v případě, že "n" je uvnitř rozsahu</p>
                                 <pre> low-limit &lt;= n &lt; hi-limit<br></pre>
                              </li>
                              <li>
                                 Zde je hra na hádání čísel (jejíž psaní vás možná bude bavit víc než hraní kohokoli jiného). Nejprve tajně zadáte číslo na zásobník (po zadání čísla jej můžete skrýt provedením slova PAGE, které vymaže obrazovku terminálu). Poté požádáte jiného hráče, aby zadal tip, za kterým následuje slovo GUESS, jako např.
                                 <pre> 100 GUESS</pre>
                                 <p>Počítač odpoví buď "PŘÍLIŠ VYSOKÉ", "PŘÍLIŠ NÍZKÉ", nebo "SPRÁVNÉ!". Napište definici GUESS a ujistěte se, že číslo odpovědi zůstane na zásobníku díky opakovanému hádání, dokud není uhodnuta správná odpověď, po které by měl být zásobník prázdný.&nbsp;</p>
                              </li>
                              <li>
                                 <p><span style="font-size: inherit;">Pomocí vnořených testů a příkazů IF...ELSE...THEN napište definici s názvem SPELLER, která bude na zásobníku hláskovat číslo od -4 do 4. Pokud bude číslo mimo tento rozsah, vypíše zprávu "OUT OF RANGE". Například:</span></p>
                                 <pre> 2 SPELLER↵<span class="output">dvojka ok </span> -4 SPELLER↵<span class="output">záporná čtyřka ok </span> 7 SPELLER↵<span class="output">OUT OF RANGE ok </span></pre>
                                 <p>Udělejte to co nejkratší. (Tip: Forthovské slovo ABS udává absolutní hodnotu čísla na zásobníku)</p>.
                              </li>
                              <li>
                                 <p><span style="font-size: inherit;">S využitím definice slova WITHIN z Problému 6 napište další hru na hádání čísel, nazvanou TRAP, ve které nejprve zadáte tajnou hodnotu a pak se ji druhý hráč pokusí doměřit tím, že ji uvězní mezi dvěma čísly, jako v tomto dialogu:</span></p>
                                 <pre> 0 1000 TRAP↵<span class="output">BETWEEN ok </span> 330 660 TRAP↵<span class="output">BETWEEN ok </span> 440 550 TRAP↵<span class="output">NOT BETWEEN ok </span> 330 440 TRAP↵<span class="output">BETWEEN ok </span></pre>
                                 <p>a tak dále, dokud hráč neuhodne odpověď:</p>
                                 <pre> 391 391 TRAP↵<span class="output">VYHRAJEŠ! ok </span></pre>
                                 <p>Nápověda: možná budete muset upravit argumenty na WITHIN, aby TRAP neříkal "MEZI", když se pouze jeden z argumentů rovná skryté hodnotě.</p>
                              </li>
                           </ol>
                           <div class="wp-block-genesis-blocks-gb-accordion gb-block-accordion gb-font-size-18">
                              <details>
                                 <summary class="gb-accordion-title">Odpovědi</summary>
                                 <div class="gb-accordion-text">
                                    <ol>
                                       <li>
                                          <pre> -1 0= 0= ( true ) .
  0 0= 0= ( false ) .
200 0= 0= ( true ) .
</pre>
                                       </li>
                                       <li>Nic!</li>
                                       <br>
                                       <li>
                                          <pre>: CARD ( věk -- )
   17 &gt; IF ." ALKOHOLICKÉ NÁPOJE POVOLENY " ELSE ." POD VĚKOVOU HRANICÍ " THEN ;
</pre>
                                       </li>
                                       <li>
                                          <pre>: SIGN.TEST ( n -- )
   DUP 0&lt; IF ." Negative " DROP EXIT THEN
       0&gt; IF ." Pozitivní " EXIT THEN
   ." Zero " ;
</pre>
                                       </li>
                                       <li>
                                          <pre>: STAR [CHAR] * EMIT ;
: STARS ( #stars -- ) 0 ?DO STAR LOOP ;
: STARS ( n -- ) ?DUP IF STARS THEN ;
</pre>
                                       </li>
                                       <li>
                                          <pre>: WITHIN ( n lo hi+1 -- flag ) OVER - &gt;R - R&gt; U&lt; ;
</pre>
                                       </li>
                                       <li>
                                          <pre>: GUESS ( odpověď guess -- odpověď )
   2DUP = IF ." Správně! " 2DROP EXIT THEN
   OVER &gt; IF ." Příliš vysoká " ELSE ." Příliš nízká " THEN ;
</pre>
                                       </li>
                                       <li>
                                          <pre>: .SIGN ( n -- |n| ) DUP 0&lt; IF ." Záporné " THEN ABS ;
: SPELER ( n -- )
   DUP ABS 4 &gt; IF ." Mimo rozsah "
      ELSE .SIGN
      DUP 0= IF ." Nula " ELSE
      DUP 1 = IF ." Jedna " ELSE
      DUP 2 = IF ." Dva " ELSE
      DUP 3 = IF ." Tři " ELSE
      ." Čtyři "
   PAK PAK PAK PAK PAK DROP ;
</pre>
                                       </li>
                                       <li>
                                          <pre>: WITHIN ( n lo hi+1 -- flag ) OVER - &gt;R - R&gt; U&lt; ;
: 3DUP ( a b c -- a b c a b c ) DUP 2OVER ROT ;
: TRAP ( odpověď lo-try hi-try -- odpověď | )
   3DUP OVER = ROT ROT = AND IF ." Máš to! " 2DROP DROP
      JINAK 3DUP SWAP 1+ SWAP WITHIN IF ." Mezi "
   ELSE ." Ne mezi " THEN 2DROP THEN ;
</pre>
                                       </li>
                                    </ol>
                                    <p></p>
                                 </div>
                              </details>
                           </div>
                        </div>
                     </div>
                  </article>
               </main>
            </div>
         </div>
      </div>
      <div class="site grid-container container hfeed grid-parent" id="page">
         <div class="site-content" id="content">
            <div class="content-area grid-parent mobile-grid-100 grid-70 tablet-grid-70" id="primary">
               <main class="site-main" id="main">
                  <article id="post-322" class="post-322 page type-page status-publish" itemtype="https://schema.org/CreativeWork" itemscope="">
                     <div class="inside-article">
                        <header class="entry-header" aria-label="Content">
                           <h2 class="entry-title" itemprop="headline">5. Filozofie pevného bodu</h2>
                        </header>
                        <div class="entry-content" itemprop="text">
                           <p>V této kapitole si představíme novou várku aritmetických operátorů. Cestou se budeme zabývat problémem práce s desetinnou čárkou pouze pomocí celočíselné aritmetiky.</p>
                           <h3><span id="Quickie_Operators">Rychlé operátory</span></h3>
                           <p>Začneme tím opravdu jednoduchým. Neměli byste mít problém zjistit, co slova v následující tabulce dělají.</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>1+</td>
                                    <td>( n1 - n2 )</td>
                                    <td>Přidá jedničku</td>
                                 </tr>
                                 <tr>
                                    <td>1-</td>
                                    <td>( n1 - n2 )</td>
                                    <td>Odčítá jedničku</td>
                                 </tr>
                                 <tr>
                                    <td>2+</td>
                                    <td>( n1 - n2 )</td>
                                    <td>Přičte dvě</td>
                                 </tr>
                                 <tr>
                                    <td>2-</td>
                                    <td>( n1 - n2 )</td>
                                    <td>Odčítá dvě</td>
                                 </tr>
                                 <tr>
                                    <td>2*</td>
                                    <td>( n1 - n2 )</td>
                                    <td>Sčítá dvěma<br>(Aritmetika <abbr title="Pro začátečníky: Později si vysvětlíme, co je &#39;aritmetický posun vlevo&#39;">posun vlevo</abbr>)</td>.
                                 </tr>
                                 <tr>
                                    <td>2/</td>
                                    <td>( n1 - n2 )</td>
                                    <td>Dělí dvěma<br>(aritmetický posun doprava)</td>
                                 </tr>
                              </tbody>
                           </table>
                           <div class="wp-block-image">
                              <figure class="alignright"><img width="100" height="197" src="./05-Fixed-Point Arithmetic_files/ch5-pronounce-1.gif" alt="běžné matematické operátory Forthu" class="wp-image-428"></figure>
                           </div>
                           <p>Jediným důvodem, proč používat slova jako 1+ místo 1 a +, je tradice. V moderních systémech Forth s optimalizátory kódu nešetří 1+ ani místo, ani čas kompilace nebo provádění </p>.
                           <h3><span id="Miscellaneous_Math_Operators">Různé matematické operátory</span></h3>
                           <p>Tady je tabulka čtyř různých matematických operátorů. Stejně jako u rychlých operátorů by tyto funkce měly být zřejmé z jejich názvů.</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>ABS</td>
                                    <td>( n1 - n2 )</td>
                                    <td>Vrací absolutní hodnotu</td>
                                 </tr>
                                 <tr>
                                    <td>NEGATE</td>
                                    <td>( n1 - n2 )</td>
                                    <td>Změní znaménko</td>
                                 </tr>
                                 <tr>
                                    <td>MIN</td>
                                    <td>( n1 n2 - min )</td>
                                    <td>Vrátí minimum</td>
                                 </tr>
                                 <tr>
                                    <td>MAX</td>
                                    <td>( n1 n2 - max)</td>
                                    <td>Vrátí maximum</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Tady jsou dvě jednoduché slovní úlohy s použitím ABS a MIN:</p>
                           <pre class="wp-block-preformatted">ABS

</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="160" height="150" src="./05-Fixed-Point Arithmetic_files/ch5-min-max.gif" alt="porovnání kladných a záporných čísel pomocí funkcí Forth&#39;MAX a MIN" class="wp-image-429"></figure>
                           </div>
                           <p>Napište definici, která vypočítá rozdíl dvou čísel bez ohledu na pořadí, v jakém jsou čísla zadána.</p>
                           <pre class="wp-block-preformatted">: ROZDÍL - ABS ;

</pre>
                           <p>Toto dává stejný výsledek, ať už zadáme</p>
                           <pre class="wp-block-preformatted">52 37 DIFFERENCE .↵<span class="output">&gt;15 ok </span>
37 52 DIFFERENCE .↵<span class="output">15 ok </span>
MIN

</pre>
                           <p>Napište definici, která vypočítá provizi, kterou prodejci nábytku obdrží, pokud jim bylo slíbeno 50 dolarů nebo 1/10 prodejní ceny, podle toho, co je menší, za každý uskutečněný prodej.</p>
                           <pre class="wp-block-preformatted">: PROVIZE 10 / 50 MIN ;

</pre>
                           <p>Tři různé hodnoty by vedly k těmto výsledkům:</p>
                           <pre class="wp-block-preformatted">600 KOMISE .↵√50 ok
450 KOMISE .↵√45 ok
 50 KOMISE .↵√5 ok

</pre>
                           <h3><span id="The_Return_Stack">Zásobník návratů</span></h3>
                           <p>Předtím jsme se zmínili, že ještě existují některé operátory pro manipulaci se zásobníkem, které jsme dosud neprobrali. Nyní je čas.</p>
                           <p>Dosud jsme mluvili o "zásobníku", jako by byl jen jeden. Ve skutečnosti však <abbr title="Většina Forthů má navíc zásobník s plovoucí desetinnou čárkou.">existují dva</abbr>: "zásobník parametrů" a "návratový zásobník". Zásobník parametrů používají programátoři Forthu častěji, takže pokud není důvod k pochybnostem, říká se mu jednoduše "zásobník".</p>
                           <p>Jak jste viděli, zásobník parametrů uchovává parametry (neboli "argumenty"), které se předávají ze slova do slova. Návratový zásobník však uchovává libovolný počet "ukazatelů", které systém Forth používá k tomu, aby se vesele prodíral bludištěm slov, která vykonávají jiná slova. Podrobněji si to vysvětlíme později.</p>
                           <p>Vy, uživatel, můžete návratový zásobník použít jako jakousi "ruku navíc", která dočasně uchovává hodnoty, zatímco provádíte operace na zásobníku parametrů.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="150" src="./05-Fixed-Point Arithmetic_files/ch5-return-stack.gif" alt="Návratový zásobník LIFO jazyka Forth&#39;neboli zásobník parametrů uchovává ukazatele na provedení" class="wp-image-430"></figure>
                           <p>Vratný zásobník je stejně jako zásobník parametrů strukturou typu "last-in first-out", takže může obsahovat mnoho hodnot. Má to však háček: cokoli vložíte do návratového zásobníku, musíte opět odstranit, než se dostanete na konec definice (středník), protože v tomto okamžiku bude systém Forth očekávat, že tam najde ukazatel. Návratový zásobník nemůžete použít k předávání parametrů z jednoho slova do druhého.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="150" src="./05-Fixed-Point Arithmetic_files/ch5-return-stack-2.gif" alt="Programátoři, kteří používají návratový zásobník, jej musí před ukončením vykonávání své funkce ponechat tak, jak byl." class="wp-image-431"></figure>
                           <p>Následující slovníček uvádí slova spojená s návratovým zásobníkem. Nezapomeňte, že zápis zásobníku se vztahuje k zásobníku <em>parametrů</em>.</p>
                           <dl class="forth">
                              <dt>&gt;R</dt>
                              <dt>( n - )</dt>
                              <dd>Vezme hodnotu ze zásobníku parametrů a přesune ji na návratový zásobník.</dd>
                              <dt>R&gt;</dt>.
                              <dt>( - n )</dt>
                              <dd>Vezme hodnotu z návratového zásobníku a posune ji na zásobník parametrů.</dd>
                              <dt>R@</dt>
                              <dt>( - n )</dt>
                              <dd>Vybere horní položku z návratového zásobníku a přesune ji na zásobník parametrů.</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="216" src="./05-Fixed-Point Arithmetic_files/ch5-pronounce-2.gif" alt="" class="wp-image-432"></figure>
                           </div>
                           <p>Slova &gt;R a R&gt; přenášejí hodnotu na návratový zásobník, resp. z návratového zásobníku. Řekněme, že chceme následující efekt zásobníku:</p>
                           <pre class="wp-block-preformatted">( 2 3 1 -- 3 2 1 )

</pre>
                           <p>tohle je věta, která to udělá:</p>
                           <pre class="wp-block-preformatted">&gt;R SWAP R&gt;

</pre>
                           <p>Každé &gt;R a jemu odpovídající R&gt; musí být použity společně v jedné definici.</p>
                           <p>Zbývající slovo R@ pouze <em>kopíruje</em> hodnoty z návratového zásobníku, aniž by je odstranilo. Tedy věta:</p>
                           <pre class="wp-block-preformatted">&gt;R SWAP R@

</pre>
                           <p>by sice přinesla stejný výsledek, pokud jde o to, co se děje, ale pokud před dalším středníkem neuklidíte koš, dojde k pádu systému.</p>
                           <p>Abyste viděli, jak lze použít &gt;R, R&gt;, R@ a I, představte si, že máte takovou smůlu a potřebujete vyřešit rovnici:</p>
                           <pre class="wp-block-preformatted">ax<sup>2</sup> + bx + c

</pre>
                           <p>se <em>všemi čtyřmi</em> hodnotami na zásobníku v následujícím pořadí:</p>
                           <pre class="wp-block-preformatted">( a b c x -- )

</pre>
                           <p>(nezapomeňte nejprve vynásobit).</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td><strong>Operátor</strong></td>
                                    <td><strong>Zásobník parametrů</strong></td>
                                    <td><strong>Zásobník návratových parametrů</strong></td>
                                 </tr>
                                 <tr>
                                    <td></td>
                                    <td>a b c x</td>
                                    <td></td>
                                 </tr>
                                 <tr>
                                    <td>&gt;R</td>
                                    <td>a b c</td>
                                    <td>x</td>
                                 </tr>
                                 <tr>
                                    <td>SWAP ROT</td>
                                    <td>c b a</td>
                                    <td>x</td>
                                 </tr>
                                 <tr>
                                    <td>R@</td>
                                    <td>c b a x</td>
                                    <td>x</td>
                                 </tr>
                                 <tr>
                                    <td>*</td>
                                    <td>c b ax</td>
                                    <td>x</td>
                                 </tr>
                                 <tr>
                                    <td>+</td>
                                    <td>c ax+b</td>
                                    <td>x</td>
                                 </tr>
                                 <tr>
                                    <td>R&gt; *</td>
                                    <td>c x(ax+b)</td>
                                    <td></td>
                                 </tr>
                                 <tr>
                                    <td>+</td>
                                    <td>x(ax+b)+c</td>
                                    <td></td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Pokračujte a vyzkoušejte si to. Načtěte následující definici:</p>
                           <pre class="wp-block-preformatted">: QUADRATIC ( a b c x -- n ) &gt;R SWAP ROT R@ * + R&gt; * + ;</pre>
                           <p>Teď to vyzkoušejte:</p>
                           <pre class="wp-block-preformatted">2 7 9 3 QUADRATIC .↵<span class="output">48 ok </span></pre>
                           <h3><span id="An_Introduction_to_Floating-Point_Arithmetic">Úvod do aritmetiky s plovoucí desetinnou čárkou</span></h3>
                           <p>Nejprve si řekněme, co znamená pojem plovoucí desetinná čárka? Vezměme si například kapesní kalkulačku. Takto vypadá displej po každém kroku:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td><strong>Zadáváte:</strong></td>
                                    <td><strong>Zobrazí se:</strong></td>
                                 </tr>
                                 <tr>
                                    <td>1 . 5 0 x</td>
                                    <td>1,5</td>
                                 </tr>
                                 <tr>
                                    <td>2 . 2 3</td>
                                    <td>2,23</td>
                                 </tr>
                                 <tr>
                                    <td>=</td>
                                    <td>3,345</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Desetinná tečka "plave" po displeji podle potřeby. Tomu se říká "zobrazení s pohyblivou desetinnou čárkou" </p>.
                           <p>"Zobrazení s pohyblivou desetinnou čárkou" je způsob ukládání čísel do paměti počítače pomocí určité formy vědeckého zápisu. Ve vědecké notaci se dvanáct milionů zapisuje takto:</p>
                           <p>12 x 10<sup>6</sup></p>
                           <p>protože deset na šestou mocninu se rovná jednomu milionu. V počítači by dvanáct milionů mohlo být uloženo jako dvě čísla: 12 a 6, kde se rozumí, že 6 je mocnina deseti, kterou se násobí 12, zatímco 3,345 by mohlo být uloženo jako 3345 a -3.</p>
                           <p>Smysl reprezentace s pohyblivou řádovou čárkou spočívá v tom, že počítač může reprezentovat obrovský rozsah čísel, od atomárních až po astronomická, pomocí dvou relativně malých čísel.</p>
                           <p>Co je reprezentace s pevnou řádovou čárkou? Je to jednoduše metoda ukládání čísel do paměti bez ukládání pozic desetinné čárky každého čísla. Například při práci s dolary a centy lze všechny hodnoty uložit v centech. Místo každého jednotlivého <em>čísla</em> si může polohu desetinné čárky pamatovat <em>program</em>.</p>
                           <p>Příklad porovnejme reprezentaci hodnot v dolarech a centech s pevnou a pohyblivou desetinnou čárkou.</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td><strong>Reálná hodnota:</strong></td>
                                    <td><strong>Pravá hodnota:</strong></td>
                                    <td><strong>Plochá hodnota :</strong></td>
                                 </tr>
                                 <tr>
                                    <td>1,23</td>
                                    <td>123</td>
                                    <td>123(-2)</td>
                                 </tr>
                                 <tr>
                                    <td>10,98</td>
                                    <td>1098</td>
                                    <td>1098(-2)</td>
                                 </tr>
                                 <tr>
                                    <td>100.00</td>
                                    <td>10000</td>
                                    <td>1(2)</td>
                                 </tr>
                                 <tr>
                                    <td>58,60</td>
                                    <td>5860</td>
                                    <td>586(-1)</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Jak vidíte , u pevného bodu musí všechny hodnoty odpovídat stejnému "měřítku". Desetinné tečky musí být správně "zarovnány" (v tomto případě o dvě místa dovnitř zprava), i když ve skutečnosti nejsou zastoupeny. Při použití pevné řádové čárky počítač zachází se všemi čísly, jako by to byla celá čísla. Pokud však program potřebuje odpověď vytisknout, jednoduše vloží desetinnou čárku o dvě místa zprava, než číslo odešle na terminál nebo na tiskárnu.</p>
                           <h3><span id="Why_Fixed-Point_is_Useful">Proč je pevná čárka užitečná</span></h3>
                           <p>Programátora jazyka Forth nejvíce zajímá maximální efektivita stroje. To znamená, že chce, aby program běžel co nejrychleji a vyžadoval co nejméně paměti počítače. Bohužel ne všechny procesory nebo řadiče nabízejí hardwarovou podporu plovoucí desetinné čárky. Proto jsou v některých prostředích programy využívající funkce s plovoucí desetinnou čárkou přesměrovány přes emulační knihovnu. Emulační kód může být až třikrát pomalejší než ekvivalentní výpočet s pevnou řádovou čárkou. Tento rozdíl je samozřejmě skutečně patrný pouze u programů, které musí provést mnoho výpočtů před odesláním výsledků do terminálu nebo provedením nějaké akce. Háček je v tom, že kód z emulační knihovny je také mnohonásobně větší než jeho protějšek s pevnou řádovou čárkou, což je pro malé vestavné řadiče a podobně dost neekonomické.</p>
                           <p>Měli byste si pečlivě uvědomit, že <em>pokud</em> procesor podporuje hardwarovou plovoucí desetinnou čárku, je téměř vždy mnohem rychlejší a kompaktnější než ekvivalent s pevnou desetinnou čárkou. Rozdíl v rychlosti může být 3 až 15násobný.</p>
                           <p>Všechno, co můžete dělat s plovoucí desetinnou čárkou, můžete dělat i s pevnou desetinnou čárkou, jak si ukážeme v následujícím textu. Jednu věc byste však měli co nejvíce minimalizovat, a to je přepínání mezi formáty s pevnou a plovoucí desetinnou čárkou. Převod formátu a další kroky škálování stojí stejně nebo dokonce více času než samotné provádění výpočtů.</p>
                           <p>Forma pomáhá programátorům používat pevnou desetinnou čárku tím, že jim poskytuje jedinečnou sadu vysokoúrovňových příkazů zvaných "operátory škálování". První z těchto příkazů si představíme v následující části. (Závěrečný příklad v <a href="https://www.forth.com/starting-forth/12-forth-code-examples/">kapitole 12</a> ilustruje použití škálovacích technik.)</p>
                           <h3><span id="Hvězdicový_skalár">Hvězdicový_skalár</span></h3>
                           <p>Tady je matematický operátor, který je stejně užitečný jako neobvyklý: <code>*/</code>.</p>
                           <dl class="forth">
                              <dt>*/</dt>
                              <dt>( n1 n2 n3 - n4 )</dt>
                              <dd>Násobí, pak dělí (n1*n2/n3). Používá dvojnásobně dlouhý mezivýsledek.</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="140" height="253" src="./05-Fixed-Point Arithmetic_files/ch5-pronounce-3.gif" alt="*/ škáluje hodnoty, například při výpočtu procent." class="wp-image-433"></figure>
                           </div>
                           <p>Jak již název napovídá, */ provádí násobení a poté dělení. Řekněme, že zásobník obsahuje například tato tři čísla:</p>
                           <pre class="wp-block-preformatted">( 225 32 100 -- )

</pre>
                           <p>*/ nejprve vynásobí 225 číslem 32 a poté výsledek vydělí číslem 100.</p>
                           <p>Tento operátor je užitečný zejména jako celočíselné aritmetické řešení problémů, jako jsou výpočty procent.</p>
                           <p>Příklad můžete definovat slovo % takto:</p>
                           <pre class="wp-block-preformatted">: % 100 */ ;

</pre>
                           <p>tak, že zadáním čísla 225 a následně výrazu:</p>
                           <pre class="wp-block-preformatted">32 %

</pre>
                           <p>Způsob, kdy nejprve vynásobíme dvě celá čísla a poté je vydělíme 100, je totožný s postupem, který většina lidí používá při řešení takovýchto úloh na papíře:</p>
                           <pre class="wp-block-preformatted"> 225
 0.32 x
 4.50
67.5
72.00
</pre>
                           <p>*/ není * a / hozené dohromady. Používá "dvojnásobně dlouhý mezivýsledek". Ptáte se, co to znamená?</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="187" src="./05-Fixed-Point Arithmetic_files/ch5-star-slash.gif" alt="*/ používá dvojnásobně dlouhý mezivýsledek, aby se zachovala správná hodnota" class="wp-image-434"></figure>
                           <p>Řekněme, že chcete vypočítat 34 % z 912 345 678. Nezapomeňte, že operátory s jednou přesností, jako jsou * a /, pracují pouze s argumenty a výsledky v rozsahu čísla jedné délky. Pokud byste zadali větu:</p>
                           <pre class="wp-block-preformatted">912345678 34 * 100 /

</pre>
                           <p>získali byste nesprávný výsledek, protože "mezivýsledek" (v tomto případě výsledek násobení), přesahuje 2147483647, jak ukazuje levý sloupec této obrázkové simulace.</p>
                           <p>Ale */ používá dvojnásobně dlouhý mezivýsledek, takže jeho rozsah bude dostatečně velký na to, aby pojal výsledek násobení jakýchkoli dvou jednočísel. Výraz:</p>
                           <pre class="wp-block-preformatted">912345678 34 100 */

</pre>
                           <p>vrátí správnou odpověď, protože konečný výsledek spadá do rozsahu jednočíselných čísel.</p>
                           <p>Předchozí příklad vyvolává další otázku: jak zaokrouhlovat </p>.
                           <p>Předpokládejme, že se jedná o tento problém:</p>
                           <blockquote class="wp-block-quote">
                              <p>Pokud si 32 % studentů stravujících se ve školní jídelně obvykle kupuje banány, kolik banánů by mělo být po ruce pro 225 lidí? Samozřejmě nás zajímají pouze celé banány, takže případný desetinný zbytek bychom rádi zaokrouhlili.</p>
                           </blockquote>
                           <p>Podle naší definice nyní jakoukoli hodnotu napravo od desetinného čísla jednoduše vynecháme. Jinými slovy, výsledek je "zkrácený".</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>32 % z:</td>
                                    <td>Výsledek:</td>
                                 </tr>
                                 <tr>
                                    <td>225 = 72,00</td>
                                    <td>72 - přesně správně</td>
                                 </tr>
                                 <tr>
                                    <td>226 = 72.32</td>
                                    <td>72 - správně, zaokrouhleno dolů (zkráceno)</td>
                                 </tr>
                                 <tr>
                                    <td>227 = 72,64</td>
                                    <td>72 - zkráceno, nezaokrouhleno</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Existuje však způsob, jak při jakékoli desetinné hodnotě 0,5 nebo vyšší zaokrouhlit nahoru na další celý banán. Mohli bychom definovat slovo R%, pro "zaokrouhlené procento", takto:</p>
                           <pre class="wp-block-preformatted">: R% 10 */ 5 + 10 / ;

</pre>
                           <p>tak, aby výraz:</p>
                           <pre class="wp-block-preformatted">227 32 R% .

</pre>
                           <p>dá 73, což je správně zaokrouhleno nahoru.</p>
                           <p>Všimněte si, že nejprve dělíme deseti, nikoliv sto. Tím získáme další desetinné místo, se kterým můžeme pracovat a ke kterému můžeme přičíst pět:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>Operace</td>
                                    <td>Obsah zásobníku</td>
                                 </tr>
                                 <tr>
                                    <td></td>
                                    <td>227 32 10</td>
                                 </tr>
                                 <tr>
                                    <td>*/</td>
                                    <td>726</td>
                                 </tr>
                                 <tr>
                                    <td>5 +</td>
                                    <td>731</td>
                                 </tr>
                                 <tr>
                                    <td>10 /</td>
                                    <td>73</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Závěrečné dělení deseti nastaví hodnotu na správnou desetinnou pozici.</p>
                           <p>Nevýhodou tohoto způsobu zaokrouhlování je, že v konečném výsledku ztrácíte jedno desetinné místo rozsahu; to znamená, že může být pouze 214 748 364 místo 2 147 483 647. Pokud vám to však vadí, můžete vždy použít čísla s dvojnásobnou délkou, která si představíme později, a stále budete moci zaokrouhlovat.</p>
                           <h3><span id="Some_Perspective_on_Scaling">Nějaký pohled na škálování</span></h5>
                           <p>Vraťme se na chvíli zpět. Vezměme si jednoduchý problém výpočtu dvou třetin čísla 171. V zásadě existují dva způsoby, jak na to jít.</p>
                           <p>Mohli bychom vypočítat hodnotu zlomku 2/3 tak, že vydělíme 2 třemi a získáme opakující se desetinné číslo .6666666 atd. Pak bychom mohli tuto hodnotu vynásobit číslem 171. Výsledek by byl 113,9999999 atd. což není úplně správně, ale dalo by se to zaokrouhlit na 114.<br>Mohli bychom vynásobit 171 číslem 2 a získat číslo 342. V tomto případě bychom mohli vynásobit 171 číslem 2 a získat číslo 342. Pak bychom mohli tuto hodnotu vydělit třemi a získat číslo 114.<br>Poznamenejme, že druhý způsob je jednodušší a přesnější.</p>
                           <div class="wp-block-image">
                              <figure class="alignleft"><img loading="lazy" width="100" height="154" src="./05-Fixed-Point Arithmetic_files/ch5-artist-easel.gif" alt="přesnější aritmetika pomocí celočíselných počtů místo zlomků" class="wp-image-435"></figure>
                           </div>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="105" src="./05-Fixed-Point Arithmetic_files/ch5-artist-result.gif" alt="zaokrouhlování zlomků vs. používání celých čísel v přesnosti matematiky" class="wp-image-436"></figure>
                           </div>
                           <p>Většina počítačových jazyků podporuje první způsob. "V počítači nemůže viset zlomek jako dvě třetiny," má se za to, "musíte ho vyjádřit jako .6666666 atd."</p>.
                           <p>Forma podporuje druhý způsob. */ umožňuje mít zlomek jako dvě třetiny, například:</p>
                           <pre class="wp-block-preformatted">171 2 3 */

</pre>
                           <p>Když už máme trochu nadhledu, podívejme se na trochu složitější příklad:</p>
                           <p>Chceme rozdat 150 dolarů <abbr title="Pro začátečníky, kteří mají rádi slovní úlohy. Zde je slovní úloha k výše uvedenému příkladu: Šéf říká, že rozdělí prémii 150 dolarů mezi dva nejlépe prodávající zástupce podle jejich měsíčních provizí. Když se spočítají příjmy, zjistí se, že nejvyšší provize činí 7 105 a 5 145 dolarů. Kolik z bonusu dostane každý marketingový zástupce?">v poměru dvou hodnot</abbr>:</p>
                           <pre class="wp-block-preformatted"> 7 105 ?
 5,145 ?
12,250 150

</pre>
                           <p>Znovu bychom mohli problém vyřešit takto:</p>
                           <pre class="wp-block-preformatted">(7,105 / 12,250) x 150

</pre>
                           <p>a</p>
                           <pre class="wp-block-preformatted">(5,145 / 12,250) x 150

</pre>
                           <p>ale pro větší přesnost bychom měli říci:</p>
                           <pre class="wp-block-preformatted">(7,105 x 150) / 12,250

</pre>
                           <p>a</p>
                           <pre class="wp-block-preformatted">(5,145 x 150) / 12,250

</pre>
                           <p>což ve Forthu znamená:</p>
                           <pre class="wp-block-preformatted">7105 150 12250 */ .↵<span class="output">87 ok </span>

</pre>
                           <p>a</p>
                           <pre class="wp-block-preformatted">5145 150 12250 */ .↵<span class="output">63 ok </span>

</pre>
                           <p>Dá se říci, že hodnoty 87 a 63 jsou "škálovány" na 7105 a 5145. Výpočet procent, jak jsme to udělali dříve, je také formou škálování. Z tohoto důvodu se */ nazývá "operátor škálování" </p>.
                           <p>Dalším operátorem škálování ve Forthu je <code>*/MOD</code>:</p>
                           <dl class="forth">
                              <dt>*/MOD</dt>
                              <dt>( n1 n2 n3 - n4 n5 )</dt>
                              <dd>Násobí a poté dělí (n1*n2/n3). Vrátí zbytek (n4) a kvocient (n5). Používá mezivýsledek o dvojnásobné délce.</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="100" src="./05-Fixed-Point Arithmetic_files/ch5-pronounce-4.gif" alt="Dělení: získání kvocientu a zbytku pomocí */MOD" class="wp-image-437"></figure>
                           </div>
                           <p>Necháváme vás, abyste si dobrý příklad pro */MOD vymysleli sami.</p>
                           <h3><span id="Použití_Racionálních_Aproximací">Použití racionálních aproximací</span></h5>
                           <p>Dosud jsme používali pouze operace se škálováním pro práci s <abbr title="Racionální číslo je celé číslo nebo zlomek, v jehož čitateli i jmenovateli jsou celá čísla. Sedmnáct je racionální číslo, stejně jako 2/3. I 1,02 je racionální číslo, protože je stejné jako 102/100. Naproti tomu sqrt(2) je iracionální číslo.">racionální čísla</abbr>. Lze je také použít na racionální aproximace iracionálních konstant, jako je p nebo +2. Například reálná hodnota čísla π je:</p>
                           <pre class="wp-block-preformatted">3,14159265358979 atd.

</pre>
                           <p>ale abychom zůstali v mezích jednovětné aritmetiky, mohli bychom napsat větu:</p>
                           <pre class="wp-block-preformatted">31416 10000 */

</pre>
                           <p>a získat docela dobrou aproximaci.</p>
                           <p>Nyní můžeme napsat definici pro výpočet plochy kružnice dané jejím poloměrem. Vzorec přeložíme:</p>
                           <pre class="wp-block-preformatted">pr<sup>2</sup>

</pre>
                           <p>do jazyka Forth. Hodnota poloměru bude na zásobníku, takže ji DUP a vynásobíme jí samotnou, pak výsledek hvězdičkujeme:</p>
                           <pre class="wp-block-preformatted">: * 31416 10000 */ ;

</pre>
                           <p>Zkuste to s kruhem, jehož poloměr je 10 palců:</p>
                           <pre class="wp-block-preformatted">10 PI .↵<span class="output">314 ok </span>

</pre>
                           <p>Ale pro ještě větší přesnost by nás mohlo zajímat, zda kromě čísel 3146 a 10000 existuje dvojice celých čísel, která se blíží hodnotě p. Překvapivě existuje. Zlomek:</p>
                           <pre class="wp-block-preformatted">355 113 */

</pre>
                           <p>je přesný na více než šest míst za desetinnou čárkou, na rozdíl od méně než čtyř míst u čísla 31416.</p>
                           <p>Naše nová a vylepšená definice tedy zní:</p>
                           <pre class="wp-block-preformatted">: * 355 113 */ ;

</pre>
                           <p>Ukazuje se, že téměř jakoukoli konstantu lze aproximovat mnoha různými dvojicemi celých čísel, přičemž všechna čísla jsou menší než 32768, s chybou menší než 10<sup>-8</sup>.</p>
                           <p>Praktická tabulka racionálních aproximací různých konstant:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td><strong>Číslo</strong></td>
                                    <td><strong>Aproximace</strong></td>
                                    <td><strong>Chybné</strong></td>
                                 </tr>
                                 <tr>
                                    <td>π = 3,141 ...</td>
                                    <td>355 / 113</td>
                                    <td>8,5 x 10<sup>-8</sup></td>
                                 </tr>
                                 <tr>
                                    <td>π = 3,141 ...</td>
                                    <td>1068966896 / 340262731</td>
                                    <td>3,0 x 10<sup>-18</sup></td>
                                 </tr>
                                 <tr>
                                    <td>√2 = 1,414 ...</td>
                                    <td>19601 / 13860</td>
                                    <td>1,5 x 10<sup>-9</sup></td>
                                 </tr>
                                 <tr>
                                    <td>√3 = 1,732 ...</td>
                                    <td>18817 / 10864</td>
                                    <td>1,1 x 10<sup>-9</sup></td>
                                 </tr>
                                 <tr>
                                    <td>e = 2,718 ...</td>
                                    <td>28667 / 10546</td>
                                    <td>5,5 x 10<sup>-9</sup></td>
                                 </tr>
                                 <tr>
                                    <td>√10 = 3,162 ...</td>
                                    <td>22936 / 7253</td>
                                    <td>5,7 x 10<sup>-9</sup></td>
                                 </tr>
                                 <tr>
                                    <td><sup>12</sup>√2 = 1,059 ...</td>
                                    <td>26797 / 25293</td>
                                    <td>1,0 x 10<sup>-9</sup></td>
                                 </tr>
                                 <tr>
                                    <td>log(2) / 1,6384 = 0,183 ...</td>
                                    <td>2040 / 11103</td>
                                    <td>1,1 x 10<sup>-8</sup></td>
                                 </tr>
                                 <tr>
                                    <td>ln(2) / 16,384 = 0,042 ...</td>
                                    <td>485 / 11464</td>
                                    <td>1,0 x 10<sup>-7</sup></td>
                                 </tr>
                              </tbody>
                           </table>
                           <h3><span id="Chapter_Summary">Souhrn kapitoly</span></h3>
                           <h3><span id="Předchozí_slova">Předchozí slova</span></h5>
                           <p>Tady je slovníček slov Forth, která jsme probrali v této kapitole:</p>
                           <dl class="forth">
                              <dt>1+</dt>
                              <dt>( n1 - n2 )</dt>
                              <dd>Přidá jedničku.</dd>
                              <dt>1-</dt>
                              <dt>( n1 - n2 )</dt>.
                              <dd>Odčítá jedničku.</dd>
                              <dt>2+</dt>
                              <dt>( n1 - n2 )</dt>.
                              <dd>Sčítá dvě.</dd>
                              <dt>2-</dt>
                              <dt>( n1 - n2 )</dt>.
                              <dd>Odčítá dvě.</dd>
                              <dt>2*</dt>
                              <dt>( n1 - n2 )</dt>.
                              <dd>Násobí dvěma (aritmetický posun doleva).</dd>
                              <dt>2/</dt>.
                              <dt>( n1 - n2 )</dt>.
                              <dd>Dělí dvěma (aritmetický posun doprava).</dd>
                              <dt>ABS</dt>
                              <dt>( n1 - n2 )</dt>
                              <dd>Vrátí absolutní hodnotu.</dd>
                              <dt>NEGATE</dt>
                              <dt>( n1 - n2 )</dt>.
                              <dd>Změní znaménko.</dd>
                              <dt>MIN</dt>
                              <dt>( n1 n2 - n3 )</dt>.
                              <dd>Vrátí minimum.</dd>
                              <dt>MAX</dt>
                              <dt>( n1 n2 - n3 )</dt>.
                              <dd>Vrátí maximum.</dd>
                              <dt>&gt;R</dt>
                              <dt>( n - )</dt>.
                              <dd>Vezme hodnotu ze zásobníku parametrů a strčí ji na návratový zásobník.</dd>
                              <dt>R&gt;</dt>.
                              <dt>( - n )</dt>
                              <dd>Vezme hodnotu z návratového zásobníku a posune ji na zásobník parametrů.</dd>
                              <dt>R@</dt>
                              <dt>( - n )</dt>
                              <dd>Vybere horní položku z návratového zásobníku a přesune ji na zásobník parametrů.</dd>
                              <dt>*/</dt>
                              <dt>( n1 n2 n3 - n4 )</dt>
                              <dd>Násobí a pak dělí (n1*n2/n3). Používá dvojnásobně dlouhý mezivýsledek.</dd>
                              <dt>*/MOD</dt>
                              <dt>( n1 n2 n3 - n4 n5 )</dt>
                              <dd>Násobí a poté dělí (n1*n2/n3). Vrátí zbytek (n4) a kvocient (n5). Používá mezivýsledek o dvojnásobné délce.</dd>
                           </dl>
                           <h3><span id="Review_of_Terms">Přehled pojmů</span></h5>
                           <dl>
                              <dt>Dvojnásobně dlouhý mezivýsledek</dt>
                              <dd>hodnota dvojnásobné délky, která je dočasně vytvořena dvojčlenným operátorem, například */, takže "mezivýsledek" (výsledek první operace) může přesáhnout rozsah čísla o jedné délce, i když počáteční argumenty a konečný výsledek nejsou.</dd>
                              <dt>Aritmetika s pevným počtem bodů</dt>
                              <dd>aritmetika, která pracuje s čísly, jež sama o sobě neuvádějí umístění desetinných míst. Místo toho program pro libovolnou skupinu čísel předpokládá umístění desetinné čárky nebo pro všechna taková čísla uchovává umístění desetinné čárky jako samostatné číslo.</dd>
                              <dt>Aritmetika s pohyblivou řádovou čárkou</dt>
                              <dd>aritmetika, která pracuje s čísly, jež sama udávají umístění své desetinné čárky. Program musí být schopen interpretovat skutečnou hodnotu každého jednotlivého čísla předtím, než může být provedena jakákoli aritmetika.</dd>
                              <dt>Zásobník parametrů</dt>
                              <dd>ve Forthu oblast paměti, která slouží jako společný prostor mezi různými operacemi k předávání argumentů (čísel, příznaků nebo čehokoli jiného) z jedné operace do druhé.</dd>
                              <dt>Zásobník návratů</dt>
                              <dd>ve Forthu oblast paměti odlišná od zásobníku parametrů, kterou systém Forth používá mimo jiné k uchovávání "návratových adres" (bude probráno v <a href="https://www.forth.com/starting-forth/9-forth-execution/">Kap. 9</a>). Uživatel může za určitých podmínek dočasně uchovávat hodnoty na návratovém zásobníku </dd>.
                              <dt>Škálování</dt>
                              <dd>Proces násobení (nebo dělení) čísla poměrem. Označuje také proces násobení (nebo dělení) čísla mocninou deseti tak, aby všechny hodnoty v souboru dat mohly být reprezentovány jako celá čísla s předpokládanou desetinnou čárkou na stejném místě pro všechny hodnoty.</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="aligncenter"><img loading="lazy" width="230" height="100" src="./05-Fixed-Point Arithmetic_files/felix.gif" alt="Programovací jazyk Forth - příklady" class="wp-image-353"></figure>
                           </div>
                           <h3><span id="Problémy_kapitola_5">Problémy - kapitola 5</span></h5>
                           <ol class="sf-numbered">
                              <li>
                                 Přeložte následující algebraický výraz do definice jazyka Forth:
                                 <pre>-ab/c</pre> Převeďte Forthův vzorec do následujícího formátu: <pre>-ab/c</pre>.
                                 <p>dáno ( a b c - )</p>
                              </li>
                              <li>
                                 Vzhledem k těmto čtyřem číslům na zásobníku:
                                 <pre>( 6 70 123 45 -- )</pre>.
                                 <p>napište výraz, který vypíše největší hodnotu.&nbsp;</p>
                              </li>
                              <li>
                                 Ve "stylu kalkulačky" převeďte následující teploty pomocí těchto vzorců:
                                 <pre>°C = (°F - 32) / 1,8°F = (°C x 1,8) + 32°K = °C + 273</pre>.
                                 <p>(Prozatím vyjadřujte všechny argumenty a výsledky v celých stupních.)<br>0° F ve stupních Celsia<br>212° F ve stupních Celsia<br>-32° F v&nbsp;<span style="font-size: inherit;">Celsius</span><br>16° C ve stupních Fahrenheita<br>233° K ve stupních Celsia</p>
                              </li>
                              <li>
                                 Nyní definujte slova pro provádění převodů v úloze Prob. 3. Použijte následující názvy:
                                 <pre>F&gt;C F&gt;K C&gt;F C&gt;K K&gt;F K&gt;C</pre>.
                                 <p>Vyzkoušejte je s výše uvedenými hodnotami.</p>
                              </li>
                           </ol>
                           <div class="wp-block-genesis-blocks-gb-accordion gb-block-accordion gb-font-size-18">
                              <details>
                                 <summary class="gb-accordion-title">Odpovědi<br></summary>
                                 <div class="gb-accordion-text">
                                    <ol>
                                       <li>
                                          <pre>: -AB/C ( a b c -- -ab/c ) */ NEGATE ;
</pre>
                                       </li>
                                       <li>
                                          <pre>: LARGEST ( a b c d -- největší ) MAX MAX MAX . ;
</pre>
                                       </li>
                                       <li>
                                          <pre> 0 32 - 10 18 */ .
212 32 - 10 18 */ .
-32 32 - 10 18 */ .
 16 18 10 */ 32 + .
233 273 - .
</pre>
                                       </li>
                                       <li>
                                          <pre>: F&gt;C ( fahr -- cels ) 32 - 10 18 */ ;
: C&gt;F ( cels -- fahr ) 18 10 */ 32 + ;
: C&gt;K ( cels -- kelv ) 273 + ;
: K&gt;C ( kelv -- cels ) 273 - ;
: F&gt;K ( fahr -- kelv ) F&gt;C C&gt;K ;
: K&gt;F ( kelv -- fahr ) K&gt;C C&gt;F ;
</pre>
                                       </li>
                                    </ol>
                                 </div>
                              </details>
                           </div>
                        </div>
                     </div>
                  </article>
               </main>
            </div>
         </div>
      </div>
      <div class="site grid-container container hfeed grid-parent" id="page">
         <div class="site-content" id="content">
            <div class="content-area grid-parent mobile-grid-100 grid-70 tablet-grid-70" id="primary">
               <main class="site-main" id="main">
                  <article id="post-322" class="post-322 page type-page status-publish" itemtype="https://schema.org/CreativeWork" itemscope="">
                     <div class="inside-article">
                        <header class="entry-header" aria-label="Content">
                           <h2 class="entry-title" itemprop="headline">5. Filozofie pevného bodu</h2>
                        </header>
                        <div class="entry-content" itemprop="text">
                           <p>V této kapitole si představíme novou várku aritmetických operátorů. Cestou se budeme zabývat problémem práce s desetinnou čárkou pouze pomocí celočíselné aritmetiky.</p>
                           <h3><span id="Quickie_Operators">Rychlé operátory</span></h3>
                           <p>Začneme tím opravdu jednoduchým. Neměli byste mít problém zjistit, co slova v následující tabulce dělají.</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>1+</td>
                                    <td>( n1 - n2 )</td>
                                    <td>Přidá jedničku</td>
                                 </tr>
                                 <tr>
                                    <td>1-</td>
                                    <td>( n1 - n2 )</td>
                                    <td>Odčítá jedničku</td>
                                 </tr>
                                 <tr>
                                    <td>2+</td>
                                    <td>( n1 - n2 )</td>
                                    <td>Přičte dvě</td>
                                 </tr>
                                 <tr>
                                    <td>2-</td>
                                    <td>( n1 - n2 )</td>
                                    <td>Odčítá dvě</td>
                                 </tr>
                                 <tr>
                                    <td>2*</td>
                                    <td>( n1 - n2 )</td>
                                    <td>Sčítá dvěma<br>(Aritmetika <abbr title="Pro začátečníky: Později si vysvětlíme, co je &#39;aritmetický posun vlevo&#39;">posun vlevo</abbr>)</td>.
                                 </tr>
                                 <tr>
                                    <td>2/</td>
                                    <td>( n1 - n2 )</td>
                                    <td>Dělí dvěma<br>(aritmetický posun doprava)</td>
                                 </tr>
                              </tbody>
                           </table>
                           <div class="wp-block-image">
                              <figure class="alignright"><img width="100" height="197" src="./05-Fixed-Point Arithmetic_files/ch5-pronounce-1.gif" alt="běžné matematické operátory Forthu" class="wp-image-428"></figure>
                           </div>
                           <p>Jediným důvodem, proč používat slova jako 1+ místo 1 a +, je tradice. V moderních systémech Forth s optimalizátory kódu nešetří 1+ ani místo, ani čas kompilace nebo provádění </p>.
                           <h3><span id="Miscellaneous_Math_Operators">Různé matematické operátory</span></h3>
                           <p>Tady je tabulka čtyř různých matematických operátorů. Stejně jako u rychlých operátorů by tyto funkce měly být zřejmé z jejich názvů.</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>ABS</td>
                                    <td>( n1 - n2 )</td>
                                    <td>Vrací absolutní hodnotu</td>
                                 </tr>
                                 <tr>
                                    <td>NEGATE</td>
                                    <td>( n1 - n2 )</td>
                                    <td>Změní znaménko</td>
                                 </tr>
                                 <tr>
                                    <td>MIN</td>
                                    <td>( n1 n2 - min )</td>
                                    <td>Vrátí minimum</td>
                                 </tr>
                                 <tr>
                                    <td>MAX</td>
                                    <td>( n1 n2 - max)</td>
                                    <td>Vrátí maximum</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Tady jsou dvě jednoduché slovní úlohy s použitím ABS a MIN:</p>
                           <pre class="wp-block-preformatted">ABS

</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="160" height="150" src="./05-Fixed-Point Arithmetic_files/ch5-min-max.gif" alt="porovnání kladných a záporných čísel pomocí funkcí Forth&#39;MAX a MIN" class="wp-image-429"></figure>
                           </div>
                           <p>Napište definici, která vypočítá rozdíl dvou čísel bez ohledu na pořadí, v jakém jsou čísla zadána.</p>
                           <pre class="wp-block-preformatted">: ROZDÍL - ABS ;

</pre>
                           <p>Toto dává stejný výsledek, ať už zadáme</p>
                           <pre class="wp-block-preformatted">52 37 DIFFERENCE .↵<span class="output">&gt;15 ok </span>
37 52 DIFFERENCE .↵<span class="output">15 ok </span>
MIN

</pre>
                           <p>Napište definici, která vypočítá provizi, kterou prodejci nábytku obdrží, pokud jim bylo slíbeno 50 dolarů nebo 1/10 prodejní ceny, podle toho, co je menší, za každý uskutečněný prodej.</p>
                           <pre class="wp-block-preformatted">: PROVIZE 10 / 50 MIN ;

</pre>
                           <p>Tři různé hodnoty by vedly k těmto výsledkům:</p>
                           <pre class="wp-block-preformatted">600 KOMISE .↵√50 ok
450 KOMISE .↵√45 ok
 50 KOMISE .↵√5 ok

</pre>
                           <h3><span id="The_Return_Stack">Zásobník návratů</span></h3>
                           <p>Předtím jsme se zmínili, že ještě existují některé operátory pro manipulaci se zásobníkem, které jsme dosud neprobrali. Nyní je čas.</p>
                           <p>Dosud jsme mluvili o "zásobníku", jako by byl jen jeden. Ve skutečnosti však <abbr title="Většina Forthů má navíc zásobník s plovoucí desetinnou čárkou.">existují dva</abbr>: "zásobník parametrů" a "návratový zásobník". Zásobník parametrů používají programátoři Forthu častěji, takže pokud není důvod k pochybnostem, říká se mu jednoduše "zásobník".</p>
                           <p>Jak jste viděli, zásobník parametrů uchovává parametry (neboli "argumenty"), které se předávají ze slova do slova. Návratový zásobník však uchovává libovolný počet "ukazatelů", které systém Forth používá k tomu, aby se vesele prodíral bludištěm slov, která vykonávají jiná slova. Podrobněji si to vysvětlíme později.</p>
                           <p>Vy, uživatel, můžete návratový zásobník použít jako jakousi "ruku navíc", která dočasně uchovává hodnoty, zatímco provádíte operace na zásobníku parametrů.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="150" src="./05-Fixed-Point Arithmetic_files/ch5-return-stack.gif" alt="Návratový zásobník LIFO jazyka Forth&#39;neboli zásobník parametrů uchovává ukazatele na provedení" class="wp-image-430"></figure>
                           <p>Vratný zásobník je stejně jako zásobník parametrů strukturou typu "last-in first-out", takže může obsahovat mnoho hodnot. Má to však háček: cokoli vložíte do návratového zásobníku, musíte opět odstranit, než se dostanete na konec definice (středník), protože v tomto okamžiku bude systém Forth očekávat, že tam najde ukazatel. Návratový zásobník nemůžete použít k předávání parametrů z jednoho slova do druhého.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="150" src="./05-Fixed-Point Arithmetic_files/ch5-return-stack-2.gif" alt="Programátoři, kteří používají návratový zásobník, jej musí před ukončením vykonávání své funkce ponechat tak, jak byl." class="wp-image-431"></figure>
                           <p>Následující slovníček uvádí slova spojená s návratovým zásobníkem. Nezapomeňte, že zápis zásobníku se vztahuje k zásobníku <em>parametrů</em>.</p>
                           <dl class="forth">
                              <dt>&gt;R</dt>
                              <dt>( n - )</dt>
                              <dd>Vezme hodnotu ze zásobníku parametrů a přesune ji na návratový zásobník.</dd>
                              <dt>R&gt;</dt>.
                              <dt>( - n )</dt>
                              <dd>Vezme hodnotu z návratového zásobníku a posune ji na zásobník parametrů.</dd>
                              <dt>R@</dt>
                              <dt>( - n )</dt>
                              <dd>Vybere horní položku z návratového zásobníku a přesune ji na zásobník parametrů.</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="216" src="./05-Fixed-Point Arithmetic_files/ch5-pronounce-2.gif" alt="" class="wp-image-432"></figure>
                           </div>
                           <p>Slova &gt;R a R&gt; přenášejí hodnotu na návratový zásobník, resp. z návratového zásobníku. Řekněme, že chceme následující efekt zásobníku:</p>
                           <pre class="wp-block-preformatted">( 2 3 1 -- 3 2 1 )

</pre>
                           <p>tohle je věta, která to udělá:</p>
                           <pre class="wp-block-preformatted">&gt;R SWAP R&gt;

</pre>
                           <p>Každé &gt;R a jemu odpovídající R&gt; musí být použity společně v jedné definici.</p>
                           <p>Zbývající slovo R@ pouze <em>kopíruje</em> hodnoty z návratového zásobníku, aniž by je odstranilo. Tedy věta:</p>
                           <pre class="wp-block-preformatted">&gt;R SWAP R@

</pre>
                           <p>by sice přinesla stejný výsledek, pokud jde o to, co se děje, ale pokud před dalším středníkem neuklidíte koš, dojde k pádu systému.</p>
                           <p>Abyste viděli, jak lze použít &gt;R, R&gt;, R@ a I, představte si, že máte takovou smůlu a potřebujete vyřešit rovnici:</p>
                           <pre class="wp-block-preformatted">ax<sup>2</sup> + bx + c

</pre>
                           <p>se <em>všemi čtyřmi</em> hodnotami na zásobníku v následujícím pořadí:</p>
                           <pre class="wp-block-preformatted">( a b c x -- )

</pre>
                           <p>(nezapomeňte nejprve vynásobit).</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td><strong>Operátor</strong></td>
                                    <td><strong>Zásobník parametrů</strong></td>
                                    <td><strong>Zásobník návratových parametrů</strong></td>
                                 </tr>
                                 <tr>
                                    <td></td>
                                    <td>a b c x</td>
                                    <td></td>
                                 </tr>
                                 <tr>
                                    <td>&gt;R</td>
                                    <td>a b c</td>
                                    <td>x</td>
                                 </tr>
                                 <tr>
                                    <td>SWAP ROT</td>
                                    <td>c b a</td>
                                    <td>x</td>
                                 </tr>
                                 <tr>
                                    <td>R@</td>
                                    <td>c b a x</td>
                                    <td>x</td>
                                 </tr>
                                 <tr>
                                    <td>*</td>
                                    <td>c b ax</td>
                                    <td>x</td>
                                 </tr>
                                 <tr>
                                    <td>+</td>
                                    <td>c ax+b</td>
                                    <td>x</td>
                                 </tr>
                                 <tr>
                                    <td>R&gt; *</td>
                                    <td>c x(ax+b)</td>
                                    <td></td>
                                 </tr>
                                 <tr>
                                    <td>+</td>
                                    <td>x(ax+b)+c</td>
                                    <td></td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Pokračujte a vyzkoušejte si to. Načtěte následující definici:</p>
                           <pre class="wp-block-preformatted">: QUADRATIC ( a b c x -- n ) &gt;R SWAP ROT R@ * + R&gt; * + ;</pre>
                           <p>Teď to vyzkoušejte:</p>
                           <pre class="wp-block-preformatted">2 7 9 3 QUADRATIC .↵<span class="output">48 ok </span></pre>
                           <h3><span id="An_Introduction_to_Floating-Point_Arithmetic">Úvod do aritmetiky s plovoucí desetinnou čárkou</span></h3>
                           <p>Nejprve si řekněme, co znamená pojem plovoucí desetinná čárka? Vezměme si například kapesní kalkulačku. Takto vypadá displej po každém kroku:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td><strong>Zadáváte:</strong></td>
                                    <td><strong>Zobrazí se:</strong></td>
                                 </tr>
                                 <tr>
                                    <td>1 . 5 0 x</td>
                                    <td>1,5</td>
                                 </tr>
                                 <tr>
                                    <td>2 . 2 3</td>
                                    <td>2,23</td>
                                 </tr>
                                 <tr>
                                    <td>=</td>
                                    <td>3,345</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Desetinná tečka "plave" po displeji podle potřeby. Tomu se říká "zobrazení s pohyblivou desetinnou čárkou" </p>.
                           <p>"Zobrazení s pohyblivou desetinnou čárkou" je způsob ukládání čísel do paměti počítače pomocí určité formy vědeckého zápisu. Ve vědecké notaci se dvanáct milionů zapisuje takto:</p>
                           <p>12 x 10<sup>6</sup></p>
                           <p>protože deset na šestou mocninu se rovná jednomu milionu. V počítači by dvanáct milionů mohlo být uloženo jako dvě čísla: 12 a 6, kde se rozumí, že 6 je mocnina deseti, kterou se násobí 12, zatímco 3,345 by mohlo být uloženo jako 3345 a -3.</p>
                           <p>Smysl reprezentace s pohyblivou řádovou čárkou spočívá v tom, že počítač může reprezentovat obrovský rozsah čísel, od atomárních až po astronomická, pomocí dvou relativně malých čísel.</p>
                           <p>Co je reprezentace s pevnou řádovou čárkou? Je to jednoduše metoda ukládání čísel do paměti bez ukládání pozic desetinné čárky každého čísla. Například při práci s dolary a centy lze všechny hodnoty uložit v centech. Místo každého jednotlivého <em>čísla</em> si může polohu desetinné čárky pamatovat <em>program</em>.</p>
                           <p>Příklad porovnejme reprezentaci hodnot v dolarech a centech s pevnou a pohyblivou desetinnou čárkou.</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td><strong>Reálná hodnota:</strong></td>
                                    <td><strong>Pravá hodnota:</strong></td>
                                    <td><strong>Plochá hodnota :</strong></td>
                                 </tr>
                                 <tr>
                                    <td>1,23</td>
                                    <td>123</td>
                                    <td>123(-2)</td>
                                 </tr>
                                 <tr>
                                    <td>10,98</td>
                                    <td>1098</td>
                                    <td>1098(-2)</td>
                                 </tr>
                                 <tr>
                                    <td>100.00</td>
                                    <td>10000</td>
                                    <td>1(2)</td>
                                 </tr>
                                 <tr>
                                    <td>58,60</td>
                                    <td>5860</td>
                                    <td>586(-1)</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Jak vidíte , u pevného bodu musí všechny hodnoty odpovídat stejnému "měřítku". Desetinné tečky musí být správně "zarovnány" (v tomto případě o dvě místa dovnitř zprava), i když ve skutečnosti nejsou zastoupeny. Při použití pevné řádové čárky počítač zachází se všemi čísly, jako by to byla celá čísla. Pokud však program potřebuje odpověď vytisknout, jednoduše vloží desetinnou čárku o dvě místa zprava, než číslo odešle na terminál nebo na tiskárnu.</p>
                           <h3><span id="Why_Fixed-Point_is_Useful">Proč je pevná čárka užitečná</span></h3>
                           <p>Programátora jazyka Forth nejvíce zajímá maximální efektivita stroje. To znamená, že chce, aby program běžel co nejrychleji a vyžadoval co nejméně paměti počítače. Bohužel ne všechny procesory nebo řadiče nabízejí hardwarovou podporu plovoucí desetinné čárky. Proto jsou v některých prostředích programy využívající funkce s plovoucí desetinnou čárkou přesměrovány přes emulační knihovnu. Emulační kód může být až třikrát pomalejší než ekvivalentní výpočet s pevnou řádovou čárkou. Tento rozdíl je samozřejmě skutečně patrný pouze u programů, které musí provést mnoho výpočtů před odesláním výsledků do terminálu nebo provedením nějaké akce. Háček je v tom, že kód z emulační knihovny je také mnohonásobně větší než jeho protějšek s pevnou řádovou čárkou, což je pro malé vestavné řadiče a podobně dost neekonomické.</p>
                           <p>Měli byste si pečlivě uvědomit, že <em>pokud</em> procesor podporuje hardwarovou plovoucí desetinnou čárku, je téměř vždy mnohem rychlejší a kompaktnější než ekvivalent s pevnou desetinnou čárkou. Rozdíl v rychlosti může být 3 až 15násobný.</p>
                           <p>Všechno, co můžete dělat s plovoucí desetinnou čárkou, můžete dělat i s pevnou desetinnou čárkou, jak si ukážeme v následujícím textu. Jednu věc byste však měli co nejvíce minimalizovat, a to je přepínání mezi formáty s pevnou a plovoucí desetinnou čárkou. Převod formátu a další kroky škálování stojí stejně nebo dokonce více času než samotné provádění výpočtů.</p>
                           <p>Forma pomáhá programátorům používat pevnou desetinnou čárku tím, že jim poskytuje jedinečnou sadu vysokoúrovňových příkazů zvaných "operátory škálování". První z těchto příkazů si představíme v následující části. (Závěrečný příklad v <a href="https://www.forth.com/starting-forth/12-forth-code-examples/">kapitole 12</a> ilustruje použití škálovacích technik.)</p>
                           <h3><span id="Hvězdicový_skalár">Hvězdicový_skalár</span></h3>
                           <p>Tady je matematický operátor, který je stejně užitečný jako neobvyklý: <code>*/</code>.</p>
                           <dl class="forth">
                              <dt>*/</dt>
                              <dt>( n1 n2 n3 - n4 )</dt>
                              <dd>Násobí, pak dělí (n1*n2/n3). Používá dvojnásobně dlouhý mezivýsledek.</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="140" height="253" src="./05-Fixed-Point Arithmetic_files/ch5-pronounce-3.gif" alt="*/ škáluje hodnoty, například při výpočtu procent." class="wp-image-433"></figure>
                           </div>
                           <p>Jak již název napovídá, */ provádí násobení a poté dělení. Řekněme, že zásobník obsahuje například tato tři čísla:</p>
                           <pre class="wp-block-preformatted">( 225 32 100 -- )

</pre>
                           <p>*/ nejprve vynásobí 225 číslem 32 a poté výsledek vydělí číslem 100.</p>
                           <p>Tento operátor je užitečný zejména jako celočíselné aritmetické řešení problémů, jako jsou výpočty procent.</p>
                           <p>Příklad můžete definovat slovo % takto:</p>
                           <pre class="wp-block-preformatted">: % 100 */ ;

</pre>
                           <p>tak, že zadáním čísla 225 a následně výrazu:</p>
                           <pre class="wp-block-preformatted">32 %

</pre>
                           <p>Způsob, kdy nejprve vynásobíme dvě celá čísla a poté je vydělíme 100, je totožný s postupem, který většina lidí používá při řešení takovýchto úloh na papíře:</p>
                           <pre class="wp-block-preformatted"> 225
 0.32 x
 4.50
67.5
72.00
</pre>
                           <p>*/ není * a / hozené dohromady. Používá "dvojnásobně dlouhý mezivýsledek". Ptáte se, co to znamená?</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="187" src="./05-Fixed-Point Arithmetic_files/ch5-star-slash.gif" alt="*/ používá dvojnásobně dlouhý mezivýsledek, aby se zachovala správná hodnota" class="wp-image-434"></figure>
                           <p>Řekněme, že chcete vypočítat 34 % z 912 345 678. Nezapomeňte, že operátory s jednou přesností, jako jsou * a /, pracují pouze s argumenty a výsledky v rozsahu čísla jedné délky. Pokud byste zadali větu:</p>
                           <pre class="wp-block-preformatted">912345678 34 * 100 /

</pre>
                           <p>získali byste nesprávný výsledek, protože "mezivýsledek" (v tomto případě výsledek násobení), přesahuje 2147483647, jak ukazuje levý sloupec této obrázkové simulace.</p>
                           <p>Ale */ používá dvojnásobně dlouhý mezivýsledek, takže jeho rozsah bude dostatečně velký na to, aby pojal výsledek násobení jakýchkoli dvou jednočísel. Výraz:</p>
                           <pre class="wp-block-preformatted">912345678 34 100 */

</pre>
                           <p>vrátí správnou odpověď, protože konečný výsledek spadá do rozsahu jednočíselných čísel.</p>
                           <p>Předchozí příklad vyvolává další otázku: jak zaokrouhlovat </p>.
                           <p>Předpokládejme, že se jedná o tento problém:</p>
                           <blockquote class="wp-block-quote">
                              <p>Pokud si 32 % studentů stravujících se ve školní jídelně obvykle kupuje banány, kolik banánů by mělo být po ruce pro 225 lidí? Samozřejmě nás zajímají pouze celé banány, takže případný desetinný zbytek bychom rádi zaokrouhlili.</p>
                           </blockquote>
                           <p>Podle naší definice nyní jakoukoli hodnotu napravo od desetinného čísla jednoduše vynecháme. Jinými slovy, výsledek je "zkrácený".</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>32 % z:</td>
                                    <td>Výsledek:</td>
                                 </tr>
                                 <tr>
                                    <td>225 = 72,00</td>
                                    <td>72 - přesně správně</td>
                                 </tr>
                                 <tr>
                                    <td>226 = 72.32</td>
                                    <td>72 - správně, zaokrouhleno dolů (zkráceno)</td>
                                 </tr>
                                 <tr>
                                    <td>227 = 72,64</td>
                                    <td>72 - zkráceno, nezaokrouhleno</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Existuje však způsob, jak při jakékoli desetinné hodnotě 0,5 nebo vyšší zaokrouhlit nahoru na další celý banán. Mohli bychom definovat slovo R%, pro "zaokrouhlené procento", takto:</p>
                           <pre class="wp-block-preformatted">: R% 10 */ 5 + 10 / ;

</pre>
                           <p>tak, aby výraz:</p>
                           <pre class="wp-block-preformatted">227 32 R% .

</pre>
                           <p>dá 73, což je správně zaokrouhleno nahoru.</p>
                           <p>Všimněte si, že nejprve dělíme deseti, nikoliv sto. Tím získáme další desetinné místo, se kterým můžeme pracovat a ke kterému můžeme přičíst pět:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>Operace</td>
                                    <td>Obsah zásobníku</td>
                                 </tr>
                                 <tr>
                                    <td></td>
                                    <td>227 32 10</td>
                                 </tr>
                                 <tr>
                                    <td>*/</td>
                                    <td>726</td>
                                 </tr>
                                 <tr>
                                    <td>5 +</td>
                                    <td>731</td>
                                 </tr>
                                 <tr>
                                    <td>10 /</td>
                                    <td>73</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Závěrečné dělení deseti nastaví hodnotu na správnou desetinnou pozici.</p>
                           <p>Nevýhodou tohoto způsobu zaokrouhlování je, že v konečném výsledku ztrácíte jedno desetinné místo rozsahu; to znamená, že může být pouze 214 748 364 místo 2 147 483 647. Pokud vám to však vadí, můžete vždy použít čísla s dvojnásobnou délkou, která si představíme později, a stále budete moci zaokrouhlovat.</p>
                           <h3><span id="Some_Perspective_on_Scaling">Nějaký pohled na škálování</span></h5>
                           <p>Vraťme se na chvíli zpět. Vezměme si jednoduchý problém výpočtu dvou třetin čísla 171. V zásadě existují dva způsoby, jak na to jít.</p>
                           <p>Mohli bychom vypočítat hodnotu zlomku 2/3 tak, že vydělíme 2 třemi a získáme opakující se desetinné číslo .6666666 atd. Pak bychom mohli tuto hodnotu vynásobit číslem 171. Výsledek by byl 113,9999999 atd. což není úplně správně, ale dalo by se to zaokrouhlit na 114.<br>Mohli bychom vynásobit 171 číslem 2 a získat číslo 342. V tomto případě bychom mohli vynásobit 171 číslem 2 a získat číslo 342. Pak bychom mohli tuto hodnotu vydělit třemi a získat číslo 114.<br>Poznamenejme, že druhý způsob je jednodušší a přesnější.</p>
                           <div class="wp-block-image">
                              <figure class="alignleft"><img loading="lazy" width="100" height="154" src="./05-Fixed-Point Arithmetic_files/ch5-artist-easel.gif" alt="přesnější aritmetika pomocí celočíselných počtů místo zlomků" class="wp-image-435"></figure>
                           </div>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="105" src="./05-Fixed-Point Arithmetic_files/ch5-artist-result.gif" alt="zaokrouhlování zlomků vs. používání celých čísel v přesnosti matematiky" class="wp-image-436"></figure>
                           </div>
                           <p>Většina počítačových jazyků podporuje první způsob. "V počítači nemůže viset zlomek jako dvě třetiny," má se za to, "musíte ho vyjádřit jako .6666666 atd."</p>.
                           <p>Forma podporuje druhý způsob. */ umožňuje mít zlomek jako dvě třetiny, například:</p>
                           <pre class="wp-block-preformatted">171 2 3 */

</pre>
                           <p>Když už máme trochu nadhledu, podívejme se na trochu složitější příklad:</p>
                           <p>Chceme rozdat 150 dolarů <abbr title="Pro začátečníky, kteří mají rádi slovní úlohy. Zde je slovní úloha k výše uvedenému příkladu: Šéf říká, že rozdělí prémii 150 dolarů mezi dva nejlépe prodávající zástupce podle jejich měsíčních provizí. Když se spočítají příjmy, zjistí se, že nejvyšší provize činí 7 105 a 5 145 dolarů. Kolik z bonusu dostane každý marketingový zástupce?">v poměru dvou hodnot</abbr>:</p>
                           <pre class="wp-block-preformatted"> 7 105 ?
 5,145 ?
12,250 150

</pre>
                           <p>Znovu bychom mohli problém vyřešit takto:</p>
                           <pre class="wp-block-preformatted">(7,105 / 12,250) x 150

</pre>
                           <p>a</p>
                           <pre class="wp-block-preformatted">(5,145 / 12,250) x 150

</pre>
                           <p>ale pro větší přesnost bychom měli říci:</p>
                           <pre class="wp-block-preformatted">(7,105 x 150) / 12,250

</pre>
                           <p>a</p>
                           <pre class="wp-block-preformatted">(5,145 x 150) / 12,250

</pre>
                           <p>což ve Forthu znamená:</p>
                           <pre class="wp-block-preformatted">7105 150 12250 */ .↵<span class="output">87 ok </span>

</pre>
                           <p>a</p>
                           <pre class="wp-block-preformatted">5145 150 12250 */ .↵<span class="output">63 ok </span>

</pre>
                           <p>Dá se říci, že hodnoty 87 a 63 jsou "škálovány" na 7105 a 5145. Výpočet procent, jak jsme to udělali dříve, je také formou škálování. Z tohoto důvodu se */ nazývá "operátor škálování" </p>.
                           <p>Dalším operátorem škálování ve Forthu je <code>*/MOD</code>:</p>
                           <dl class="forth">
                              <dt>*/MOD</dt>
                              <dt>( n1 n2 n3 - n4 n5 )</dt>
                              <dd>Násobí a poté dělí (n1*n2/n3). Vrátí zbytek (n4) a kvocient (n5). Používá mezivýsledek o dvojnásobné délce.</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="100" src="./05-Fixed-Point Arithmetic_files/ch5-pronounce-4.gif" alt="Dělení: získání kvocientu a zbytku pomocí */MOD" class="wp-image-437"></figure>
                           </div>
                           <p>Necháváme vás, abyste si dobrý příklad pro */MOD vymysleli sami.</p>
                           <h3><span id="Použití_Racionálních_Aproximací">Použití racionálních aproximací</span></h5>
                           <p>Dosud jsme používali pouze operace se škálováním pro práci s <abbr title="Racionální číslo je celé číslo nebo zlomek, v jehož čitateli i jmenovateli jsou celá čísla. Sedmnáct je racionální číslo, stejně jako 2/3. I 1,02 je racionální číslo, protože je stejné jako 102/100. Naproti tomu sqrt(2) je iracionální číslo.">racionální čísla</abbr>. Lze je také použít na racionální aproximace iracionálních konstant, jako je p nebo +2. Například reálná hodnota čísla π je:</p>
                           <pre class="wp-block-preformatted">3,14159265358979 atd.

</pre>
                           <p>ale abychom zůstali v mezích jednovětné aritmetiky, mohli bychom napsat větu:</p>
                           <pre class="wp-block-preformatted">31416 10000 */

</pre>
                           <p>a získat docela dobrou aproximaci.</p>
                           <p>Nyní můžeme napsat definici pro výpočet plochy kružnice dané jejím poloměrem. Vzorec přeložíme:</p>
                           <pre class="wp-block-preformatted">pr<sup>2</sup>

</pre>
                           <p>do jazyka Forth. Hodnota poloměru bude na zásobníku, takže ji DUP a vynásobíme jí samotnou, pak výsledek hvězdičkujeme:</p>
                           <pre class="wp-block-preformatted">: * 31416 10000 */ ;

</pre>
                           <p>Zkuste to s kruhem, jehož poloměr je 10 palců:</p>
                           <pre class="wp-block-preformatted">10 PI .↵<span class="output">314 ok </span>

</pre>
                           <p>Ale pro ještě větší přesnost by nás mohlo zajímat, zda kromě čísel 3146 a 10000 existuje dvojice celých čísel, která se blíží hodnotě p. Překvapivě existuje. Zlomek:</p>
                           <pre class="wp-block-preformatted">355 113 */

</pre>
                           <p>je přesný na více než šest míst za desetinnou čárkou, na rozdíl od méně než čtyř míst u čísla 31416.</p>
                           <p>Naše nová a vylepšená definice tedy zní:</p>
                           <pre class="wp-block-preformatted">: * 355 113 */ ;

</pre>
                           <p>Ukazuje se, že téměř jakoukoli konstantu lze aproximovat mnoha různými dvojicemi celých čísel, přičemž všechna čísla jsou menší než 32768, s chybou menší než 10<sup>-8</sup>.</p>
                           <p>Praktická tabulka racionálních aproximací různých konstant:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td><strong>Číslo</strong></td>
                                    <td><strong>Aproximace</strong></td>
                                    <td><strong>Chybné</strong></td>
                                 </tr>
                                 <tr>
                                    <td>π = 3,141 ...</td>
                                    <td>355 / 113</td>
                                    <td>8,5 x 10<sup>-8</sup></td>
                                 </tr>
                                 <tr>
                                    <td>π = 3,141 ...</td>
                                    <td>1068966896 / 340262731</td>
                                    <td>3,0 x 10<sup>-18</sup></td>
                                 </tr>
                                 <tr>
                                    <td>√2 = 1,414 ...</td>
                                    <td>19601 / 13860</td>
                                    <td>1,5 x 10<sup>-9</sup></td>
                                 </tr>
                                 <tr>
                                    <td>√3 = 1,732 ...</td>
                                    <td>18817 / 10864</td>
                                    <td>1,1 x 10<sup>-9</sup></td>
                                 </tr>
                                 <tr>
                                    <td>e = 2,718 ...</td>
                                    <td>28667 / 10546</td>
                                    <td>5,5 x 10<sup>-9</sup></td>
                                 </tr>
                                 <tr>
                                    <td>√10 = 3,162 ...</td>
                                    <td>22936 / 7253</td>
                                    <td>5,7 x 10<sup>-9</sup></td>
                                 </tr>
                                 <tr>
                                    <td><sup>12</sup>√2 = 1,059 ...</td>
                                    <td>26797 / 25293</td>
                                    <td>1,0 x 10<sup>-9</sup></td>
                                 </tr>
                                 <tr>
                                    <td>log(2) / 1,6384 = 0,183 ...</td>
                                    <td>2040 / 11103</td>
                                    <td>1,1 x 10<sup>-8</sup></td>
                                 </tr>
                                 <tr>
                                    <td>ln(2) / 16,384 = 0,042 ...</td>
                                    <td>485 / 11464</td>
                                    <td>1,0 x 10<sup>-7</sup></td>
                                 </tr>
                              </tbody>
                           </table>
                           <h3><span id="Chapter_Summary">Souhrn kapitoly</span></h3>
                           <h3><span id="Předchozí_slova">Předchozí slova</span></h5>
                           <p>Tady je slovníček slov Forth, která jsme probrali v této kapitole:</p>
                           <dl class="forth">
                              <dt>1+</dt>
                              <dt>( n1 - n2 )</dt>
                              <dd>Přidá jedničku.</dd>
                              <dt>1-</dt>
                              <dt>( n1 - n2 )</dt>.
                              <dd>Odčítá jedničku.</dd>
                              <dt>2+</dt>
                              <dt>( n1 - n2 )</dt>.
                              <dd>Sčítá dvě.</dd>
                              <dt>2-</dt>
                              <dt>( n1 - n2 )</dt>.
                              <dd>Odčítá dvě.</dd>
                              <dt>2*</dt>
                              <dt>( n1 - n2 )</dt>.
                              <dd>Násobí dvěma (aritmetický posun doleva).</dd>
                              <dt>2/</dt>.
                              <dt>( n1 - n2 )</dt>.
                              <dd>Dělí dvěma (aritmetický posun doprava).</dd>
                              <dt>ABS</dt>
                              <dt>( n1 - n2 )</dt>
                              <dd>Vrátí absolutní hodnotu.</dd>
                              <dt>NEGATE</dt>
                              <dt>( n1 - n2 )</dt>.
                              <dd>Změní znaménko.</dd>
                              <dt>MIN</dt>
                              <dt>( n1 n2 - n3 )</dt>.
                              <dd>Vrátí minimum.</dd>
                              <dt>MAX</dt>
                              <dt>( n1 n2 - n3 )</dt>.
                              <dd>Vrátí maximum.</dd>
                              <dt>&gt;R</dt>
                              <dt>( n - )</dt>.
                              <dd>Vezme hodnotu ze zásobníku parametrů a strčí ji na návratový zásobník.</dd>
                              <dt>R&gt;</dt>.
                              <dt>( - n )</dt>
                              <dd>Vezme hodnotu z návratového zásobníku a posune ji na zásobník parametrů.</dd>
                              <dt>R@</dt>
                              <dt>( - n )</dt>
                              <dd>Vybere horní položku z návratového zásobníku a přesune ji na zásobník parametrů.</dd>
                              <dt>*/</dt>
                              <dt>( n1 n2 n3 - n4 )</dt>
                              <dd>Násobí a pak dělí (n1*n2/n3). Používá dvojnásobně dlouhý mezivýsledek.</dd>
                              <dt>*/MOD</dt>
                              <dt>( n1 n2 n3 - n4 n5 )</dt>
                              <dd>Násobí a poté dělí (n1*n2/n3). Vrátí zbytek (n4) a kvocient (n5). Používá mezivýsledek o dvojnásobné délce.</dd>
                           </dl>
                           <h3><span id="Review_of_Terms">Přehled pojmů</span></h5>
                           <dl>
                              <dt>Dvojnásobně dlouhý mezivýsledek</dt>
                              <dd>hodnota dvojnásobné délky, která je dočasně vytvořena dvojčlenným operátorem, například */, takže "mezivýsledek" (výsledek první operace) může přesáhnout rozsah čísla o jedné délce, i když počáteční argumenty a konečný výsledek nejsou.</dd>
                              <dt>Aritmetika s pevným počtem bodů</dt>
                              <dd>aritmetika, která pracuje s čísly, jež sama o sobě neuvádějí umístění desetinných míst. Místo toho program pro libovolnou skupinu čísel předpokládá umístění desetinné čárky nebo pro všechna taková čísla uchovává umístění desetinné čárky jako samostatné číslo.</dd>
                              <dt>Aritmetika s pohyblivou řádovou čárkou</dt>
                              <dd>aritmetika, která pracuje s čísly, jež sama udávají umístění své desetinné čárky. Program musí být schopen interpretovat skutečnou hodnotu každého jednotlivého čísla předtím, než může být provedena jakákoli aritmetika.</dd>
                              <dt>Zásobník parametrů</dt>
                              <dd>ve Forthu oblast paměti, která slouží jako společný prostor mezi různými operacemi k předávání argumentů (čísel, příznaků nebo čehokoli jiného) z jedné operace do druhé.</dd>
                              <dt>Zásobník návratů</dt>
                              <dd>ve Forthu oblast paměti odlišná od zásobníku parametrů, kterou systém Forth používá mimo jiné k uchovávání "návratových adres" (bude probráno v <a href="https://www.forth.com/starting-forth/9-forth-execution/">Kap. 9</a>). Uživatel může za určitých podmínek dočasně uchovávat hodnoty na návratovém zásobníku </dd>.
                              <dt>Škálování</dt>
                              <dd>Proces násobení (nebo dělení) čísla poměrem. Označuje také proces násobení (nebo dělení) čísla mocninou deseti tak, aby všechny hodnoty v souboru dat mohly být reprezentovány jako celá čísla s předpokládanou desetinnou čárkou na stejném místě pro všechny hodnoty.</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="aligncenter"><img loading="lazy" width="230" height="100" src="./05-Fixed-Point Arithmetic_files/felix.gif" alt="Programovací jazyk Forth - příklady" class="wp-image-353"></figure>
                           </div>
                           <h3><span id="Problémy_kapitola_5">Problémy - kapitola 5</span></h5>
                           <ol class="sf-numbered">
                              <li>
                                 Přeložte následující algebraický výraz do definice jazyka Forth:
                                 <pre>-ab/c</pre> Převeďte Forthův vzorec do následujícího formátu: <pre>-ab/c</pre>.
                                 <p>dáno ( a b c - )</p>
                              </li>
                              <li>
                                 Vzhledem k těmto čtyřem číslům na zásobníku:
                                 <pre>( 6 70 123 45 -- )</pre>.
                                 <p>napište výraz, který vypíše největší hodnotu.&nbsp;</p>
                              </li>
                              <li>
                                 Ve "stylu kalkulačky" převeďte následující teploty pomocí těchto vzorců:
                                 <pre>°C = (°F - 32) / 1,8°F = (°C x 1,8) + 32°K = °C + 273</pre>.
                                 <p>(Prozatím vyjadřujte všechny argumenty a výsledky v celých stupních.)<br>0° F ve stupních Celsia<br>212° F ve stupních Celsia<br>-32° F v&nbsp;<span style="font-size: inherit;">Celsius</span><br>16° C ve stupních Fahrenheita<br>233° K ve stupních Celsia</p>
                              </li>
                              <li>
                                 Nyní definujte slova pro provádění převodů v úloze Prob. 3. Použijte následující názvy:
                                 <pre>F&gt;C F&gt;K C&gt;F C&gt;K K&gt;F K&gt;C</pre>.
                                 <p>Vyzkoušejte je s výše uvedenými hodnotami.</p>
                              </li>
                           </ol>
                           <div class="wp-block-genesis-blocks-gb-accordion gb-block-accordion gb-font-size-18">
                              <details>
                                 <summary class="gb-accordion-title">Odpovědi<br></summary>
                                 <div class="gb-accordion-text">
                                    <ol>
                                       <li>
                                          <pre>: -AB/C ( a b c -- -ab/c ) */ NEGATE ;
</pre>
                                       </li>
                                       <li>
                                          <pre>: LARGEST ( a b c d -- největší ) MAX MAX MAX . ;
</pre>
                                       </li>
                                       <li>
                                          <pre> 0 32 - 10 18 */ .
212 32 - 10 18 */ .
-32 32 - 10 18 */ .
 16 18 10 */ 32 + .
233 273 - .
</pre>
                                       </li>
                                       <li>
                                          <pre>: F&gt;C ( fahr -- cels ) 32 - 10 18 */ ;
: C&gt;F ( cels -- fahr ) 18 10 */ 32 + ;
: C&gt;K ( cels -- kelv ) 273 + ;
: K&gt;C ( kelv -- cels ) 273 - ;
: F&gt;K ( fahr -- kelv ) F&gt;C C&gt;K ;
: K&gt;F ( kelv -- fahr ) K&gt;C C&gt;F ;
</pre>
                                       </li>
                                    </ol>
                                 </div>
                              </details>
                           </div>
                        </div>
                     </div>
                  </article>
               </main>
            </div>
         </div>
      </div>
      <div class="site grid-container container hfeed grid-parent" id="page">
         <div class="site-content" id="content">
            <div class="content-area grid-parent mobile-grid-100 grid-70 tablet-grid-70" id="primary">
               <main class="site-main" id="main">
                  <article id="post-329" class="post-329 page type-page status-publish" itemtype="https://schema.org/CreativeWork" itemscope="">
                     <div class="inside-article">
                        <a id="kindsOfNumbers"><header class="entry-header" aria-label="Content">
                           <h2 class="entry-title" itemprop="headline">7. Řada druhů čísel</h2>
                        </header>
                        <div class="entry-content" itemprop="text">
                           <div class="wp-block-image">
                              <figure class="alignright"><img width="140" height="105" src="./07-Signed and Double-Length Numbers_files/ch7-binary-numbers.gif" alt="Čísla bez znaménka a čísla dvojkové délky a jejich operátory" class="wp-image-448"></figure>
                           </div>
                           <p>Dosud jsme hovořili pouze o číslech se znaménkem jedné délky. V této kapitole si představíme čísla bez znaménka a čísla dvojnásobné délky a také celou řadu nových operátorů, které se k nim hodí.</p>
                           <p>Tato kapitola je rozdělena do dvou částí:</p>
                           <p><em>Pro začátečníky</em> - tato část vysvětluje, jak se počítač dívá na čísla a co přesně znamenají pojmy signed nebo unsigned a single length nebo double length.</p>
                           <p><em>Pro každého</em> - tato část pokračuje v našem pojednání o jazyce Forth pro začátečníky i odborníky a vysvětluje, jak jazyk Forth zachází s čísly se znaménkem a bez znaménka, s čísly o jedné a o dvou délkách.<br></p>
                           <h3 id="h-sekce-1-pro-začátečníky"><span id="Sekce_1_Pro_začátečníky">Sekce 1 - Pro začátečníky</span></h3>
                           <h3 id="h-signed-versus-unsigned-numbers"><span id="Signed_versus_Unsigned_Numbers">Signed versus Unsigned Numbers</span></h5>
                           <p>Všechny digitální počítače ukládají čísla v binární podobě. Ve Forthu hovoříme o zásobníku v termínech "velikosti buňky" implementace (běžné velikosti jsou 16, 32 a 64 bitů, ale jsou možné i jiné velikosti buněk). Níže je uveden pohled na nejméně významných šestnáct bitů buňky, který ukazuje hodnotu každého bitu:</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="61" src="./07-Signed and Double-Length Numbers_files/ch7-32bit-numbers.gif" alt="16bitová, 32bitová a 64bitová čísla a velikosti buněk datových zásobníků Forth&#39;s" class="wp-image-449"></figure>
                           <p>Pokud by každý bit obsahoval jedničku, celkový počet jen těchto šestnácti bitů by byl 65 535. Ve 32 bitech tedy můžeme vyjádřit libovolnou hodnotu v rozmezí 0 až 4 294 967 295. Protože tento druh čísla nám neumožňuje vyjádřit záporné hodnoty, říkáme mu "číslo bez znaménka". V našich tabulkách a zápisech zásobníku označujeme čísla bez znaménka písmenem "u".</p>
                           <p>Ale co záporná čísla? Abychom mohli vyjádřit kladné nebo záporné číslo, musíme obětovat jeden bit, který bude v podstatě označovat znaménko. Tímto bitem je bit úplně vlevo, "bit vyššího řádu". V 31 bitech můžeme vyjádřit číslo vysoké až 2 147 483 647. Když znaménkový bit obsahuje 1, můžeme se vrátit o stejnou vzdálenost zpět do záporných čísel. V rámci 32 bitů tak můžeme vyjádřit libovolné číslo od -2 147 483 648 do +2 147 483 647. To by vám mělo připadat povědomé jako rozsah čísla o jedné délce, které označujeme písmenem "n" </p>.
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="81" src="./07-Signed and Double-Length Numbers_files/ch7-sign-bit.gif" alt="Rozsahy čísel ve 32 bitech - podrobnosti o implementaci Forthu" class="wp-image-450"></figure>
                           <p>Než vás zanecháme s mylnými představami, raději objasníme způsob reprezentace záporných čísel. Možná si myslíte, že jde o jednoduchou záležitost, kdy nastavením znaménkového bitu označíte, zda je číslo kladné nebo záporné, ale tak to nefunguje.</p>
                           <p> Abychom vysvětlili, jak se záporná čísla reprezentují, vraťme se k desetinnému zápisu a prozkoumejme počítadlo, jaké najdete na mnoha webových stránkách.</p>
                           <div class="wp-block-image">
                              <figure class="alignleft"><img loading="lazy" width="75" height="20" src="./07-Signed and Double-Length Numbers_files/20400.gif" alt="Reprezentace záporných čísel ve Forthu" class="wp-image-451"></figure>
                           </div>
                           <p>Řekněme, že čítač má tři číslice, nikoliv pět. Když stránku navštíví více lidí, kolečka počítadla se otočí a číslo se zvýší. Začněte opět s počítadlem na hodnotě 0 a nyní si představte, že velmi litujete, že jste stránku navštívili, a mohli byste ji "zrušit" tím, že byste kolečka počítadla otočili zpět. První číslo, které uvidíte, je 999, což je v jistém smyslu totéž jako -1. Další číslo bude 998, což je totéž jako -2, a tak dále.</p>
                           <p>Zobrazení čísel se znaménkem v počítači je podobné.</p>
                           <p>Začneme-li 32bitovým číslem</p>
                           <pre class="wp-block-preformatted">0000,0000,0000,0000,0000,0000,0000,0000</pre>
                           <p>a postupujeme-li o jedno číslo zpět, dostaneme</p>
                           <pre class="wp-block-preformatted">1111,1111,1111,1111,1111,1111,1111,1111 (thirty-two ones)</pre>
                           <p>což znamená 4 294 967 295 v zápisu bez znaménka i -1 v zápisu se znaménkem. Číslo</p>
                           <pre class="wp-block-preformatted">1111,1111,1111,1111,1111,1111,1111,1110</pre>
                           <p>které v nepodepsaném zápisu znamená 4 294 967 294, ve podepsaném zápisu představuje -2.</p>
                           <p>Tady je tabulka, která ukazuje, jak lze binární číslo na zásobníku použít buď jako číslo bez znaménka, nebo jako číslo se znaménkem:</p>
                           <div class="wp-block-image">
                              <figure class="aligncenter"><img loading="lazy" width="460" height="233" src="./07-Signed and Double-Length Numbers_files/ch7-signed-unsigned-number.gif" alt="Binární čísla a čísla se znaménkem, čísla bez znaménka ve Forthu" class="wp-image-452"></figure>
                           </div>
                           <p>Tento bizarně vypadající způsob reprezentace záporných hodnot umožňuje počítači používat pro odčítání stejné postupy jako pro sčítání.</p>
                           <p>Abychom si ukázali, jak to funguje, vezměme si velmi jednoduchý problém:</p>
                           <pre class="wp-block-preformatted"> 2<br><span style="border-bottom: solid 1px #000;">-1 </span></pre>
                           <p>Odčítání jedničky od dvojky je stejné jako sčítání dvojky a záporné jedničky. V jedničkovém binárním zápisu vypadá dvojka takto:</p>
                           <pre class="wp-block-preformatted">0000,0000,0000,0000,0000,0000,0000,0010</pre>
                           <p>zatímco záporná jednička vypadá takto:</p>
                           <pre class="wp-block-preformatted">1111,1111,1111,1111,1111,1111,1111,1111</pre>
                           <p>Počítač je sčítá stejným způsobem, jako bychom je sčítali na papíře; to znamená, že když součet v některém sloupci překročí jedničku, přenese jedničku do dalšího sloupce. Výsledek vypadá takto:</p>
                           <pre class="wp-block-preformatted"> 0000,0000,0000,0000,0000,0000,0000,0010<br>+1111,1111,1111,1111,1111,1111,1111,1111<br>10000,0000,0000,0000,0000,0000,0000,0001</pre>
                           <p>Jak vidíte, počítač musel přenést jedničku do každého sloupce po celé délce a skončil s jedničkou na třicátém třetím místě. Protože je však zásobník široký pouze dvaatřicet bitů, výsledek je jednoduše</p>
                           <pre class="wp-block-preformatted">0000,0000,0000,0000,0000,0000,0000,0001</pre>
                           <p>což je správná odpověď, jednička.</p>
                           <p>Nemusíme vám vysvětlovat, jak počítač převádí kladné číslo na záporné, ale řekneme vám, že tento proces se nazývá "doplňování dvojky" </p>.
                           <h3 id="h-aritmetický-posun"><span id="Aritmetický-posun">Aritmetický-posun</span></h5>
                           <p>Když už jsme u toho, jak počítač provádí určité matematické operace, vysvětlíme si, co znamenají záhadné výrazy ještě v <a href="https://www.forth.com/starting-forth/5-fixed-point-arithmetic/">kapitole 5</a>: "aritmetický posun doleva" a "aritmetický posun doprava".</p>
                           <p> Okamžité přehrání jazyka Forth:</p>
                           <dl class="forth">
                              <dt>2*</dt>
                              <dt>( n1 - n2 )</dt>
                              <dd>Násobí dvěma (aritmetický posun doleva).</dd>
                              <dt>2/</dt>
                              <dt>( n1 - n2 )</dt>.
                              <dd>Dělí dvěma (aritmetický posun doprava).</dd>
                           </dl>
                           <p>Pro ilustraci si vybereme číslo, řekněme šest, a zapíšeme ho v binárním tvaru:</p>
                           <pre class="wp-block-preformatted">0000,0000,0000,0000,0000,0000,0000,0110</pre>
                           <p>(4+2). Nyní posuneme každou číslici o jedno místo doleva a na volné místo ve sloupci jedniček vložíme nulu.</p>
                           <pre class="wp-block-preformatted">0000,0000,0000,0000,0000,0000,0000,1100</pre>
                           <p>Toto je binární reprezentace dvanácti (8+4), což je přesně dvojnásobek původního čísla. Funguje to ve všech případech a funguje to i obráceně. Pokud každou číslici posunete o jedno místo <em>vpravo</em> a volnou číslici vyplníte nulou, bude výsledek vždy <em>polovina</em> původní hodnoty.</p>
                           <p>Při aritmetickém posunu se znaménkový bit neposouvá. To znamená, že kladné číslo zůstane kladné a záporné číslo zůstane záporné, když ho vydělíte nebo vynásobíte dvěma.</p>
                           <p>Když se bit vyššího řádu posune spolu se všemi ostatními bity, používá se termín "logický posun". Ve Forthu můžete provést logický posun až o 32 míst pomocí slov LSHIFT a RSHIFT.</p>
                           <p>Důležité je, abyste věděli, že většina počítačů dokáže číslice posunout mnohem rychleji, než dokáže projít všemi složkami běžného dělení nebo násobení. Pokud je rychlost kritická, je mnohem lepší říkat</p>
                           <pre class="wp-block-preformatted">2*</pre>
                           <p>než</p>
                           <pre class="wp-block-preformatted">2 *</pre>
                           <p>a možná je dokonce lepší říci</p>
                           <pre class="wp-block-preformatted">2* 2* 2*</pre>
                           <p>než</p>
                           <pre class="wp-block-preformatted">8 *</pre>
                           <p>závisí na konkrétním modelu počítače, ale toto téma se teď stává příliš technickým.</p>
                           <h3 id="h-an-introduction-to-double-length-numbers"><span id="An_Introduction_to_Double-Length_Numbers">Úvod do čísel dvojkové délky</span></h5>
                           <p>Číslo dvojí délky je přesně to, co jste pravděpodobně očekávali - číslo, které je reprezentováno ve dvou buňkách místo jedné. V 32bitové implementaci jazyka Forth mají čísla se znaménkem dvojité délky rozsah -9 223 372 036 854 775 808 až 9 223 372 036 854 775 807 (se znaménkem) nebo 0 až 18 446 744 073 709 551 615 (bez znaménka).</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="100" src="./07-Signed and Double-Length Numbers_files/ch7-double-length-numbers.gif" alt="Signovaná čísla dvojí délky v 32bitových implementacích Forthu" class="wp-image-453"></figure>
                           <p>V jazyce Forth zaujímá číslo dvojí délky místo dvou čísel jedné délky na zásobníku. Operátory jako 2DUP jsou užitečné buď pro čísla dvojí délky, nebo pro dvojice čísel jedné délky.</p>
                           <p>Ještě jednu věc bychom měli vysvětlit: pro počítačový svět, který neovládá jazyk Forth, může termín "dvojslovo" znamenat 32bitovou hodnotu nebo čtyři bajty. Ve Forthu však "slovo" znamená definovaný příkaz. Aby se tedy programátoři jazyka Forth vyhnuli zmatkům, označují jedno číslo na zásobníku jako "buňku". Dvojnásobně dlouhé číslo vyžaduje dvě buňky.</p>
                           <h3 id="h-ostatní-číselné-základy"><span id="Other_Number_Bases">Ostatní číselné základy</span></h5>
                           <p>Jakmile se budete více zabývat programováním, budete muset kromě desítkové a dvojkové soustavy používat i jiné číselné báze, zejména šestnáctkovou (základ 16) a případně osmičkovou (základ 8). Protože o těchto dvou číselných bázích budeme hovořit později v této kapitole, myslíme si, že by se vám nyní mohl hodit úvod.</p>
                           <p>Počítači začali používat šestnáctkovou a osmičkovou soustavu čísel z jednoho hlavního důvodu: počítače myslí ve dvojkové soustavě a lidé mají problém se čtením dlouhých dvojkových čísel. Pro lidi je mnohem snazší převádět binární čísla na hexadecimální než binární na desítková, protože šestnáctka je sudá mocnina dvou, zatímco desítka ne. Totéž platí pro osmičkovou soustavu. Programátoři tedy obvykle používají šestnáctkovou nebo osmičkovou soustavu k vyjádření binárních čísel, která počítač používá pro takové věci, jako jsou adresy a strojové kódy. Šestnáctková soustava (nebo jednoduše "hex") vypadá na první pohled podivně, protože používá písmena A až F.</p>
                           <figure class="wp-block-table is-style-regular">
                              <table>
                                 <tbody>
                                    <tr>
                                       <td><strong>Decimální</strong></td>
                                       <td><strong>Dvojkový</strong></td>
                                       <td><strong>Hexadecimální</strong></td>
                                    </tr>
                                    <tr>
                                       <td>0</td>
                                       <td>0000</td>
                                       <td>0</td>
                                    </tr>
                                    <tr>
                                       <td>1</td>
                                       <td>0001</td>
                                       <td>1</td>
                                    </tr>
                                    <tr>
                                       <td>2</td>
                                       <td>0010</td>
                                       <td>2</td>
                                    </tr>
                                    <tr>
                                       <td>3</td>
                                       <td>0011</td>
                                       <td>3</td>
                                    </tr>
                                    <tr>
                                       <td>4</td>
                                       <td>0100</td>
                                       <td>4</td>
                                    </tr>
                                    <tr>
                                       <td>5</td>
                                       <td>0101</td>
                                       <td>5</td>
                                    </tr>
                                    <tr>
                                       <td>6</td>
                                       <td>0110</td>
                                       <td>6</td>
                                    </tr>
                                    <tr>
                                       <td>7</td>
                                       <td>0111</td>
                                       <td>7</td>
                                    </tr>
                                    <tr>
                                       <td>8</td>
                                       <td>1000</td>
                                       <td>8</td>
                                    </tr>
                                    <tr>
                                       <td>9</td>
                                       <td>1001</td>
                                       <td>9</td>
                                    </tr>
                                    <tr>
                                       <td>10</td>
                                       <td>1010</td>
                                       <td>A</td>
                                    </tr>
                                    <tr>
                                       <td>11</td>
                                       <td>1011</td>
                                       <td>B</td>
                                    </tr>
                                    <tr>
                                       <td>12</td>
                                       <td>1100</td>
                                       <td>C</td>
                                    </tr>
                                    <tr>
                                       <td>13</td>
                                       <td>1101</td>
                                       <td>D</td>
                                    </tr>
                                    <tr>
                                       <td>14</td>
                                       <td>1110</td>
                                       <td>E</td>
                                    </tr>
                                    <tr>
                                       <td>15</td>
                                       <td>1111</td>
                                       <td>F</td>
                                    </tr>
                                 </tbody>
                              </table>
                           </figure>
                           <p>Přijměme binární číslo o jedné délce:</p>
                           <pre class="wp-block-preformatted">00000000000000000111101110100001</pre>
                           <p>Chceme-li toto číslo převést do šestnáctkové soustavy, nejprve jej rozdělíme na osm jednotek po čtyřech bitech:</p>
                           <pre class="wp-block-preformatted">| 0000 | 0000 | 0000 | 0000 | 0111 | 1011 | 1010 | 0001 |</pre>
                           <p>poté každou čtyřbitovou jednotku převedeme na její hexadecimální ekvivalent:</p>
                           <pre class="wp-block-preformatted">|0|0|0|0|7|B|A|1|</pre>
                           <p>nebo jednoduše 7BA1.</p>
                           <p>Oktová čísla používají pouze číslice 0 až 7. Protože v dnešní době většina počítačů používá šestnáctkovou reprezentaci, příklad převodu do osmičkové soustavy vynecháme.</p>
                           <p>Podrobněji se převodům budeme věnovat v části nazvané "Převody čísel" později v této kapitole.</p>
                           <h3 id="h-the-ascii-znaková-sada"><span id="The_ASCII_Character_Set">Sada znaků ASCII</span></h5>
                           <p>Pokud počítač používá k ukládání čísel binární zápis, jak ukládá znaky a další symboly? Opět binárně, ale ve speciálním kódu, který byl před mnoha lety přijat jako průmyslový standard. Tento kód se nazývá American Standard Code for Information Interchange, obvykle zkráceně ASCII.</p>
                           <p>Tabulka 7-1 ukazuje každý znak ASCII v systému, jeho 7bitovou kódovanou sadu znaků pro výměnu informací podle normy ISO 646-1983, ekvivalent mezinárodní referenční verze (IRV) a jeho hexadecimální podobu.</p>
                           <p>Znaky v prvním sloupci (hexadecimální kódy ASCII 0-1F) se nazývají "řídicí znaky", protože označují, že terminál nebo počítač má něco udělat, například zazvonit, vrátit mezerník, začít nový řádek atd. Zbývající znaky se nazývají "tiskové znaky", protože vytvářejí viditelné znaky včetně písmen, číslic nula až devět, všech dostupných symbolů a dokonce i prázdného místa (hex 20). Jedinou výjimkou je DEL (hex 7F), což je signál počítači, aby ignoroval poslední odeslaný znak.</p>
                           <p>V <a href="https://www.forth.com/starting-forth/1-forth-stacks-dictionary/">kapitole 1</a> jsme si představili slovo EMIT. EMIT vezme ASCII kód na zásobníku a pošle jej na terminál, aby jej terminál vytiskl jako znak. Například,</p>
                           <pre class="wp-block-preformatted">65 EMIT↵<span class="output">&gt;A ok </span>
66 EMIT↵<span class="output">B ok </span></pre>
                           <p>atd. (Používáme spíše desítkový než šestnáctkový ekvivalent, protože to váš počítač s největší pravděpodobností právě očekává)</p>.
                           <p>Proč netestovat EMIT při každém tiskovém znaku "automaticky"?</p>
                           <pre class="wp-block-preformatted">: PRINTABLES ( -- ) 127 32 DO I EMIT SPACE LOOP ;</pre>
                           <p>PRINTABLES bude emitovat každý tisknutelný znak v sadě ASCII; to znamená znaky od desetinného čísla 32 do desetinného čísla 126. (Kódy ASCII používáme jako index naší smyčky DO.)</p>
                           <pre class="wp-block-preformatted">PRINTABLES↵<span class="output"> ! " # $ % &amp; ' ( ) * + , - . / ...ok </span></pre>
                           <div class="wp-block-image">
                              <figure class="aligncenter">
                                 <img loading="lazy" width="995" height="455" src="./07-Signed and Double-Length Numbers_files/ascii-table.jpg" alt="" class="wp-image-72946" srcset="https://www.forth.com/wp-content/uploads/2018/12/ascii-table.jpg 995w, https://www.forth.com/wp-content/uploads/2018/12/ascii-table-300x137.jpg 300w, https://www.forth.com/wp-content/uploads/2018/12/ascii-table-768x351.jpg 768w, https://www.forth.com/wp-content/uploads/2018/12/ascii-table-600x274.jpg 600w" sizes="(max-width: 995px) 100vw, 995px">
                                 <figcaption>Tabulka 7.1 - Standardní grafické znaky &amp; ekvivalenty</figcaption>
                              </figure>
                           </div>
                           <p>Mezi řídicí (netisknutelné) znaky, které je dobré znát, patří následující:</p>
                           <figure class="wp-block-table">
                              <table>
                                 <tbody>
                                    <tr>
                                       <td><strong>Jméno</strong></td>
                                       <td><strong>Operace</strong></td>
                                       <td><strong>Decimální ekvivalent</strong></td>
                                    </tr>
                                    <tr>
                                       <td>BS</td>
                                       <td>Zpětná mezera</td>
                                       <td>8</td>
                                    </tr>
                                    <tr>
                                       <td>LF</td>
                                       <td>Linefeed</td>
                                       <td>10</td>
                                    </tr>
                                    <tr>
                                       <td>CR</td>
                                       <td>Carriage return</td>
                                       <td>13</td>
                                    </tr>
                                 </tbody>
                              </table>
                           </figure>
                           <p>Experimentujte s těmito řídicími znaky a zjistěte, co dělají.</p>
                           <p>ASCII je navržena tak, aby každý znak mohl být reprezentován jedním bajtem. V tabulkách v této knize se používá písmeno "c" nebo zkratka "char" pro označení hodnoty bajtu, která se používá jako kódovaný znak ASCII.</p>
                           <h3 id="h-bit-logic"><span id="Bit_Logic">Bitová logika</span></h5>
                           <p>Slova AND a OR (která jsme si představili v <a href="https://www.forth.com/starting-forth/4-conditional-if-then-statements/">kapitole 4</a>) používají "bitovou logiku"; to znamená, že s každým bitem se zachází samostatně a nedochází k "přenosům" z jednoho bitového místa na druhé. Podívejme se například, co se stane, když provedeme AND těchto dvou binárních čísel:</p>
                           <pre class="wp-block-preformatted">0000,0000,0000,0000,0000,0000,1111,1111<br><span style="border-bottom: solid 1px #000;">0000,0000,0000,0000,0110,0101,1010,0010</span> AND<br>0000,0000,0000,0000,0000,0000,1010,0010</pre>
                           <p>Aby byl jakýkoli výsledný bit "1", musí být příslušné bity v obou argumentech "1". V tomto příkladu si všimněte, že argument nahoře obsahuje všechny nuly ve vyšších bajtech a všechny jedničky v nižších bajtech. Vliv na druhý argument v tomto příkladu spočívá v tom, že osm bitů nižšího řádu zůstane zachováno, ale dvacet čtyři bitů vyššího řádu bude nastaveno na nulu. První argument je zde použit jako "maska", která maskuje bajty vysokého řádu druhého argumentu.</p>
                           <p>Slovo OR také používá bitovou logiku. Například,</p>
                           <pre class="wp-block-preformatted">1000,0100,0010,0001,1000,1001,0000,1001<br><span style="border-bottom: solid 1px #000;">0110,0110,0110,0110,0000,0011,1100,1000</span> OR<br>1110,0110,0110,0111,1000,1011,1100,1001</pre>
                           <p>Při zadání "1" v obou argumentech se ve výsledku zobrazí "1". Opět se s každým sloupcem zachází samostatně, bez přenášení.</p>
                           <p>Chytrým použitím masek bychom dokonce mohli použít 32bitovou hodnotu pro 32 samostatných příznaků. Mohli bychom například zjistit, zda tento bit</p>
                           <pre class="wp-block-preformatted">1000,0100,0010,0001,1000,1001,0000,1001
                    ^</pre>
                           <p>je "1" nebo "0" tím, že zamaskujeme všechny ostatní příznaky, například takto:</p>
                           <pre class="wp-block-preformatted">1000,0100,0010,0001,1000,1001,0000,1001<br><span style="border-bottom: solid 1px #000;">0000,0000,0000,0000,1000,0000,0000,0000</span> AND<br>0000,0000,0000,0000,1000,0000,0000,0000</pre>
                           <p>Jelikož bit byl "1", výsledkem je "true". Kdyby byl bit "0", byl by výsledek "0" nebo "nepravda".</p>
                           <p>Pomocí této techniky bychom mohli nastavit příznak na hodnotu "0", aniž bychom ovlivnili ostatní příznaky:</p>
                           <pre class="wp-block-preformatted">1000,0100,0010,0001,1000,1001,0000,1001<br><span style="border-bottom: solid 1px #000;">1111,1111,1111,1111,<strong>0</strong>111,1111,1111,1111</span> AND<br>1000,0100,0010,0001,0000,1001,0000,1001</pre>
                           <p>Použili jsme masku, která obsahuje všechny "1" kromě bitu, který jsme chtěli nastavit na "0". Stejný příznak můžeme nastavit zpět na "1" pomocí této techniky:</p>
                           <pre class="wp-block-preformatted">1000,0100,0010,0001,0000,1001,0000,1001<br><span style="border-bottom: solid 1px #000;">0000,0000,0000,0000,<strong>1</strong>000,0000,0000,0000</span> OR<br>1000,0100,0010,0001,1000,1001,0000,1001</pre>
                           <h3 id="h-section-2-for-everybody"><span id="Section_2_For_Everybody">Section 2 - For Everybody</span></h3>
                           <h3 id="h-signed-and-unsigned-numbers"><span id="Signed_and_Unsigned_Numbers">Signed and Unsigned Numbers</span></h5>
                           <p>V <a href="https://www.forth.com/starting-forth/1-forth-stacks-dictionary/">kapitole 1</a> jsme si představili slovo ČÍSLA. Pokud slovo FIND nenajde ve slovníku příchozí řetězec, předá jej slovu NUMBER. Slovo NUMBER se pak pokusí řetězec převést na číslo vyjádřené v binární podobě. Pokud se to číslu NUMBER podaří, vloží binární ekvivalent na zásobník.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="134" src="./07-Signed and Double-Length Numbers_files/ch7-interpret-number.gif" alt="když Forth převádí řetězce na čísla" class="wp-image-454"></figure>
                           <div class="sc-info-box normal full">
                              <p></p>
                              <h3><span id="Pro_začátečníky">Pro začátečníky</span></h5>
                              <p>To znamená, že NUMBER nekontroluje, zda číslo, které jste zadali jako číslo o jedné délce, nepřesahuje správný rozsah. Pokud zadáte obří číslo, NUMBER ho převede, ale uloží pouze nejméně významnou třicetidvoucifernou číslici.<br></p>
                           </div>
                           <p>ČÍSLO neprovádí žádnou kontrolu rozsahu. Z tohoto důvodu může NUMBER převádět jak čísla se znaménkem, tak čísla bez znaménka.</p>
                           <p>Například pokud zadáte libovolné číslo v rozsahu 2147483648 až 4294967295, NUMBER jej převede jako číslo bez znaménka. Jakákoli hodnota mezi -2147483648 a -1 bude uložena jako celé číslo s dvojkovým doplňkem.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="125" src="./07-Signed and Double-Length Numbers_files/ch7-pronounce-1.gif" alt="Zásobník dat jazyka Forth&#39;může obsahovat binární hodnoty se znaménkem i bez znaménka" class="wp-image-455"></figure>
                           </div>
                           <p>Toto je důležitý bod: zásobník lze použít k uložení čísel se znaménkem i bez znaménka. To, zda bude binární hodnota interpretována jako podepsaná nebo nepodepsaná, závisí na operátorech, které na ni použijete. Rozhodněte se, která forma je pro danou situaci lepší, a pak se své volby držte.</p>
                           <p>Zavedli jsme slovo ., které vypíše hodnotu na zásobník jako číslo se znaménkem:</p>
                           <p>4294967295 .↵<span class="output">-1 ok </span></p>
                           <p>Slovo U. vytiskne binární reprezentaci jako číslo bez znaménka:</p>
                           <p>4294967295 U.↵<span class="output">4294967295 ok </span></p>
                           <dl class="forth">
                              <dt>U.</dt>
                              <dt>( u - )</dt>
                              <dd>Vytiskne číslo bez znaménka o jedné délce, za kterým následuje mezera.</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="136" src="./07-Signed and Double-Length Numbers_files/ch7-pronounce-2.gif" alt="Zápis signed an unsigned hodnot na zásobnících" class="wp-image-456"></figure>
                           </div>
                           <p>V této knize písmeno "n" označuje <em>signovaná</em> čísla o jedné délce, zatímco písmeno "u" označuje <em>nesignovaná</em> čísla o jedné délce. (Již jsme si představili funkci U.R, která vytiskne nepodepsané jednodélkové číslo vpravo zarovnané v rámci dané šířky sloupce.)</p>
                           <p>Zde jsou uvedena některá další slova, která používají čísla bez znaménka:</p>
                           <dl class="forth">
                              <dt>UM*</dt>
                              <dt>( u1 u2 - ud )</dt>
                              <dd>Sčítá dvě čísla o jedné délce. Vrátí výsledek o dvojnásobné délce. Všechny hodnoty jsou bez znaménka </dd>.
                              <dt>UM/MOD</dt>
                              <dt>( ud u1 - u2 u3 )</dt>
                              <dd>Dělí dvojnásobně dlouhé číslo jedničkovým číslem. Vrací zbytek u2 o jedné délce a kvocient u3. Všechny hodnoty jsou bez znaménka.</dd>
                              <dt>U&lt;</dt>
                              <dt>( u1 u2 - f )</dt>
                              <dd>Zůstane true, pokud u1 &lt; u2, přičemž se obě považují za celá čísla jedné délky bez znaménka.</dd>
                           </dl>
                           <h3 id="h-number-bases"><span id="Number_Bases">Číselné báze</span></h5>
                           <p>Při prvním spuštění jazyka Forth se při všech převodech čísel používá základ deset (desetinný), a to jak na vstupu, tak na výstupu.</p>
                           <div class="wp-block-image">
                              <figure class="aligncenter"><img loading="lazy" width="400" height="144" src="./07-Signed and Double-Length Numbers_files/ch7-default-base.gif" alt="převody čísel, výchozí je základ 10" class="wp-image-457"></figure>
                           </div>
                           <p> Základ můžete snadno změnit provedením jednoho z následujících příkazů:</p>
                           <dl class="forth">
                              <dt>HEX</dt>
                              <dt>( - )</dt>
                              <dd>Nastaví základnu na šestnáct.</dd>
                              <dt>OCTAL</dt>
                              <dt>( - )</dt>.
                              <dd>Nastaví základ na osm (dostupné v některých systémech).</dd>
                              <dt>DECIMAL</dt>
                              <dt>( - )</dt>
                              <dd>Nastaví základ na deset.</dd>
                           </dl>
                           <p>Pokud změníte základ čísla, zůstane změněný, dokud jej znovu nezměníte. Proto nezapomeňte deklarovat DECIMAL, jakmile skončíte s jiným základem čísla.</p>
                           <p>Tyto příkazy usnadňují provádění převodů čísel "ve stylu kalkulačky" </p>.
                           <p>Příklad chcete-li převést desetinné číslo 100 na šestnáctkové, zadejte</p>
                           <pre class="wp-block-preformatted">DECIMAL 100 HEX .↵<span class="output">64 ok </span></pre>
                           <p>Chcete-li převést hexadecimální F na desítkovou soustavu (nezapomeňte, že už jste v hexadecimální soustavě), zadejte</p>
                           <pre class="wp-block-preformatted">0F DECIMAL .↵<span class="output">15 ok </span></pre>
                           <p>Zvykněte si, počínaje tímto okamžikem, před každou hexadecimální hodnotu vkládat nulu, jako například</p>
                           <pre class="wp-block-preformatted">0A 0B 0F</pre>
                           <p>Tímto postupem se vyhnete záměně s případně předdefinovanými slovy jako DEADBEEF, BAD, DEC atd.</p>
                           <h3 id="h-handy-hint-a-definice-binární-nebo-jaké-koliv-ary"><span id="Handy_Hint_A_definice_binární-nebo-jaké-koliv-ary">Handy Hint
                              Definice pojmu BINÁRNÍ - nebo libovolný-ARY</span>
                           </h5>
                           <p>
                              Začátečníci, kteří se chtějí podívat, jak vypadají čísla v binárním zápisu, mohou zadat tuto definici:
                           </p>
                           <pre class="wp-block-preformatted">: BINARY ( -- ) 2 BASE ! ;</pre>
                           <p>
                              Nové slovo BINARY bude fungovat stejně jako OCTAL nebo HEX, ale změní základ čísla na <em>dvojku</em>. V systémech, které nemají slovo OCTAL, mohou experimentátoři definovat např.
                           </p>
                           <pre class="wp-block-preformatted">: OCTAL ( -- ) 8 BASE ! ;</pre>
                           <h3 id="h-double-length-numbers"><span id="Double-Length_Numbers">Čísla dvojí délky</span></h5>
                           <p>Většina systémů ANS Forth do určité míry podporuje čísla dvojí délky. Standardním způsobem, jak zadat do zásobníku číslo dvojí délky (ať už z klávesnice nebo ze souboru), je jeho přerušení tečkou na konci. Když textový interpret zpracovává číslo, za kterým bezprostředně následuje desetinná tečka a které se nenachází jako název definice, převede se na dvojčíslí.</p>
                           <p>Například při zadání</p>
                           <pre class="wp-block-preformatted">200000.↵</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="300" height="120" src="./07-Signed and Double-Length Numbers_files/ch7-convert-double.gif" alt="Desetinné tečky v čísle označují čísla dvojí délky" class="wp-image-458"></figure>
                           </div>
                           <p>ČÍSLO rozpozná tečku na konci jako signál, že tato hodnota má být převedena na dvojnásobnou délku. NUMBER pak tuto hodnotu přesune na zásobník jako dvě po sobě jdoucí "buňky" (buňka je termín jazyka Forth pro prvek jedné délky na zásobníku), přičemž buňka vyššího řádu je nahoře.</p>
                           <p>Některé implementace jazyka Forth (včetně SwiftForth) převedou každé číslo, které obsahuje následující znaky, jako dvojčíslí:</p>
                           <pre class="wp-block-preformatted">+ , - . / :</pre>
                           <p>Slovo Forth D. vytiskne dvojciferné číslo bez interpunkce:</p>
                           <dl class="forth">
                              <dt>D.</dt>
                              <dt>( d - )</dt>
                              <dd>Vytiskne podepsané dvojciferné číslo d, za kterým následuje jedna mezera.</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="126" src="./07-Signed and Double-Length Numbers_files/ch7-pronounce-3.gif" alt="Interpunkce v číselných řetězcích, které označují čísla dvojí délky v některých implementacích jazyka Forth" class="wp-image-459"></figure>
                           </div>
                           <p>V této knize písmeno "d" označuje celé číslo se znaménkem dvojité délky.</p>
                           <p>Příklad po zadání čísla dvojnásobné délky, pokud byste nyní provedli příkaz D.,počítač by odpověděl:</p>
                           <p></p>
                           <pre class="wp-block-preformatted">D.↵<span class="output">200000 ok </span></pre>
                           <p>V další části si ukážeme, jak definovat vlastní ekvivalenty k D., které spolu s číslem vypíší libovolnou interpunkci.</p>
                           <h3 id="h-formátování-čísel-dvojnásobná-délka-bezznaménková"><span id="Formátování_čísel_Dvojnásobná-délka_bezznaménková">Formátování čísel - dvojnásobná délka bez znaménka</span></h5>
                           <pre class="wp-block-preformatted">$200.00 31.12.1980 999-6784 6:32:59 98.6</pre>
                           <p>Výše uvedená čísla představují druhy výstupů, které můžete vytvořit definováním vlastních "slov pro formátování čísel" v jazyce Forth. V této části vám ukážeme, jak na to.</p>
                           <p>Nejjednodušší definice formátování čísel, kterou bychom mohli napsat, by byla</p>
                           <pre class="wp-block-preformatted">: UD. ( ud -- ) &lt;# #S #&gt; TYPE ;</pre>
                           <p>UD. vypíše číslo bez znaménka o dvojnásobné délce. Slova &lt;# a #&gt; (resp. vyslovovaná <em>číslo v závorce</em> a <em>číslo v závorce</em>) označují začátek a konec procesu převodu čísla. V této definici se celá konverze provádí pomocí jediného slova #S (vyslovovaného čísla). #S převádí hodnotu na zásobníku na znaky ASCII. Vytvoří pouze tolik číslic, kolik je potřeba k reprezentaci čísla; nevytváří úvodní nuly. Vždy však vytvoří alespoň jednu číslici, která bude nulová, pokud byla hodnota nulová. Například:</p>
                           <pre class="wp-block-preformatted">12,345 UD.↵<span class="output">12345ok </span>
12. UD.↵<span class="output">12ok </span>
0. UD.↵<span class="output">0ok </span></pre>
                           <p>Slovo TYP vypíše znaky, které představují číslo na terminálu. Všimněte si, že mezi číslem a znakem "ok" není žádná mezera. Chcete-li získat mezeru,stačí přidat slovo SPACE, například takto:</p>
                           <pre class="wp-block-preformatted">: UD. ( ud -- ) &lt;# #S #&gt; TYPE SPACE ;</pre>
                           <p>Nyní řekněme, že máme na zásobníku telefonní číslo vyjádřené jako celé číslo bez znaménka o dvojnásobné délce. Mohli jsme například zadat:</p>
                           <pre class="wp-block-preformatted">999-6784</pre>
                           <p>(nezapomeňte, že pomlčka říká číslu NUMBER, aby s touto hodnotou zacházelo jako s hodnotou dvojnásobné délky). Chceme definovat slovo, které bude tuto hodnotu formátovat zpět jako telefonní číslo. Nazvěme jej .PH# (pro "vypsat telefonní číslo") a definujme jej takto:</p>
                           <pre class="wp-block-preformatted">: .PH# ( ud -- ) &lt;# # # # # [CHAR] - HOLD #S #&gt; TYPE SPACE ;</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="140" height="106" src="./07-Signed and Double-Length Numbers_files/ch7-telephone.gif" alt="Formáty výstupních čísel ve Forthu" class="wp-image-460"></figure>
                           </div>
                           <p>Naše definice .PH# má vše, co má UD., a ještě něco navíc. Slovo # (vyslovované <em>číslo</em>) v jazyce Forth vytváří pouze jednu číslici. Definice tvaru čísla je obrácená oproti pořadí, v jakém se číslo vytiskne, takže věta</p>
                           <p></p>
                           <pre class="wp-block-preformatted"># # # #</pre>
                           <p>produkuje čtyři nejpravější číslice telefonního čísla.</p>
                           <p>Nyní je čas vložit pomlčku. Pomocí [CHAR] můžeme získat kódovou hodnotu tohoto ASCII znaku na zásobníku. Forthovské slovo HOLD převezme tento kód ASCII a vloží jej do formátovaného řetězce znaků čísla.</p>
                           <p>Nyní nám zbývají tři číslice. Můžeme použít větu</p>
                           <pre class="wp-block-preformatted"># # #</pre>
                           <p>ale jednodušší je jednoduše použít slovo #S, které za nás automaticky převede zbytek čísla.</p>
                           <p>Nyní zformátujeme nepodepsané dvojčíslí jako datum, a to v následujícím tvaru:</p>
                           <pre class="wp-block-preformatted">6/15/03</pre>
                           <p>Tady je definice:</p>
                           <pre class="wp-block-preformatted">: .DATE ( ud -- ) &lt;# # # [CHAR] / HOLD # # [CHAR] / HOLD #S #&gt; TYPE SPACE ;</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="129" src="./07-Signed and Double-Length Numbers_files/ch7-calendar.gif" alt="Formátování data v číselném výstupu Forth&#39;u" class="wp-image-461"></figure>
                           </div>
                           <p>Postupujme podle výše uvedené definice a pamatujme, že se zapisuje v opačném pořadí než výstup. Výraz</p>
                           <pre class="wp-block-preformatted"># # [CHAR] / HOLD

</pre>
                           <p>produkuje dvě nejpravější číslice (představující rok) a pravé lomítko. Další výskyt stejné fráze vytvoří prostřední dvě číslice (představující den) a levé lomítko. Nakonec #S vytvoří dvě nejlevější číslice (představující měsíc).</p>
                           <p>Stejně snadno bychom mohli definovat</p>
                           <pre class="wp-block-preformatted"># # [CHAR] / HOLD</pre>
                           <p>jako vlastní slovo a použít toto slovo dvakrát v definici .DATE.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="310" src="./07-Signed and Double-Length Numbers_files/ch7-clock.gif" alt="změna číselných základů pro časové hodnoty" class="wp-image-462"></figure>
                           </div>
                           <p>Protože máte kontrolu nad procesem převodu, můžete skutečně převádět různé číslice v různých číselných základech, což je funkce, která je užitečná při formátování takových čísel, jako jsou hodiny a minuty. Řekněme například, že máte na zásobníku čas v sekundách a chcete slovo, které vypíše hh:mm:ss. Můžete jej definovat takto:</p>
                           <pre class="wp-block-preformatted">: SEXTAL ( -- ) 6 BASE ! ;
: :00 ( ud1 -- ud2 ) # SEXTAL # DECIMAL [CHAR] : HOLD ;
: SEC ( ud -- ) &lt;# :00 :00 #S #&gt; TYPE SPACE ;</pre>
                           <p>K formátování sekund a minut použijeme slovo :00. Sekundy i minuty jsou modulo-60, takže pravá číslice může být až devět, ale levá číslice může být jen do pěti. V definici :00 tedy převedeme první číslici (tu vpravo) jako desetinné číslo, pak přejdeme do "sextálu" (základ 6) a převedeme levou číslici. Nakonec se vrátíme do desítkové soustavy a vložíme znak dvojtečky. Poté, co :00 převede sekundy a minuty,#S převede zbývající hodiny.</p>
                           <p>Příklad pokud bychom měli na zásobníku 4500 sekund, dostali bychom</p>
                           <pre class="wp-block-preformatted">4500. SEC↵<span class="output">1:15:00 ok </span></pre>
                           <p>Tento slovníček shrnuje slova jazyka Forth, která se používají při formátování čísel:</p>
                           <dl class="forth">
                              <dt>&lt;#</dt>
                              <dt>( - )</dt>
                              <dd>Začíná proces převodu čísla.</dd>
                              <dt>#</dt>
                              <dt>( ud1 - ud2 )</dt>
                              <dd>Převede jednu číslici a předepíše ji do výstupního řetězce znaků. <em>Vždy</em> vytvoří jednu číslici - pokud vám chybí významné číslice, dostanete za každé # nulu.</dd>.
                              <dt>#S</dt>
                              <dt>( ud1 - ud2 )</dt>
                              <dd>Převádí číslo, dokud výsledek není nula. Vždy vytvoří <em>alespoň jednu číslici</em> (0, pokud je hodnota nulová).</dd>
                              <dt>HOLD</dt>
                              <dt>( znak - )</dt>
                              <dd>Vloží na aktuální pozici formátovaného řetězce znaků znak, jehož ASCII hodnota je na zásobníku. HOLD (nebo slovo, které používá HOLD) musí být použito mezi &lt;# a #&gt;.</dd>
                              <dt>ZNAČKA</dt>
                              <dt>( n - )</dt>
                              <dd>Připraví do výstupního řetězce znaménko minus, pokud je vrchol zásobníku záporný.</dd>
                              <dt>#&gt;</dt>
                              <dt>( ud - addr len )</dt>
                              <dd>Ukončí převod čísla tak, že na zásobníku ponechá adresu a délku řetězce (to jsou příslušné argumenty pro TYPE).</dd>
                           </dl>
                           <p>Tyto jsou efekty zásobníku pro formátování čísel:</p>
                           <dl class="forth">
                              <dt>&lt;# ... #&gt;</dt>
                              <dt>( ud - addr len )</dt>
                              <dd>Převede dvojnásobně dlouhou nepodepsanou hodnotu ud na výstupní řetězec addr len.</dd>
                              <dt>&lt;# ... ROT SIGN #&gt;</dt>
                              <dt>( n |d| - addr u )</dt>
                              <dd>Převede dvojnásobně dlouhou hodnotu se znaménkem (kde n je buňka vyššího řádu d a |d| je absolutní hodnota d).</dd>
                           </dl>
                           <p>Klíč k zápisu komentáře zásobníku:</p>
                           <figure class="wp-block-table">
                              <table>
                                 <tbody>
                                    <tr>
                                       <td>n, n1, ...</td>
                                       <td>Jednodélkový signed</td>
                                    </tr>
                                    <tr>
                                       <td>d, d1, ...</td>
                                       <td>Dvojitá délka se znaménkem</td>
                                    </tr>
                                    <tr>
                                       <td>u, u1 ...</td>
                                       <td>Jednodélkové bez znaménka</td>
                                    </tr>
                                    <tr>
                                       <td>ud, ud1, ...</td>
                                       <td>Dvojnásobná délka bez znaménka</td>
                                    </tr>
                                    <tr>
                                       <td>addr</td>
                                       <td>Adresa</td>
                                    </tr>
                                    <tr>
                                       <td>len</td>
                                       <td>Délka (řetězce nebo vyrovnávací paměti)<br></td>
                                    </tr>
                                    <tr>
                                       <td>znak</td>
                                       <td>Hodnota znaku ASCII</td>
                                    </tr>
                                 </tbody>
                              </table>
                           </figure>
                           <h3 id="h-číslo-formátování-podepsané-a-jednotlivé-délky"><span id="Číslo_formátování_podepsané_a-jednotlivé-délky">Formátování čísla - podepsané a jednotlivá délka</span></h5>
                           <p>Dosud jsme formátovali pouze čísla bez znaménka o dvojnásobné délce. Formát &lt;#...#&gt; očekává pouze čísla bez znaménka dvojnásobné délky, ale můžeme jej použít i pro jiné typy čísel, pokud provedeme určité úpravy na zásobníku.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="275" src="./07-Signed and Double-Length Numbers_files/ch7-pronounce-4.gif" alt="Formátování signovaného číselného výstupu" class="wp-image-463"></figure>
                           </div>
                           <p>Podívejme se například na zjednodušenou verzi systémové definice D. (která vypisuje <em>signované</em> číslo dvojí délky):</p>
                           <pre class="wp-block-preformatted">: D. ( d -- ) TUCK DABS &lt;# #S ROT SIGN #&gt; TYPE SPACE ;</pre>
                           <p>Výraz ROT SIGN vloží do řetězce znaků mínusový řetězec, pokud je <em>třetí</em> číslo na zásobníku záporné. Na tento test jsme se připravili tak, že jsme kopii buňky vyššího řádu (té se znaménkovým bitem) umístili na konec zásobníku, a to pomocí slova TUCK.</p>
                           <p>Protože &lt;# očekává pouze <em>neznaménková</em> čísla dvojí délky,musíme vzít absolutní hodnotu našeho čísla dvojí délky se znaménkem, a to pomocí slova DABS. Nyní máme správné uspořádání argumentů na zásobníku pro větu &lt;#...#&gt;. V některých případech, například v účetnictví, můžeme chtít, aby bylo zapsáno záporné číslo</p>
                           <pre class="wp-block-preformatted">12345-</pre>
                           <p>v takovém případě bychom na levou stranu naší věty &lt;#...#&gt; umístili větu ROT SIGN, například takto:</p>
                           <pre class="wp-block-preformatted">&lt;# ROT SIGN #S #&gt;</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="60" height="75" src="./07-Signed and Double-Length Numbers_files/ch7-dollar-sign.gif" alt="Formátování částek měny ve Forthu" class="wp-image-464"></figure>
                           </div>
                           <p>Definujme slovo, které vytiskne podepsané číslo o dvojnásobné délce s desetinnou tečkou a dvěma desetinnými místy vpravo od desetinné čárky. Protože se tento tvar nejčastěji používá pro zápis dolarů a centů, nazvěme jej</p>
                           <pre class="wp-block-preformatted">.$</pre>
                           <p>a definujme jej takto:</p>
                           <pre class="wp-block-preformatted">: .$ ( d -- ) TUCK DABS &lt;# # # [CHAR] . HOLD #S ROT SIGN [CHAR] $ HOLD #&gt; TYPE SPACE ;</pre>
                           <p>Zkusme to:</p>
                           <pre class="wp-block-preformatted">2000.00 .$↵<span class="output">$2000.00 ok </span></pre>
                           <p>nebo dokonce</p>
                           <pre class="wp-block-preformatted">2 000,00 .$↵<span class="output">$2000,00 ok </span></pre>
                           <p>Doporučujeme uložit .$, protože jej budeme používat v některých budoucích příkladech.</p>
                           <p> Můžete také zapsat speciální formáty pro čísla o jedné délce. Chcete-li například použít číslo bez znaménka o jedné délce, jednoduše vložte na zásobník před slovo &lt;# nulu. Tím se efektivně změní číslo o jedné délce na číslo o dvojnásobné délce, které je tak malé, že nemá v buňce vyššího řádu nic (nulu). Chcete-li formátovat <em>signed</em> číslo o jedné délce, opět musíte dodat nulu jako buňku vysokého řádu. Musíte však také ponechat kopii čísla se znaménkem na třetí pozici zásobníku pro ROT SIGN a na druhé pozici zásobníku musíte ponechat absolutní hodnotu čísla. Věta, která toto vše provede, je</p>
                           <pre class="wp-block-preformatted">DUP ABS 0</pre>
                           <p>Tady jsou "nastavovací" fráze, které jsou potřeba k vypsání různých druhů čísel:</p>
                           <figure class="wp-block-table">
                              <table>
                                 <tbody>
                                    <tr>
                                       <td><strong>Číslo, které se má vytisknout</strong></td>
                                       <td><strong>Předchází &lt;# by</strong></td>
                                    </tr>
                                    <tr>
                                       <td>Dvojitá délka, bez znaménka</td>
                                       <td>(není potřeba)</td>
                                    </tr>
                                    <tr>
                                       <td>Double-length, signed</td>
                                       <td>SWAP OVER DABS<br>(pro uložení znaku pro SIGN)</td>
                                    </tr>
                                    <tr>
                                       <td>Jednodélkový, bez znaménka&nbsp;</td>
                                       <td>0 (pro dummy vysokého řádu)</td>
                                    </tr>
                                    <tr>
                                       <td>Jednodélkový, signed&nbsp;</td>
                                       <td>DUP ABS 0<br>(pro uložení znaku)</td>.
                                    </tr>
                                 </tbody>
                              </table>
                           </figure>
                           <h3 id="h-operátory dvojí délky"><span id="Operátory dvojí délky">Operátory dvojí délky</span></h5>
                           <p>Tady je seznam matematických operátorů dvojnásobné délky:</p>
                           <dl class="forth">
                              <dt>D.R</dt>
                              <dt>( d u - )</dt>
                              <dd>Vytiskne znaménkové dvojnásobně dlouhé číslo d, zarovnané doprava v rámci šířky pole u.</dd>
                              <dt>D+</dt>
                              <dt>( d1 d2 - d3 )</dt>
                              <dd>Složí dvě dvojciferná čísla d1 a d2 a vrátí součet d3</dd>.
                              <dt>D-</dt>
                              <dt>( d1 d2 - d3 )</dt>
                              <dd>Odčítá dvojciferné číslo d2 od d1 a vrací rozdíl d3.</dd>
                              <dt>DNEGATE</dt>
                              <dt>( d1 - d2 )</dt>
                              <dd>Změní znaménko dvojciferného čísla.</dd>
                              <dt>DMAX</dt>
                              <dt>( d1 d2 - d3 )</dt>.
                              <dd>Vrátí maximum dvou dvojciferných čísel.</dd>
                              <dt>DMIN</dt>
                              <dt>( d1 d2 - d3 )</dt>
                              <dd>Vrátí minimum dvou čísel dvojí délky.</dd>
                              <dt>D=</dt>
                              <dt>( d1 d2 - flag )</dt>
                              <dd>Vrátí true, pokud se d1 a d2 rovnají.</dd>
                              <dt>D0=</dt>
                              <dt></dt>
                              <dd>Vrátí true, pokud je d rovno nule.</dd>
                              <dt>D&lt;</dt>
                              <dt>( d1 d2 - flag )</dt>
                              <dd>Vrací true, pokud je d1 menší než d2. Obě čísla mají znaménko.</dd>
                              <dt>DU&lt;</dt>
                              <dt>( ud1 ud2 - flag )</dt>
                              <dd>Vrátí true, pokud je ud1 menší než ud2. Obě čísla jsou bez znaménka.</dd>
                           </dl>
                           <p>Počáteční písmeno "D" znamená, že tyto operátory lze použít pouze pro operace s dvojnásobnou délkou, zatímco počáteční písmeno "2", stejně jako u operátorů 2SWAP a 2DUP, znamená, že tyto operátory lze použít buď pro čísla dvojnásobné délky, nebo pro dvojice čísel jedné délky.</p>
                           <p>Uveďme si příklad použití operátoru D+:</p>
                           <pre class="wp-block-preformatted">200 000 300 000 D+ D.↵<span class="output">500000 ok </span></pre>
                           <h3 id="h-mixed-length-operators"><span id="Mixed-Length_Operators">Operátory smíšené délky</span></h5>
                           <p>Tady je seznam velmi užitečných operátorů jazyka Forth, které pracují s kombinací čísel jedné a dvou délek:</p>
                           <dl class="forth">
                              <dt>M+</dt>
                              <dt>( d1 n - d2 )</dt>
                              <dd>Přidá dvojnásobně dlouhé číslo d1 k jednonásobně dlouhému číslu n. Vrátí dvojnásobně dlouhý výsledek d2.</dd>
                              <dt>SM/REM</dt>
                              <dt>( d n1 - n2 n3 )</dt>
                              <dd>Dělí d1 číslem n1, čímž získá symetrický kvocient n3 a zbytek n2. Vstupní a výstupní argumenty zásobníku jsou se znaménkem. Nejednoznačná podmínka existuje, pokud je n1 nula nebo pokud kvocient leží mimo rozsah jednočíselného znaménkového čísla.</dd>
                              <dt>FM/MOD</dt>
                              <dt>( d n1 - n2 n3 )</dt>
                              <dd>Dělíme d1 číslem n1, čímž získáme plovoucí kvocient n3 a zbytek n2. Vstupní a výstupní argumenty zásobníku jsou se znaménkem. Nejednoznačná podmínka existuje, pokud je n1 nula nebo pokud kvocient leží mimo rozsah jednočíselného čísla se znaménkem.</dd>
                              <dt>M*</dt>
                              <dt>( n1 n2 - d )</dt>
                              <dd>Násobí dvě jednočíslí o jedné délce. Vrací dvojnásobně dlouhý výsledek. Všechny hodnoty jsou se znaménkem.</dd>
                              <dt>M*/</dt>
                              <dt> d1 +n1 n2 - d2 )</dt>
                              <dd>Násobí dvojnásobně dlouhé číslo d1 jednovýkonným kladným číslem n1 a trojnásobně dlouhý výsledek vydělí jednovýkonným číslem n2. Vrátí dvojnásobně dlouhý výsledek d2. Všechny hodnoty jsou se znaménkem.</dd>
                           </dl>
                           <p>Uveďme si příklad použití M+:</p>
                           <pre class="wp-block-preformatted">200 000 7 M+ D.↵<span class="output">200007 ok </span></pre>
                           <p>Nebo můžeme pomocí M*/ předefinovat naši dřívější verzi % tak, aby přijímala argument dvojí délky:</p>
                           <pre class="wp-block-preformatted">: % ( d1 -- d2 ) 100 M*/ ;</pre>
                           <p>jako v</p>
                           <pre class="wp-block-preformatted">200.50 15 % D.↵<span class="output">3007 ok </span></pre>
                           <p>Pokud jste načetli definici .$, kterou jsme uvedli v minulé Praktické nápovědě, můžete zadat</p>
                           <pre class="wp-block-preformatted">200,50 15 % .$↵<span class="output">30,07 ok </span></pre>
                           <p>Naší dřívější definici R% můžeme předefinovat tak, abychom získali zaokrouhlený dvojnásobně dlouhý výsledek, například takto:</p>
                           <pre class="wp-block-preformatted">: R% ( d1 -- d2 ) 10 M*/ 5 M+ 1 10 M*/ ;</pre>
                           <p>tedy</p>
                           <pre class="wp-block-preformatted">200,50 15 R% .$↵<span class="output">$30,08 ok</span></pre>
                           <p>Všimněte si, že M*/ je jediné hotové slovo jazyka Forth, které provádí násobení na argumentu dvojnásobné délky. Chceme-li například vynásobit 200 000 číslem 3, musíme jako fiktivní jmenovatel zadat "1":</p>
                           <pre class="wp-block-preformatted">200,000 3 1 M*/ D.↵<span class="output">600000 ok </span></pre>
                           <p>since</p>
                           <pre class="wp-block-preformatted"><span style="border-bottom: solid 1px #000;"> 3 </span>
 1</pre>
                           <p>je stejný jako 3.</p>
                           <p>M*/ je také jediné hotové slovo jazyka Forth, které provádí dělení s výsledkem dvojnásobné délky. Chceme-li tedy například vydělit 200 000 číslem 4, musíme zadat "1" jako fiktivní čitatel:</p>
                           <pre class="wp-block-preformatted">200,000 1 4 M*/ D.↵<span class="output">50000 ok </span></pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="200" height="176" src="./07-Signed and Double-Length Numbers_files/ch7-binary-monk.gif" alt="Sestavení čísel v binárním tvaru bez ohledu na aktuální číselný základ" class="wp-image-465"></figure>
                           </div>
                           <h3 id="h-čísla-v-definicích"><span id="Čísla_v_definicích">Čísla v definicích</span></h5>
                           <p>Když definice obsahuje číslo, jako například</p>
                           <pre class="wp-block-preformatted">: SCORE-MORE ( n1 -- n2 ) 20 + ;</pre>
                           <p>číslo je do slovníku zakomponováno v binární podobě, tak jak vypadá na zásobníku.</p>
                           <p>Binární hodnota čísla závisí na číselném základu v okamžiku <em>kompilování</em> definice. Pokud byste například zadali</p>
                           <pre class="wp-block-preformatted">HEX
: SCORE-MORE ( n1 -- n2 ) 14 + ;
DECIMAL</pre>
                           <p>definice slovníku by obsahovala hexadecimální hodnotu 14, která je stejná jako desítková hodnota 20 (16+4). Od této chvíle bude SCORE-MORE k hodnotě na zásobníku vždy přičítat ekvivalent desítkové hodnoty 20, bez ohledu na aktuální číselný základ.</p>
                           <p>Pokud byste naopak vložili slovo HEX <em>vnitř</em> definice, pak byste při spuštění definice změnili číselný základ.</p>
                           <p>Příklad pokud byste definovali:</p>
                           <pre class="wp-block-preformatted">DECIMAL
: EXAMPLE ( -- ) HEX 20 .  DECIMAL ;</pre>
                           <p>číslo by se zkompilovalo jako binární ekvivalent desítkové soustavy 20, protože DECIMAL byl v době kompilace aktuální.</p>
                           <p>V době provádění se stane toto:</p>
                           <pre class="wp-block-preformatted">Příklad↵<span class="output">14 ok </span></pre>
                           <p>Číslo se vypíše v šestnáctkové soustavě.</p>
                           <p>Pro zajímavost: číslo, které se objeví uvnitř definice, se nazývá "literál". (Na rozdíl od slov ve zbytku definice, která odkazují na jiné definice, musí být číslo bráno doslovně)</p>.
                           <h3 id="h-souhrn kapitoly"><span id="Souhrn kapitoly">Souhrn kapitoly</span></h3>
                           <h3 id="h-slovosled"><span id="Slovosled">Slovosled</span></h5>
                           <p>Tady je seznam slov Forth, která jsme probrali v této kapitole:</p>
                           <dl class="forth">
                              <dt>U.</dt>
                              <dt>( u - )</dt>
                              <dd>Vytiskne číslo bez znaménka o jedné délce, za kterým následuje mezera.</dd>
                              <dt>UM*</dt>
                              <dt>( u1 u2 - ud )</dt>
                              <dd>Sčítá dvě čísla o jedné délce. Vrací výsledek o dvojnásobné délce. Všechny hodnoty jsou bez znaménka.</dd>
                              <dt>UM/MOD</dt>
                              <dt>( ud u1 - u2 u3 )</dt>
                              <dd>Dělí dvojnásobně dlouhé číslo jedničkovým číslem. Vrací jednočíselný kvocient u2 a zbytek u3. Všechny hodnoty jsou bez znaménka.</dd>
                              <dt>U&lt;</dt>
                              <dt>( u1 u2 - f )</dt>
                              <dd>Zůstane true, pokud u1 &lt; u2, přičemž se obě považují za celá čísla jedné délky bez znaménka.</dd>
                              <dt>HEX</dt>
                              <dt>( - )</dt>
                              <dd>Nastaví základ na šestnáct.</dd>
                              <dt>OCTAL</dt>
                              <dt>( - )</dt>Přidá číslo.
                              <dd>Nastaví základ na osm (dostupné v některých systémech).</dd>
                              <dt>DECIMAL</dt>
                              <dt>( - )</dt>
                              <dd>Nastaví základ na deset.</dd>
                              <dt>&lt;#</dt>
                              <dt>( - )</dt>.
                              <dd>Spustí proces převodu čísel.</dd>
                              <dt>#</dt>
                              <dt>( ud1 - ud2 )</dt>.
                              <dd>Převede jednu číslici a předepíše ji do výstupního řetězce znaků. <em>Vždy</em> vytvoří jednu číslici - pokud vám chybí významné číslice, dostanete za každé # nulu.</dd>.
                              <dt>#S</dt>
                              <dt>( ud1 - ud2 )</dt>
                              <dd>Převádí číslo, dokud výsledek není nula. Vždy vytvoří <em>alespoň jednu číslici</em> (0, pokud je hodnota nulová).</dd>
                              <dt>HOLD</dt>
                              <dt>( znak - )</dt>
                              <dd>Vloží na aktuální pozici formátovaného řetězce znaků znak, jehož ASCII hodnota je na zásobníku. HOLD (nebo slovo, které používá HOLD) musí být použito mezi &lt;# a #&gt;.</dd>
                              <dt>ZNAČKA</dt>
                              <dt>( n - )</dt>
                              <dd>Připraví do výstupního řetězce znaménko minus, pokud je vrchol zásobníku záporný.</dd>
                              <dt>#&gt;</dt>
                              <dt>( ud - addr len )</dt>
                              <dd>Ukončí převod čísla tak, že na zásobníku ponechá adresu a délku řetězce (to jsou příslušné argumenty pro TYPE).</dd>
                              <dt>D.</dt>.
                              <dt>( d - )</dt>
                              <dd>Vytiskne číslo se znaménkem dvojnásobné délky d, za kterým následuje jedna mezera.</dd>
                              <dt>D.R</dt>
                              <dt>( d u - )</dt>
                              <dd>Vytiskne podepsané dvojciferné číslo d, zarovnané doprava v rámci šířky pole u.</dd>
                              <dt>D+</dt>
                              <dt>( d1 d2 - d3 )</dt>
                              <dd>Složí dvě dvojciferná čísla d1 a d2 a vrátí součet d3</dd>.
                              <dt>D-</dt>
                              <dt>( d1 d2 - d3 )</dt>
                              <dd>Odčítá dvojciferné číslo d2 od d1 a vrací rozdíl d3.</dd>
                              <dt>DNEGATE</dt>
                              <dt>( d1 - d2 )</dt>
                              <dd>Změní znaménko dvojciferného čísla.</dd>
                              <dt>DMAX</dt>
                              <dt>( d1 d2 - d3 )</dt>.
                              <dd>Vrátí maximum dvou dvojciferných čísel.</dd>
                              <dt>DMIN</dt>
                              <dt>( d1 d2 - d3 )</dt>
                              <dd>Vrátí minimum dvou čísel dvojí délky.</dd>
                              <dt>D=</dt>
                              <dt>( d1 d2 - flag )</dt>
                              <dd>Vrátí true, pokud se d1 a d2 rovnají.</dd>
                              <dt>D0=</dt>
                              <dt></dt>
                              <dd>Vrátí true, pokud je d rovno nule.</dd>
                              <dt>D&lt;</dt>
                              <dt>( d1 d2 - flag )</dt>
                              <dd>Vrací true, pokud je d1 menší než d2. Obě čísla mají znaménko.</dd>
                              <dt>DU&lt;</dt>
                              <dt>( ud1 ud2 - flag )</dt>
                              <dd>Vrátí true, pokud je ud1 menší než ud2. Obě čísla jsou bez znaménka.</dd>
                              <dt>M+</dt>
                              <dt>( d1 n - d2 )</dt>
                              <dd>Přičte dvojnásobně dlouhé číslo d1 k jednonásobně dlouhému číslu n. Vrátí dvojnásobně dlouhý výsledek d2.</dd>
                              <dt>SM/REM</dt>
                              <dt>( d n1 - n2 n3 )</dt>
                              <dd>Dělí d1 číslem n1, čímž získá symetrický kvocient n3 a zbytek n2. Vstupní a výstupní argumenty zásobníku jsou se znaménkem. Nejednoznačná podmínka existuje, pokud je n1 nula nebo pokud kvocient leží mimo rozsah jednočíselného znaménkového čísla.</dd>
                              <dt>FM/MOD</dt>
                              <dt>( d n1 - n2 n3 )</dt>
                              <dd>Dělíme d1 číslem n1, čímž získáme plovoucí kvocient n3 a zbytek n2. Vstupní a výstupní argumenty zásobníku jsou se znaménkem. Nejednoznačná podmínka existuje, pokud je n1 nula nebo pokud kvocient leží mimo rozsah jednočíselného čísla se znaménkem.</dd>
                              <dt>M*</dt>
                              <dt>( n1 n2 - d )</dt>
                              <dd>Násobí dvě jednočíslí o jedné délce. Vrací dvojnásobně dlouhý výsledek. Všechny hodnoty jsou se znaménkem.</dd>
                              <dt>M*/</dt>
                              <dt> d1 +n1 n2 - d2 )</dt>
                              <dd>Násobí dvojnásobně dlouhé číslo d1 jednovýkonným kladným číslem n1 a trojnásobně dlouhý výsledek vydělí jednovýkonným číslem n2. Vrátí dvojnásobně dlouhý výsledek d2. Všechny hodnoty jsou se znaménkem.</dd>
                           </dl>
                           <h3 id="h-review-of-terms"><span id="Review_of_Terms">Přehled termínů</span></h5>
                           <dl>
                              <dt>Aritmetický posun doleva a doprava</dt>
                              <dd>proces posunu všech bitů čísla, kromě znaménkového bitu, doleva nebo doprava, čímž se číslo (předpokládané se znaménkem) v důsledku zdvojnásobí, resp. zmenší na polovinu </dd>.
                              <dt>Logický posun doleva a doprava</dt>
                              <dd>proces posunu všech bitů čísla, včetně znaménkového bitu, doleva nebo doprava, čímž se (předpokládané nesignované) číslo zdvojnásobí, resp. zmenší na polovinu.</dd>
                              <dt>ASCII</dt>
                              <dd>standardizovaný systém reprezentace vstupních/výstupních znaků jako hodnot bajtů. Zkratka pro American Standard Code for Information Interchange (Americký standardní kód pro výměnu informací). (Vyslovuje se <em>ask-key</em>)</dd>.
                              <dt>Binární</dt>
                              <dd>číselný základ 2.</dd>
                              <dt>Bajt</dt>
                              <dd>standardní výraz pro 8bitovou hodnotu.</dd>
                              <dt>Buňka</dt>
                              <dd>formulářový termín pro jednobuněčnou hodnotu.</dd>
                              <dt>Decimální</dt>
                              <dd>číslo o základu 10.</dd>
                              <dt>Hexadecimální</dt>
                              <dd>číselný základ 16.</dd>.
                              <dt>Literární</dt>
                              <dd>obecně číslo symbolu, které reprezentuje pouze samo sebe; ve Forthu číslo, které se vyskytuje uvnitř definice.</dd>
                              <dt>Maska</dt>
                              <dd>hodnota, kterou lze " překrýt" přes jinou hodnotu, čímž se skryjí určité bity a odhalí se pouze ty bity, které nás zajímají.</dd>
                              <dt>Formátování čísel</dt>
                              <dd>proces vypisování čísla, obvykle ve speciálním tvaru, například 3/13/03 nebo $47,93.</dd>
                              <dt>Oktál</dt>
                              <dd>číselný základ 8.</dd>.
                              <dt>Značkový bit vysokého řádu</dt>
                              <dd>bit, který u čísla se znaménkem udává, zda je kladné nebo záporné, a u čísla bez znaménka představuje bit s nejvyšší velikostí.</dd>
                              <dt>Dvojkový doplněk</dt>
                              <dd>pro libovolné číslo číslo se stejnou absolutní hodnotou, ale opačným znaménkem. Pro výpočet 10 - 4 počítač nejprve vytvoří dvojkový doplněk čísla 4, (tj. -4), a poté vypočítá 10 + (-4).</dd>
                              <dt>Číslo bez znaménka</dt>
                              <dd>číslo, u kterého se předpokládá, že je kladné.</dd>
                              <dt>Neznačené číslo o jedné délce</dt>
                              <dd>celé číslo, které spadá do intervalu 0 až 2147483647.</dd>
                              <dt>Slovo</dt>
                              <dd>V jazyce Forth definovaná položka slovníku, jinde výraz pro 16bitovou hodnotu.</dd>
                              <dt>Dělení celými čísly</dt>
                              <dd>produkuje kvocient q a zbytek r dělením operandu a operandem b. Operace dělení vrací q, r nebo obojí. Pro všechna a a b platí identita b*q + r = a.</dd>
                              <dt>Podrobné dělení</dt>
                              <dd>je celočíselné dělení, při kterém zbytek nese znaménko dělitele nebo je nulový a kvocient se zaokrouhluje na aritmetickou dolní mez.</dd>
                              <dt>Symetrické dělení</dt>
                              <dd>je celočíselné dělení, při kterém zbytek nese znaménko dividendy nebo je roven nule a kvocient je matematický kvocient "zaokrouhlený k nule" nebo "zkrácený".</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="aligncenter"><img loading="lazy" width="230" height="100" src="./07-Signed and Double-Length Numbers_files/felix.gif" alt="Programovací jazyk Forth - příklady" class="wp-image-353"></figure>
                           </div>
                           <h3 id="h-problems-chapter-7"><span id="Problems_Chapter_7">Problémy - kapitola 7</span></h5>
                           <ol class="sf-numbered">
                              <li>
                                 Veronika Wainwrightová si nemohla vzpomenout na horní mez pro číslo se znaménkem o jedné délce a neměla k dispozici žádnou knihu, pouze terminál jazyka Forth. Napsala tedy definici nazvanou N-MAX, v níž použila cyklus BEGIN... UNTIL. Když ji provedla, dostala
                                 <pre>↵<span class="output">2147483647 ok </span></pre>
                                 <p>Jaká byla její definice?</p>
                              </li>
                              <li>
                                 Protože nyní víte, že AND a OR využívají bitovou logiku, vysvětlete, proč se v následujícím příkladu musí použít OR místo +:
                                 <pre>: MATCH vtipný citlivý AND umění milující hudbu milující NEBO AN kouřící 0= AND IF ." Mám někoho, s kým by ses měl seznámit " TED ;</pre>
                              </li>
                              <li>Napište definici, která třikrát "zazvoní" na zvonek vašeho terminálu. Ujistěte se, že mezi jednotlivými zvoněními je dostatečná prodleva, aby byla rozlišitelná. Pokaždé, když zvonek zazvoní, mělo by se na obrazovce terminálu objevit slovo "BEEP".</li>
                              <li>Napište znovu definice převodu teplot, které jste vytvořili pro úlohy v kap. 5. Tentokrát předpokládejte, že vstupní a výsledné teploty mají být celá čísla se znaménkem o dvojnásobné délce, která jsou škálována (tj. násobena) deseti. Pokud je například zadáno 10,5 stupně, jedná se o 32bitové celé číslo s hodnotou 105,</li>.
                              <li>
                                 Zapište formátované výstupní slovo s názvem .DEG, které zobrazí celé číslo se znaménkem o dvojnásobné délce škálované deseti jako řetězec číslic, desetinnou tečku a jednu zlomkovou číslici. Například:
                                 <pre>12.3 .DEG↵<span class="output">12.3 ok </span></pre>
                              </li>
                              <li>Řešte následující převody:<br>0,0° F ve stupních Celsia<br>212,0° F ve stupních Celsia<br>20,0° F ve stupních Celsia<br>16,0° C ve stupních Fahrenheita<br>-40,0° C ve stupních Fahrenheita<br>100,0° K ve stupních Celsia<br>100,0° K ve stupních Fahrenheita<br>233,0° K ve stupních Celsia<br>233,0° K ve stupních Fahrenheita</li>.
                              <li>Napsat rutinu, která vyhodnotí kvadratickou rovnici 7x<sup>2</sup> + 20x + 5 zadanou x a vrátí výsledek o dvojnásobné délce.</li>
                              <li>
                                 Napište slovo .BASES, které vypíše čísla 0 až 16 (v desítkové soustavě) v desítkové, šestnáctkové a dvojkové soustavě ve třech sloupcích. Např,
                                 <pre>DECIMAL 0 HEX 0 BINARY 0DECIMAL 1 HEX 1 BINARY 1DECIMAL 2 HEX 2 BINARY 10...DECIMAL 16 HEX 10 BINARY 10000</pre>
                              </li>
                              <li>
                                 Pokud zadáte<code>..↵</code>
                                 <p>(dvě tečky neoddělené mezerou) a systém odpoví "ok", co vám to říká?</p>
                              </li>
                              <li>
                                 Napište definici slova pro formátování telefonního čísla, které vypíše také směrové číslo s lomítkem <em>pouze a jen tehdy, když</em> číslo obsahuje směrové číslo. Např,
                                 <pre>555-1234 .PH# 555-1234↵<span class="output">ok </span>310/999-6784 .PH#↵<span class="output">310/999-6784 ok </span></pre>
                              </li>
                           </ol>
                           <div class="wp-block-genesis-blocks-gb-accordion gb-font-size-18 gb-block-accordion">
                              <details>
                                 <summary class="gb-accordion-title">Odpovědi</summary>
                                 <div class="gb-accordion-text">
                                    <ol>
                                       <li>
                                          <pre>: N-MAX ( -- n ) 0 BEGIN 1+ DUP 0&lt; UNTIL 1- ;
\ To může na 32bitovém systému trvat velmi dlouho.
</pre>
                                       </li>
                                       <li>Použitím + získáme aritmetický součet příznaků, zatímco OR provede logické bitové nebo.</li>
                                       <li>
                                          <pre>: MS ( u -- ) DROP ; \ pokud váš systém nemá MS
: BEEP ." BEEP " 7 EMIT ; \ není ANS, ale funguje na mnoha systémech
: DELAY 500 MS ;
: VYZVÁNĚNÍ PÍPNUTÍ ZPOŽDĚNÍ PÍPNUTÍ ZPOŽDĚNÍ PÍPNUTÍ ;
</pre>
                                       </li>
                                       <li>
                                          <pre>: F&gt;C ( d1 -- d2 ) -320 M+ 10 18 M*/ ;
: C&gt;F ( d1 -- d2 ) 18 10 M*/ 320 M+ ;
: C&gt;K ( d1 -- d2 ) 2732 M+ ;
: K&gt;C ( d1 -- d2 ) -2732 M+ ;
: F&gt;K ( d1 -- d2 ) F&gt;C C&gt;K ;
: K&gt;F ( d1 -- d2 ) K&gt;C C&gt;F ;
</pre>
                                       </li>
                                       <li>
                                          <pre>: .DEG ( d -- ) TUCK DABS
   &lt;# # [CHAR] . HOLD #S ROT SIGN #&gt; TYPE SPACE ;
</pre>
                                       </li>
                                       <li>
                                          <pre>0.0 F&gt;C .DEG↵<span class="output">-17.7 ok </span>
212.0 F&gt;C .DEG↵<span class="output">100.0 ok </span>
20,0 F&gt;C .DEG↵<span class="output">-6,6 ok </span>
16,0 C&gt;F .DEG↵<span class="output">60,8 ok </span>
-40,0 C&gt;F .DEG↵<span class="output">-40,0 ok </span>
100,0 K&gt;C .DEG↵<span class="output">-173,2 ok </span>
100,0 K&gt;F .DEG↵<span class="output">-279,7 ok </span>
233,0 K&gt;C .DEG↵<span class="output">-40,2 ok </span>
233,0 K&gt;F .DEG↵<span class="output">-40,3 ok </span>
</pre>
                                       </li>
                                       <li>
                                          <pre>: POLY ( x -- d ) DUP 7 * 20 + M* 5 M+ ;
</pre>
                                       </li>
                                       <li>
                                          <pre>: BINARY 2 BASE ! ;
: .BASES ( -- )
   17 0 DO CR ." decimal" DECIMAL I 4 U.R 8 SPACES
                ." hex " HEX I 3 U.R 8 SPACES
                ." binární" BINARY I 8 U.R 8 SPACES
   LOOP DECIMAL ;
</pre>
                                       </li>
                                       <li>Říká, že se jedná o systém Forth, který interpretuje libovolný počet desetinných míst jako dvojnásobné specifikátory.</li>
                                       <li>
                                          <pre>: .PH# ( d -- ) &lt;# # # # # [CHAR] - HOLD # # #
   OVER IF [CHAR] / HOLD #S THEN #&gt; TYPE SPACE ;
</pre>
                                       </li>
                                    </ol>
                                 </div>
                              </details>
                           </div>
                        </div>
                     </div>
                  </article>
               </main>
            </div>
         </div>
      </div>
      <div class="site grid-container container hfeed grid-parent" id="page">
         <div class="site-content" id="content">
            <div class="content-area grid-parent mobile-grid-100 grid-70 tablet-grid-70" id="primary">
               <main class="site-main" id="main">
                  <article id="post-332" class="post-332 page type-page status-publish" itemtype="https://schema.org/CreativeWork" itemscope="">
                     <div class="inside-article">
                        <header class="entry-header" aria-label="Content">
                           <h2 class="entry-title" itemprop="headline">8. Proměnné, konstanty a pole</h2>
                        </header>
                        <div class="entry-content" itemprop="text">
                           <p>Jak jsme viděli v předchozích sedmi kapitolách, programátoři jazyka Forth používají zásobník k dočasnému ukládání čísel při provádění výpočtů nebo k předávání argumentů z jednoho slova do druhého. Když programátoři potřebují čísla uchovávat trvaleji, používají proměnné a konstanty.</p>
                           <p>V této kapitole se dozvíme, jak jazyk Forth zachází s proměnnými a konstantami, a přitom si ukážeme, jak přímo přistupovat k místům v paměti.</p>
                           <h3><span id="Proměnné">Proměnné</span></h3>
                           <p>Začněme příkladem situace, kdy byste chtěli použít proměnnou - k uložení denního data. Nejprve vytvoříme proměnnou s názvem DATE. Uděláme to tak, že řekneme</p>
                           <pre class="wp-block-preformatted">Proměnná DATE

</pre>
                           <p>Pokud je dnes dvanáctého, řekneme nyní</p>
                           <pre class="wp-block-preformatted">12 DATE !

</pre>
                           <p>To znamená, že na zásobník vložíme dvanáctku, pak uvedeme jméno proměnné a nakonec vykonáme slovo !, které se vyslovuje <em>sklad</em>. Tato věta uloží číslo dvanáct do proměnné DATE.</p>
                           <p>Obráceně můžeme říci</p>
                           <pre class="wp-block-preformatted">DATE @

</pre>
                           <p>to znamená, že můžeme proměnnou pojmenovat a pak provést slovo @, které se vyslovuje <em>převzít</em>. Tato věta načte dvanáctku a vloží ji na zásobník. Tedy věta</p>
                           <pre class="wp-block-preformatted">DATE @ .↵<span class="output">12 ok </span>

</pre>
                           <p>vypíše datum.</p>
                           <p>Aby to bylo ještě jednodušší, existuje slovo Forth, jehož definice zní takto:</p>
                           <pre class="wp-block-preformatted">: ?   @ . ;

</pre>
                           <p>Místo "DATE-fetch-dot" tedy můžeme jednoduše napsat</p>
                           <pre class="wp-block-preformatted">DATE ?↵<span class="output">12 ok </span>

</pre>
                           <p>Hodnota DATE bude dvanáct, dokud ji nezměníme. Chceme-li ji změnit, jednoduše uložíme nové číslo</p>
                           <pre class="wp-block-preformatted">13 DATE !↵<span class="output">ok </span>
DATE ?↵<span class="output">13 ok </span>

</pre>
                           <p>Možná bychom mohli definovat další proměnné pro měsíc a rok:</p>
                           <pre class="wp-block-preformatted">VARIABLE DATE VARIABLE MONTH VARIABLE YEAR

</pre>
                           <p>poté definujte slovo !DATE (pro "store-the-date") takto:</p>
                           <pre class="wp-block-preformatted">: !DATE YEAR !  DATE !  MĚSÍC !

</pre>
                           <p>používá se takto:</p>
                           <pre class="wp-block-preformatted">7 31 03 !DATE↵<span class="output">ok </span>

</pre>
                           <p>poté definujte slovo .DATE (pro "print-the-date") takto:</p>
                           <pre class="wp-block-preformatted">: .DATE MONTH ?  DATE ?  ROK ?

</pre>
                           <p>Váš systém Forth již má definováno několik proměnných; jedna z nich se nazývá BASE. BASE obsahuje číselný základ, ve kterém právě pracujete. Ve skutečnosti jsou definice HEX a DECIMAL (a OCTAL, pokud je váš systém má) jednoduše</p>
                           <pre class="wp-block-preformatted">: DECIMAL 10 BASE ! ;<br>: HEX 16 BASE ! ;<br>: OCTAL 8 BASE ! ;</pre>
                           <p>Jednoduchým uložením do BASE můžete pracovat s libovolným základem čísla.</p>
                           <h3><span id="Pro_odborníky">Pro odborníky</span></h5>
                           <p>Třípísmenný kód, například název letištního terminálu, lze uložit jako jednočíslí bez znaménka v základu 36. Například:</p>
                           <pre class="wp-block-preformatted">: ALPHA 36 BASE ! ;↵ok <br>ALPHA↵ok <br>ZAP U.↵ZAP ok </pre>
                           <p>Někde v definicích systémových slov, která provádějí převody vstupních a výstupních čísel, najdete větu</p>
                           <pre class="wp-block-preformatted">BASE @

</pre>
                           <p>protože při převodu se používá aktuální hodnota BASE. Jediná rutina tedy může převádět čísla v <em>jakémkoli základu</em>. To nás vede k formálnímu prohlášení o použití proměnných:</p>
                           <h3><span id="A_Closer_Look_at_Variables">Blíže k proměnným</span></h5>
                           <p>V jazyce Forth jsou proměnné vhodné pro jakoukoli hodnotu, která se používá uvnitř definice a kterou může být potřeba kdykoli změnit poté, co již byla definice zkompilována.</p>
                           <p>Když vytvoříte proměnnou, například DATE, pomocí věty</p>
                           <pre class="wp-block-preformatted">Proměnná DATE

</pre>
                           <p>ve skutečnosti do slovníku zakompilujete nové slovo s názvem DATE. Zjednodušené zobrazení by vypadalo jako zobrazení níže.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img width="254" height="87" src="./08-Proměnné, konstanty a pole_files/ch8-Forth-dictionary-entry-variable-1.gif" alt="Definice hodnoty proměnné sestavené ve slovníku Forth" class="wp-image-466"></figure>
                           </div>
                           <p>DATE je jako každé jiné slovo ve vašem slovníku s tím rozdílem, že jste ho definovali pomocí slova VARIABLE místo slova :. V důsledku toho jste nemuseli definovat, co má vaše definice <em>dělat</em>, slovo VARIABLE samo o sobě říká, co se má stát. A tady <em>je</em> to, co se stane:</p>
                           <p>Když řeknete</p>
                           <pre class="wp-block-preformatted">12 DAT !

</pre>
                           <p>Dvanáctka se dostane na zásobník, načež interpret textu vyhledá ve slovníku DATE, a když ho najde, ukáže na něj EXECUTE.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="127" src="./08-Variables, Constants and Arrays_files/ch8-stack-variables-1.gif" alt="Proměnné jazyka Forth ukládají hodnotu na adresu v paměti" class="wp-image-467"></figure>
                           <p>EXECUTE vykoná proměnnou zkopírováním adresy "prázdné" buňky proměnné (kam se hodnota dostane) na zásobník.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="300" height="120" src="./08-Variables, Constants and Arrays_files/ch8-stack-variables-2.gif" alt="adresa dat proměnné&#39;přejde na zásobník dat" class="wp-image-469"></figure>
                           <p>Slovo ! vezme adresu (nahoře) a hodnotu (dole) a uloží ji na toto místo. Číslo, které se na této adrese nacházelo, se nahradí novým číslem.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="135" src="./08-Variables, Constants and Arrays_files/ch8-stack-variables-3.gif" alt="Operátor store (!) vezme hodnotu a adresu proměnné&#39;ze zásobníku." class="wp-image-470"></figure>
                           <p>(Chcete-li si zapamatovat, v jakém pořadí argumenty patří, představte si, že si položíte balíček a pak na něj nalepíte štítek s adresou)</p>.
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="141" src="./08-Variables, Constants and Arrays_files/ch8-stack-variables-4.gif" alt="Operátor fetch (@) získá hodnotu z adresy proměnné&#39;v paměti." class="wp-image-471"></figure>
                           <p>Slovo @ očekává pouze jeden argument: adresu, která je v tomto případě zadána názvem proměnné, jako v</p>
                           <pre class="wp-block-preformatted">DATE @

</pre>
                           <p>Při použití hodnoty na zásobníku jako adresy slovo @ přesune obsah tohoto místa na zásobník, čímž "vypustí" adresu. (Obsah umístění zůstane nedotčen.)</p>
                           <h3><span id="Použití_proměnné_jako_počítače">Použití proměnné jako počítadla</span></h5>
                           <p>V jazyce Forth je proměnná ideální k tomu, abyste mohli něco počítat. Abychom znovu použili náš příklad s balírnou vajec, mohli bychom sledovat, kolik vajec sjede po dopravním pásu za jeden den. (Tento příklad bude fungovat i na vašem terminálu, takže ho zadejte, jak budeme postupovat) </p>.
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="200" height="100" src="./08-Variables, Constants and Arrays_files/ch8-counter-variable.gif" alt="použití proměnné k uchování hodnoty počítání něčeho" class="wp-image-472"></figure>
                           </div>
                           <p>Nejprve můžeme definovat</p>
                           <pre class="wp-block-preformatted">Proměnná EGGS

</pre>
                           <p>aby bylo možné udržovat počet v. Abychom každé ráno začali s čistým štítem, mohli bychom do EGGS uložit nulu tak, že provedeme slovo, jehož definice vypadá takto:</p>
                           <pre class="wp-block-preformatted">: VYNULOVAT 0 VAJEC ! ;

</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="439" src="./08-Variables, Constants and Arrays_files/ch8-pronounce-1.gif" alt="zvýšení hodnoty proměnné&#39;o jedničku" class="wp-image-473"></figure>
                           </div>
                           <p>Pak bychom někde v naší aplikaci pro balení vajec definovali slovo, které provede následující větu pokaždé, když vejce projde kolem elektrického oka na dopravníku:</p>
                           <pre class="wp-block-preformatted">1 EGGS +!

</pre>
                           <p>Slovo +! přidá danou hodnotu k obsahu dané adresy. (Neobtěžuje se sdělit, co je to za obsah.) Tedy věta</p>
                           <pre class="wp-block-preformatted">1 EGGS +!

</pre>
                           <p>zvýší počet vajec o jedničku. Pro ilustraci vložme tuto frázi do definice takto:</p>
                           <pre class="wp-block-preformatted">: EGG 1 EGGS +! ;

</pre>
                           <p>Nakonec bychom řekli</p>
                           <pre class="wp-block-preformatted">EGGS ?

</pre>
                           <p> abychom zjistili, kolik vajec od rána ubylo.</p>
                           <p>Zkusíme to:</p>
                           <pre class="wp-block-preformatted">RESET↵<span class="output">ok </span>
EGG↵<span class="output">ok </span>
EGG↵<span class="output">ok </span>
EGG↵<span class="output">ok </span>
EGGS ?↵<span class="output">3 ok </span>

</pre>
                           <p>Tady je seznam slov, která jsme dosud probrali:</p>
                           <dl class="forth">
                              <dt>VARIABLE xxx</dt>
                              <dt>( - ) xxx: ( - addr )</dt>
                              <dd>Vytvoří proměnnou s názvem xxx; slovo xxx po provedení vrátí její adresu </dd>.
                              <dt>!</dt>
                              <dt>( n addr - )</dt>
                              <dd>Uloží do adresy číslo o jedné délce.</dd>
                              <dt>@</dt>
                              <dt>( addr - n )</dt>
                              <dd>Vybere tuto hodnotu na adrese addr.</dd>
                              <dt>?</dt>
                              <dt>( addr - )</dt>
                              <dd>Vytiskne obsah adresy následovaný jednou mezerou.</dd>
                              <dt>+!</dt>
                              <dt>( n addr - )</dt>
                              <dd>Přidá k obsahu adresy číslo o jedné délce.</dd>
                           </dl>
                           <h3><span id="Konstanty">Konstanty</span></h3>
                           <p> Zatímco proměnné se obvykle používají pro hodnoty, které se mohou měnit, konstanty se používají pro hodnoty, které se <em>nebudou měnit</em>. Ve Forthu vytvoříme konstantu a zároveň nastavíme její hodnotu takto:</p>
                           <pre class="wp-block-preformatted">220 KONSTANTA LIMIT

</pre>
                           <p>Zde jsme definovali konstantu s názvem LIMIT a přiřadili jí hodnotu 220. Nyní můžeme místo hodnoty použít slovo LIMIT, například takto:</p>
                           <pre class="wp-block-preformatted">: ?TOO-HOT LIMIT &gt; IF ." Nebezpečí -- snížit teplotu " THEN ;

</pre>
                           <p>Pokud je číslo na zásobníku větší než 220, vypíše se varovná zpráva.</p>
                           <p>Všimněte si, že když řekneme</p>
                           <pre class="wp-block-preformatted">LIMIT

</pre>
                           <p>získáme <em>hodnotu</em>, nikoli adresu. Nepotřebujeme "fetch."</p>
                           <p>Toto je důležitý rozdíl mezi proměnnými a konstantami. Důvodem rozdílu je to, že u proměnných potřebujeme adresu, abychom měli možnost načítat nebo ukládat. U konstant chceme vždy hodnotu; rozhodně nikdy neukládáme.</p>
                           <p>Jedním z použití konstant je pojmenování hardwarové adresy. Například aplikace přenosné kamery řízené mikroprocesorem může obsahovat tuto definici:</p>
                           <pre class="wp-block-preformatted">: FOTOGRAFIE ČAS OTEVŘENÍ ZÁVĚRKY VYSTAVIT ZAVŘENÍ ZÁVĚRKY ;

</pre>
                           <p>Zde bylo slovo SHUTTER definováno jako konstanta, takže provedení příkazu SHUTTER vrátí hardwarovou adresu závěrky fotoaparátu. Mohlo by být například definováno takto:</p>
                           <pre class="wp-block-preformatted">HEX<br>FFFF3E27 CONSTANT SHUTTER<br>DECIMAL</pre>
                           <p>Slova OTEVŘÍT a ZAVŘÍT lze definovat jednoduše takto</p>
                           <pre class="wp-block-preformatted">: OTEVŘÍT 1 SWAP ! ;<br>: CLOSE 0 SWAP ! ;</pre>
                           <p>tak, aby věta</p>
                           <pre class="wp-block-preformatted">ZAVŘÍT OTEVŘÍT

</pre>
                           <p> zapíše na adresu závěrky hodnotu "1", čímž způsobí otevření závěrky.</p>
                           <p>Tady jsou některé situace, kdy je dobré definovat čísla jako konstanty:</p>
                           <ol>
                              <li>Kdy je důležité, aby byla vaše aplikace čitelnější. Jedním z prvků stylu jazyka Forth je, že definice by měly být samodokumentující, jako je tomu u výše uvedené definice FOTOGRAFIE.</li>
                              <li>Když je pohodlnější použít jméno místo čísla. Pokud si například myslíte, že budete muset změnit hodnotu (protože se například může změnit hardware), budete muset změnit hodnotu <em>jen jednou</em> - v souboru, kde je konstanta definována - a pak aplikaci překompilovat.</li>
                              <li>(platí pouze pro méně sofistikované překladače jazyka Forth) Pokud ve své aplikaci používáte stejnou hodnotu vícekrát. V zkompilované podobě definice vyžaduje odkaz na konstantu méně místa v paměti.</li>
                           </ol>
                           <dl class="forth">
                              <dt>CONSTANT xxx</dt>
                              <dt>( n - ) xxx: ( - n )</dt>
                              <dd>Vytvoří proměnnou s názvem xxx s hodnotou n; slovo xxx po provedení vrací n.</dd>
                           </dl>
                           <h3><span id="Double-Length_Variables_and_Constants">Proměnné a konstanty dvojí délky</span></h3>
                           <p>Proměnnou dvojí délky můžete definovat pomocí slova 2VARIABLE. Například,</p>
                           <pre class="wp-block-preformatted">2VARIABLE DATE

</pre>
                           <p>Nyní můžete použít forthovská slova 2! (vyslovuje se two-store) a 2@ (vyslovuje se two-fetch) pro přístup k této proměnné o dvojnásobné délce. Můžete do ní uložit dvojnásobně dlouhé číslo jednoduše vyslovením</p>
                           <pre class="wp-block-preformatted">800 000 DAT 2!

</pre>
                           <p>a zpětně ji načíst pomocí</p>
                           <pre class="wp-block-preformatted">DATUM 2@ D.↵<span class="output">800000 ok </span>

</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="513" src="./08-Variables, Constants and Arrays_files/ch8-pronounce-2.gif" alt="Dvojité proměnné a konstanty: 2VARIABLE, 2CONSTANT, 2@ a 2! double operators" class="wp-image-475"></figure>
                           </div>
                           <p>Nebo do ní můžete uložit celý měsíc/datum/rok, například takto:</p>
                           <pre class="wp-block-preformatted">7/17/03 DATUM 2!

</pre>
                           <p>a zpětně jej načíst pomocí</p>
                           <pre class="wp-block-preformatted">DATE 2@ .DATE↵<span class="output">7/17/03 ok </span>

</pre>
                           <p>Předpokládáme, že jste načetli verzi .DATE, kterou jsme uvedli v minulé kapitole.</p>
                           <p> Konstantu dvojí délky můžete definovat pomocí forthovského slova 2CONSTANT, například takto:</p>
                           <pre class="wp-block-preformatted">200 000 2CONSTANT APPLES

</pre>
                           <p>Nyní slovo APPLES umístí na zásobník číslo dvojnásobné délky.</p>
                           <pre class="wp-block-preformatted">APPLES D.↵<span class="output">200000 ok </span>

</pre>
                           <p>Můžeme samozřejmě udělat:</p>
                           <pre class="wp-block-preformatted">400 000 2CONSTANT MUCH
: MNOHEM-VÍCE 200 000 D+ MNOHEM D+ ;

</pre>
                           <p>aby bylo možné říci</p>
                           <pre class="wp-block-preformatted">APPLES MUCH-MORE D.↵<span class="output">800000 ok </span>

</pre>
                           <p>Jak nám připomíná předpona "2", můžeme také použít 2CONSTANT k definování dvojice čísel o jedné délce. Důvodem pro uvedení dvou čísel pod stejným jménem je pohodlnost a úspora místa ve slovníku.</p>
                           <p>Jako příklad si připomeňme (z <a href="https://www.forth.com/starting-forth/5-fixed-point-arithmetic/">kap. 5</a>), že můžeme použít větu</p>
                           <pre class="wp-block-preformatted">355 113 */

</pre>
                           <p>pro vynásobení čísla hrubou aproximací čísla π. Tato dvě celá čísla bychom mohli uložit jako 2CONSTANT takto:</p>
                           <pre class="wp-block-preformatted">355 113 2CONSTANT PI

</pre>
                           <p>tedy jednoduše použijeme větu</p>
                           <pre class="wp-block-preformatted">PI */

</pre>
                           <p>jako v</p>
                           <pre class="wp-block-preformatted">10000 PI */ .↵<span class="output">31415 ok </span>

</pre>
                           <p>Tady je přehled slov s dvojí délkou datové struktury:</p>
                           <dl class="forth">
                              <dt>2VARIABLE XXX</dt>
                              <dt>( - ) xxx: ( - addr )</dt>
                              <dd>Vytvoří dvouhodnotovou proměnnou s názvem xxx; slovo xxx po provedení vrátí její adresu </dd>.
                              <dt>2CONSTANT XXX</dt>
                              <dt>( d - ) xxx: ( - d )</dt>
                              <dd>Vytvoří dvojnásobně dlouhou konstantu s názvem xxx s hodnotou d; slovo xxx při provedení vrátí d.</dd>
                              <dt>2!</dt>
                              <dt>( d addr - ) nebo ( n1 n2 addr - )</dt>
                              <dd>Uloží číslo dvojnásobné délky (nebo dvojici čísel jedné délky) na adresu addr.</dd>
                              <dt>2@</dt>
                              <dt>( addr - d ) nebo ( addr - n1 n2 )</dt>
                              <dd>Vybere číslo o dvojnásobné délce (nebo dvojici čísel o jedné délce) z adresy addr.</dd>
                           </dl>
                           <h3><span id="Pole">Pole</span></h3>
                           <p>Jak víte, výraz</p>
                           <pre class="wp-block-preformatted">Proměnná DATA

</pre>
                           <p>vytváří definici, která koncepčně vypadá takto:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>4 D A T E</td>
                                    <td>kód</td>
                                    <td>Místo pro jednu buňku</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Nyní, když řeknete</p>
                           <pre class="wp-block-preformatted">1 CELLS ALLOT

</pre>
                           <p>v definici se přidělí další buňka takto:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>4 D A T E</td>
                                    <td>kód</td>
                                    <td>Místo pro první buňku</td>
                                    <td>Místo pro druhou buňku</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Výsledek je stejný, jako kdybyste použili 2VARIABLE. Změnou argumentu na ALLOT však můžete definovat <em>libovolný počet</em> proměnných pod stejným názvem. Takové skupině proměnných se říká "pole" </p>.
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="300" height="85" src="./08-Variables, Constants and Arrays_files/ch8-burners.gif" alt="ALLOT vytvoří pole více proměnných stejného jména" class="wp-image-478"></figure>
                           </div>
                           <p>Řekněme například, že v naší laboratoři máme ne jeden, ale <em>pět</em> hořáků, které ohřívají různé druhy kapalin.</p>
                           <p>Můžeme naše slovo ?TOO-HOT kontrolovat, zda všech pět hořáků nepřekročilo svůj individuální limit, pokud definujeme LIMIT pomocí pole, nikoliv pomocí konstanty.</p>
                           <p>Pojmenujme pole LIMITY takto:</p>
                           <pre class="wp-block-preformatted">Proměnné LIMITY 4 BUNĚK VŠECHNY</pre>
                           <p>Výraz "4 CELLS ALLOT" dává poli čtyři buňky navíc (celkem pět buněk).</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>6LIMITS</td>
                                    <td>kód</td>
                                    <td>Burner0</td>
                                    <td>Palivo1</td>
                                    <td>Horák2</td>
                                    <td>Horák3</td>
                                    <td>Horák4</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>Předpokládejme, že chceme, aby limit pro hořák 0 byl 220. Tuto hodnotu můžeme uložit jednoduše tak, že řekneme</p>
                           <pre class="wp-block-preformatted">220 LIMITS !

</pre>
                           <p>protože LIMITS vrací adresu první buňky v poli. Předpokládejme, že chceme, aby limit pro vypalovačku 1 byl 340. Tuto hodnotu můžeme uložit tak, že k adrese původní buňky přičteme 1 CELLS, například takto:</p>
                           <pre class="wp-block-preformatted">340 LIMITS 1 CELLS + !

</pre>
                           <p>Můžeme uložit limity pro vypalovačky 2, 3 a 4 tak, že k původní adrese přidáme "posunutí" 2 CELLS, 3 CELLS a 4 CELLS. Můžeme definovat vhodné slovo</p>
                           <pre class="wp-block-preformatted">: LIMIT ( burner# -- addr ) CELLS LIMITS + ;

</pre>
                           <p>pro přijetí čísla vypalovače na zásobníku a výpočet adresy, která odráží příslušný offset.</p>
                           <p>Nyní, pokud chceme, aby hodnota 170 byla limitem pro hořák 2, jednoduše řekneme</p>
                           <pre class="wp-block-preformatted">170 2 LIMIT !

</pre>
                           <p>nebo podobně můžeme načíst limit pro hořák 2 pomocí věty</p>
                           <pre class="wp-block-preformatted">2 LIMIT ?↵<span class="output">170 ok </span>

</pre>
                           <p>Tato technika zvyšuje užitečnost slova LIMIT, takže můžeme nadefinovat ?TOO-HOT takto:</p>
                           <pre class="wp-block-preformatted">: ?TOO-HOT ( temp burner# -- ) LIMIT @ &gt; IF ." Nebezpečí -- snížit teplotu " THEN ;</pre>
                           <p>který funguje takto:</p>
                           <pre class="wp-block-preformatted">210 0 ?TOO-HOT↵<span class="output">ok </span><br>230 0 ?TOO-HOT↵<span class="output">Nebezpečí -- snížit teplo ok </span><br>300 1 ? TOO-HOT↵<span class="output">ok </span><br>350 1 ?TOO-HOT↵<span class="output">Nebezpečí -- snížit teplo ok </span></pre>
                           <p>atd.</p>
                           <h3><span id="Další_příklad_použití__množiny_pro_počítání">Další příklad - použití pole pro počítání</span></h3>
                           <p>Zpět na ranči s vejci:</p>
                           <p>Tady je další příklad použití pole. V tomto příkladu je každý prvek pole použit jako samostatné počítadlo. Můžeme tedy sledovat, kolik kartonů "extra velkých" vajec stroj zabalil, kolik "velkých" a tak dále.</p>
                           <p>Připomeňte si, že z předchozí definice EGGSIZE (v <a href="https://www.forth.com/starting-forth/4-conditional-if-then-statements/">kapitole 4</a>) jsme použili čtyři kategorie přijatelných vajec a dvě kategorie "špatných vajec" </p>.
                           <pre class="wp-block-preformatted">0 STEJNÉ NEVHODNÉ<br>1 STEJNÉ MALÉ<br>2 STEJNÉ STŘEDNÍ<br>3 STEJNÉ VELKÉ<br>4 STEJNÉ EXTRA VELKÉ<br>5 STEJNÉ CHYBNÉ</pre>
                           <p> Vytvořme tedy pole o délce šesti buněk:</p>
                           <pre class="wp-block-preformatted">VARIABLE COUNTS 5 CELLS ALLOT

</pre>
                           <p>Počty budeme inkrementovat pomocí slova +!, takže musíme být schopni nastavit všechny prvky pole na nulu, než začneme počítat. Výraz</p>
                           <pre class="wp-block-preformatted">CELKEM 6 BUNĚK 0 VYPLNĚNO

</pre>
                           <p>vyplní 6 buněk , počínaje adresou COUNTS, nulami. Pokud váš systém Forth obsahuje slovo ERASE, je lepší ho v této situaci použít. ERASE vyplní daný počet bajtů nulami. Použijte jej takto:</p>
                           <pre class="wp-block-preformatted">CELKEM 6 BUNĚK ERASE

</pre>
                           <dl class="forth">
                              <dt>VYPLNÍ</dt>
                              <dt>( addr n char - )</dt>
                              <dd>Naplní n bajtů paměti, počínaje adresou addr, hodnotou char.</dd>
                              <dt>ERASE</dt>
                              <dt>( addr n - )</dt>
                              <dd>Uloží nuly do n bajtů paměti, počínaje adresou addr.</dd>
                           </dl>
                           <p>Pro usnadnění můžeme tuto větu vložit dovnitř definice, například takto:</p>
                           <pre class="wp-block-preformatted">: RESET POČÍTÁ 6 BUNĚK VYMAZAT ;

</pre>
                           <p>Nyní definujme slovo, které nám poskytne adresu jednoho z počítadel v závislosti na čísle kategorie, které je mu přiděleno (0 až 5), takto:</p>
                           <pre class="wp-block-preformatted">: POČÍTADLO BUNĚK POČÍTÁ + ;

</pre>
                           <p>a další slovo, které přidá jedničku k počítadlu, jehož číslo je zadáno, takto:</p>
                           <pre class="wp-block-preformatted">: TALLY COUNTER 1 SWAP +! ;

</pre>
                           <p>"1" slouží jako přírůstek pro +! a SWAP seřadí argumenty pro +! v pořadí, v jakém k sobě patří, tedy ( n addr - ).</p>
                           <p>Nyní například věta</p>
                           <pre class="wp-block-preformatted">VELKÝ TALLY

</pre>
                           <p>bude inkrementovat čítač, který odpovídá velkým vejcím.</p>
                           <p>Nyní definujme slovo, které převede hmotnost na tucet na <abbr title="Brzy uvidíme jednodušší definici." onclick="alert(&#39;Brzy uvidíme jednodušší definici.&#39;);">číslo kategorie</abbr>:</p>
                           <pre class="wp-block-preformatted">: KATEGORIE ( váha -- kategorie )<br> DUP 18 &lt; IF REJECT ELSE<br> DUP 21 &lt; IF SMALL ELSE<br> DUP 24 &lt; IF MEDIUM ELSE<br> DUP 27 &lt; IF LARGE ELSE<br> DUP 30 &lt; IF EXTRA-LARGE ELSE<br> ERROR<br> THEN THEN THEN THEN NIP ;</pre>
                           <p>(Než se dostaneme k NIP, budeme mít na zásobníku dvě hodnoty: hmotnost, kterou jsme DUPovali, a číslo kategorie, které bude nahoře. Chceme pouze číslo kategorie; "NIP" eliminuje váhu.)</p>
                           <p>Například věta</p>
                           <pre class="wp-block-preformatted">25 KATEGORIE

</pre>
                           <p>zůstane na hromádce číslo 3 (VELKÁ). Výše uvedená definice CATEGORY se podobá naší staré definici EGGSIZE, ale ve stylu pravého Forthu, který se snaží udržet slova co nejkratší, jsme z definice odstranili výstupní zprávy. Místo toho budeme definovat další slovo, které očekává číslo kategorie a vypíše výstupní zprávu, takto:</p>
                           <pre class="wp-block-preformatted">: LABEL ( category -- )<br> CASE<br> REJECT OF ." reject " ENDOF<br> SMALL OF ." small " ENDOF<br> MEDIUM OF ." medium " ENDOF<br> LARGE OF ." large " ENDOF<br> EXTRA-LARGE OF ." extra large " ENDOF<br> ERROR OF ." error " ENDOF<br> ENDCASE ;</pre>
                           <p>Příklad:</p>
                           <pre class="wp-block-preformatted">MALÝ LABEL↵<span class="output">malý ok </span>

</pre>
                           <p>Nyní můžeme definovat EGGSIZE pomocí tří vlastních slov:</p>
                           <pre class="wp-block-preformatted">: EGGSIZE CATEGORY DUP LABEL TALLY ;

</pre>
                           <p>Takto vznikne věta</p>
                           <pre class="wp-block-preformatted">23 EGGSIZE

</pre>
                           <p>vypíše se</p>
                           <pre class="wp-block-preformatted"><span class="output">medium ok </span>

</pre>
                           <p>na terminálu a aktualizuje počítadlo pro střední vejce.</p>
                           <p>Jak budeme čítače odečítat na konci dne? Mohli bychom kontrolovat každou buňku v poli zvlášť pomocí věty, jako je</p>
                           <pre class="wp-block-preformatted">Počítač velkých vajec ?

</pre>
                           <p>(což by nám řeklo, kolik "velkých" kartonů bylo zabaleno). Ale pojďme být trochu fantasknější a definujme si vlastní slovo, které bude vypisovat tabulku denních výsledků v tomto formátu:</p>
                           <pre class="wp-block-preformatted"><span style="border-bottom:solid 1px #000;">VELIKOST KVANTITY</span><br> 1 vyřazeno<br> 112 malých<br> 132 středních<br> 143 velkých<br> 159 extra velkých<br> 0 chyb</pre>
                           <p>Protože jsme již vymysleli čísla kategorií, můžeme jednoduše použít DO a index na číslo kategorie, například takto:</p>
                           <pre class="wp-block-preformatted">: .": "REPORT ( -- ) PAGE .": "REPORT ( -- ) PAGE .": "REPORT ( -- ) PAGE ." QUANTITY SIZE" CR CR<br> 6 0 DO I COUNTER @ 5 U.R 7 SPACES I LABEL CR LOOP ;</pre>
                           <p>(Věta "I COUNTER @ 5 U.R" vezme číslo kategorie zadané I, indexuje do pole a vypíše obsah příslušného prvku v pětisloupcovém poli)</p>.
                           <h3><span id="Factoring_Definitions">Definice faktoringu</span></h3>
                           <p>Tady je vhodná chvíle pohovořit o faktoringu, jak se vztahuje k definicím jazyka Forth. Právě jsme viděli příklad, ve kterém nám faktoring zjednodušil problém.</p>
                           <p>Naše první definice EGGSIZE z <a href="https://www.forth.com/starting-forth/4-conditional-if-then-statements/">kapitoly 4</a>, kategorizovala vejce podle hmotnosti a na terminál vypisovala názvy kategorií. V naší současné verzi jsme "kategorizaci" a "vypisování" faktorovali do dvou samostatných slov. Slovo KATEGORIE můžeme použít jako argument buď pro slovo tisk, nebo pro slovo kontrétní třídění (nebo pro obě slova). A tiskařské slovo LABEL můžeme použít jak ve slově EGGSIZE, tak ve slově REPORT.</p>
                           <p>Jak napsal Charles Moore, vynálezce jazyka Forth:</p>
                           <blockquote class="wp-block-quote">
                              <p>Dobrý slovník jazyka Forth obsahuje velké množství malých slov. Nestačí rozdělit problém na malé kousky. Cílem je izolovat slova <em>která lze opakovaně použít</em>.</p>
                           </blockquote>
                           <p>Například v receptu:</p>
                           <div style="padding-left:2em; margin-bottom:2em;">
                              Vezměte si plechovku rajčatové omáčky.<br>
                              Otevřete plechovku rajčatové omáčky.<br>
                              Nalijte rajčatovou omáčku do pánve.<br>
                              Vezmi plechovku žampionů.<br>
                              Otevři plechovku s houbami.<br>
                              Nalij houby do pánve.
                           </div>
                           <p>Můžete "vyfakturovat" získání, otevření a vysypání, protože jsou společné pro obě konzervy. Pak můžete vyfakturovaný proces pojmenovat a jednoduše napsat:</p>
                           <pre class="wp-block-preformatted">TOMATOES ADD<br>MUSHROOMS ADD</pre>
                           <p>a každý kuchař, který absolvoval Postfixovou školu vaření, bude přesně vědět, co máte na mysli.</p>
                           <p>Faktorizace nejenže usnadňuje psaní programu (a jeho opravy!), ale také šetří místo v paměti. Opakovaně použitelné slovo, jako je ADD, se definuje pouze jednou. Čím složitější je aplikace, tím větší je úspora.</p>
                           <p>Než opustíme ranč s vejci, je tu ještě jedna myšlenka o stylu Forth. Vzpomeňte si na naši definici EGGSIZE</p>
                           <pre class="wp-block-preformatted">: EGGSIZE CATEGORY DUP LABEL TALLY ;

</pre>
                           <p>CATEGORY nám poskytla hodnotu, kterou jsme chtěli přenést na LABEL i TALLY, takže jsme zahrnuli DUP. Aby byla definice "čistší", mohli jsme být v pokušení DUP vyjmout a vložit ho dovnitř definice LABEL, na začátek. Mohli jsme tedy napsat:</p>
                           <pre class="wp-block-preformatted">: EGGSIZE CATEGORY LABEL TALLY ;

</pre>
                           <p>kde CATEGORY předává hodnotu do LABEL a LABEL ji předává do TALLY. Tento přístup by jistě fungoval. Ale pak bychom při definici REPORT museli říci</p>
                           <pre class="wp-block-preformatted">I LABEL DROP

</pre>
                           <p>místo toho, abychom jednoduše</p>
                           <pre class="wp-block-preformatted">I LABEL DROP

</pre>
                           <p>Programátoři mají tendenci dodržovat tuto konvenci: pokud je to možné, slova by měla zničit své vlastní parametry. Obecně je lepší umístit DUP uvnitř "volající definice" (EGGSIZE, zde) než do "volané" definice (LABEL, zde).</p>
                           <h3><span id="Další_příklad_8220Looping8221_through_an_Array">Další příklad - "looping" přes pole</span></h3>
                           <p>Rádi bychom vám představili malou techniku, která se týká polí. Tuto techniku si nejlépe ukážeme tak, že si napíšeme vlastní definici slova jazyka Forth s názvem DUMP. Slovo DUMP se používá k vypsání obsahu řady paměťových adres. Použití je</p>
                           <pre class="wp-block-preformatted">addr count DUMP

</pre>
                           <p>Například můžeme zadat</p>
                           <pre class="wp-block-preformatted">COUNTS 6 DUMP

</pre>
                           <p>vypsat obsah našeho pole pro počítání vajec s názvem COUNTS. Protože DUMP je primárně určen jako programovací nástroj pro výpis obsahu paměťových míst, vypisuje buď po jednotlivých bajtech, nebo po jednotlivých buňkách, v závislosti na typu adresování, které náš počítač používá. Naše verze programu DUMP bude tisknout buňku po buňce.</p>
                           <p>Je zřejmé, že DUMP bude zahrnovat smyčku DO. Otázka zní: co bychom měli použít za index? I když bychom mohli jako index smyčky použít samotný počet (0 - 6), je lepší použít jako index <em>adresu</em>.</p>
                           <p>Adresa COUNTS bude počátečním indexem smyčky, zatímco adresa plus počet bude sloužit jako limit, například takto:</p>
                           <pre class="wp-block-preformatted">: DUMP ( addr cell-count -- ) CELLS OVER + SWAP<br> DO CR I @ 5 U.R 1 CELLS +LOOP ;</pre>
                           <p>Klíčová věta je zde</p>
                           <pre class="wp-block-preformatted">CELLS OVER + SWAP

</pre>
                           <p>která bezprostředně předchází DO.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="158" src="./08-Variables, Constants and Arrays_files/ch8-array-looping.gif" alt="Použití DO...LOOP pro čtení hodnot z pole" class="wp-image-480"></figure>
                           <p>Koncová a počáteční adresa jsou nyní na zásobníku připraveny sloužit jako limit a index pro smyčku DO. Protože "indexujeme na adresách", jakmile se ocitneme uvnitř smyčky, stačí říci</p>
                           <pre class="wp-block-preformatted">I @ 5 U.R

</pre>
                           <p>vypsat obsah každého prvku pole. Protože zkoumáme buňky (@ načte hodnotu jedné buňky o jedné délce), zvýšíme index pokaždé o jednu buňku, a to pomocí</p>
                           <pre class="wp-block-preformatted">1 CELLS +LOOP

</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="200" height="85" src="./08-Variables, Constants and Arrays_files/ch8-byte-array.gif" alt="Pole bajtů uchovávají jednotlivé 8bitové hodnoty, například řetězce znaků ASCII - šetří místo v paměti" class="wp-image-481"></figure>
                           </div>
                           <h3><span id="Byte_Arrays">Bajtová pole</span></h3>
                           <p>Příkaz umožňuje vytvořit pole, v němž každý prvek tvoří jeden bajt, nikoli celá buňka. To je užitečné vždy, když ukládáte řadu čísel, jejichž rozsah se vejde do rozsahu, který lze vyjádřit osmi bity.</p>
                           <p>Rozsah osmibitového čísla bez znaménka je 0 až 255. Pole bajtů se používají také k ukládání řetězců znaků ASCII. Výhodou použití pole bajtů namísto pole buněk je to, že stejné množství dat můžete získat na 25 % (32bitový Forth) paměťového prostoru.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="233" src="./08-Variables, Constants and Arrays_files/ch8-pronounce-3.gif" alt="C! a C@ pracují s hodnotami v bajtových polích" class="wp-image-482"></figure>
                           </div>
                           <p>Mechanika použití pole bajtů je stejná jako použití pole buněk s tím rozdílem, že</p>
                           <ol>
                              <li>pro manipulaci s odsazením nemusíte používat buňky, protože každý prvek odpovídá jedné adresové jednotce, a</li>
                              <li>musíte používat slova C! a C@ místo ! a @. Tato slova, která pracují pouze s hodnotami bajtů, mají předponu "C", protože jejich typickým použitím je přijímání znaků ASCII.</li>
                           </ol>
                           <dl class="forth">
                              <dt>C!</dt>
                              <dt>( char addr - )</dt>
                              <dd>Uloží byte char na adresu addr.</dd>
                              <dt>C@</dt>
                              <dt>( char addr - )</dt>
                              <dd>Vybere hodnotu bajtu z adresy.</dd>
                           </dl>
                           <h3><span id="Initializing_an_Array">Inicializace pole</span></h3>
                           <p>Mnoho situací vyžaduje pole, jehož hodnoty se během provozu aplikace nikdy nezmění a které mohou být do pole uloženy stejně dobře v okamžiku jeho vytvoření, jako je tomu u CONSTANTů. Forth poskytuje prostředky, jak toho dosáhnout, prostřednictvím dvou slov CREATE a , (vyslovují se <em>create</em> a <em>čárka</em>).</p>
                           <p>Předpokládejme, že chceme mít v našem poli LIMITS trvalé hodnoty. Místo toho, abychom řekli</p>
                           <pre class="wp-block-preformatted">Proměnné LIMITS 4 buňky ALLOT

</pre>
                           <p>můžeme říci</p>
                           <pre class="wp-block-preformatted">Vytvořte LIMITS 220 , 340 , 170 , 100 , 190 ,

</pre>
                           <p>Obvykle by se výše uvedený řádek vkládal z diskového souboru, ale funguje i interaktivně.</p>
                           <p>Stejně jako slovo VARIABLE, i CREATE při kompilaci vloží do slovníku nový název a při spuštění vrátí adresu této definice. Pro hodnotu však "nepřiděluje" žádné bajty.</p>
                           <p>Slovo , vezme číslo ze zásobníku a uloží ho do pole. Takže pokaždé, když vyjádříte číslo a následuje za ním , přidáte do pole jednu buňku.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="154" src="./08-Variables, Constants and Arrays_files/ch8-array-increases.gif" alt="Vytváření polí konstantních hodnot pomocí operátorů CREATE a , (čárka)." class="wp-image-483"></figure>
                           <div class="sc-info-box normal full">
                              <p></p>
                              <h3><span id="Pro_nováčky">Pro nováčky</span></h5>
                              <p>Zakořeněné návyky, naučené z anglického psaní, vedou některé nováčky k tomu, že zapomínají psát koncové , v řádku. Pamatujte, že , neodděluje číslovky, ale <em>skládá je</em>.<br></p>
                           </div>
                           <p>K prvkům v poli CREATE můžete přistupovat stejně jako k prvkům v poli VARIABLE. Například:</p>
                           <pre class="wp-block-preformatted">LIMITS CELL+ @ .↵<span class="output">340 ok </span>

</pre>
                           <p> Do pole můžete ukládat i nové hodnoty, stejně jako do pole VARIABLE.</p>
                           <p>Pro inicializaci pole bajtů, které bylo definováno pomocí příkazu CREATE, můžete použít slovo C, (c-čárka). Každou z hodnot použitých v naší definici třídění vajec CATEGORY bychom mohli uložit například takto:</p>
                           <pre class="wp-block-preformatted">CREATE velikosti 18 C, 21 C, 24 C, 27 C, 30 C, 255 C,

</pre>
                           <p>To by nám umožnilo nadefinovat CATEGORY pomocí smyčky DO, nikoli jako sérii vnořených příkazů IF...THEN, a to následujícím způsobem</p>
                           <pre class="wp-block-preformatted">: CATEGORY 6 0 DO DUP SIZES I + C@ &lt; IF DROP I LEAVE THEN LOOP ;

</pre>
                           <p>Všimněte si, že jsme do pole přidali maximum (255), abychom zjednodušili definici týkající se kategorie 5.</p>
                           <p>Včetně inicializace pole SIZES zabere tato verze pouze tři řádky zdrojového textu oproti šesti a zabere také méně místa ve slovníku.</p>
                           <div class="sc-info-box normal full">
                              <p></p>
                              <h3><span id="Pro_lidi, kteří_neradi_hádají, jak to funguje">Pro lidi, kteří neradi hádají, jak to funguje</span></h5>
                              <p>Jedná se o tuto myšlenku: protože existuje pět možných kategorií, můžeme čísla kategorií použít jako index naší smyčky. Pokaždé porovnáme číslo na zásobníku s prvkem v SIZES, posunutým o index aktuální smyčky. Jakmile je váha na zásobníku větší než jeden z prvků v poli, opustíme smyčku a pomocí I zjistíme, kolikrát jsme smyčku prošli, než jsme ji "opustili". Protože toto číslo je naším posunem do pole, bude to také číslo naší kategorie.<br></p>
                           </div>
                           <h3><span id="Chapter_Summary">Shrnutí kapitoly</span></h3>
                           <h3><span id="Předchozí_slova">Předchozí slova</span></h5>
                           <p>Tady je seznam slov Forth, která jsme probrali v této kapitole:</p>
                           <dl class="forth">
                              <dt>VARIABLE xxx</dt>
                              <dt>( - ) xxx: ( - addr )</dt>
                              <dd>Vytvoří proměnnou s názvem xxx; slovo xxx po provedení vrátí její adresu </dd>.
                              <dt>!</dt>
                              <dt>( n addr - )</dt>
                              <dd>Uloží do adresy číslo o jedné délce.</dd>
                              <dt>@</dt>
                              <dt>( addr - n )</dt>
                              <dd>Vybere tuto hodnotu na adrese addr.</dd>
                              <dt>?</dt>
                              <dt>( addr - )</dt>
                              <dd>Vytiskne obsah adresy následovaný jednou mezerou.</dd>
                              <dt>+!</dt>
                              <dt>( n addr - )</dt>
                              <dd>Přidá k obsahu adresy číslo o jedné délce.</dd>
                              <dt>CONSTANT xxx</dt>
                              <dt>( n - ) xxx: ( - n )</dt>
                              <dd>Vytvoří proměnnou s názvem xxx s hodnotou n; slovo xxx po provedení vrací n.</dd>
                              <dt>2Proměnná XXX</dt>
                              <dt>( - ) xxx: ( - addr )</dt>
                              <dd>Vytvoří dvouhodnotovou proměnnou s názvem xxx; slovo xxx při provedení vrátí její adresu.</dd>
                              <dt>2CONSTANT XXX</dt>
                              <dt>( d - ) xxx: ( - d )</dt>
                              <dd>Vytvoří dvojnásobně dlouhou konstantu s názvem xxx s hodnotou d; slovo xxx při provedení vrátí d.</dd>
                              <dt>2!</dt>
                              <dt>( d addr - ) nebo ( n1 n2 addr - )</dt>
                              <dd>Uloží číslo dvojnásobné délky (nebo dvojici čísel jedné délky) na adresu addr.</dd>
                              <dt>2@</dt>
                              <dt>( addr - d ) nebo ( addr - n1 n2 )</dt>
                              <dd>Vybere číslo o dvojnásobné délce (nebo dvojici čísel o jedné délce) z adresy addr.</dd>
                              <dt>FILL</dt>
                              <dt>( addr n znak - )</dt>
                              <dd>Naplní n bajtů paměti, počínaje adresou addr, hodnotou char.</dd>
                              <dt>ERASE</dt>
                              <dt>( addr n - )</dt>
                              <dd>Uloží nuly do n bajtů paměti, počínaje adresou addr.</dd>
                              <dt>C!</dt>
                              <dt>( char addr - )</dt>
                              <dd>Uloží znak v bajtu na adresu addr.</dd>
                              <dt>C@</dt>
                              <dt>( char addr - )</dt>
                              <dd>Vybere hodnotu bajtu z adresy.</dd>
                           </dl>
                           <p>Klíč k zápisu komentáře zásobníku:</p>
                           <table class="wp-block-table">
                              <tbody>
                                 <tr>
                                    <td>n, n1, ...</td>
                                    <td>Jednodélkový signovaný</td>
                                 </tr>
                                 <tr>
                                    <td>d, d1, ...</td>
                                    <td>Dvojitá délka se znaménkem</td>
                                 </tr>
                                 <tr>
                                    <td>u, u1 ...</td>
                                    <td>Jednodélkové bez znaménka</td>
                                 </tr>
                                 <tr>
                                    <td>ud, ud1, ...</td>
                                    <td>Dvojnásobná délka bez znaménka</td>
                                 </tr>
                                 <tr>
                                    <td>addr</td>
                                    <td>Adresa</td>
                                 </tr>
                                 <tr>
                                    <td>len</td>
                                    <td>Délka (řetězce nebo vyrovnávací paměti)<br></td>
                                 </tr>
                                 <tr>
                                    <td>znak</td>
                                    <td>Hodnota znaku ASCII</td>
                                 </tr>
                              </tbody>
                           </table>
                           <h3><span id="Review_of_Terms">Přehled pojmů</span></h5>
                           <dl>
                              <dt>Mřížka</dt>
                              <dd>Řada paměťových míst s jedním názvem. Do jednotlivých míst lze ukládat a načítat hodnoty zadáním názvu pole a přidáním offsetu k adrese.</dd>
                              <dt>Konstanta</dt>
                              <dd>hodnota, která má jméno. Hodnota je uložena v paměti a obvykle se nikdy nemění.</dd>
                              <dt>Faktoring</dt>
                              <dd>jak se uplatňuje při programování ve Forthu, zjednodušení rozsáhlé úlohy vyčleněním těch prvků, které by mohly být opakovaně použity, a definování těchto prvků jako operací.</dd>
                              <dt>Vybírání</dt>
                              <dd>získání hodnoty z daného místa v paměti.</dd>.
                              <dt>Initialize</dt>.
                              <dd>pro přidělení počáteční hodnoty (počátečních hodnot) proměnné (nebo pole) před zahájením zbytku programu.</dd>
                              <dt>Offset</dt>
                              <dd>číslo, které lze přičíst k adrese začátku pole a získat tak adresu požadovaného místa v poli.</dd>
                              <dt>Uložení</dt>
                              <dd>umístění hodnoty na dané místo v paměti.</dd>
                              <dt>Proměnná</dt>
                              <dd>místo v paměti, které má jméno a do kterého se často ukládají a načítají hodnoty.</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="aligncenter"><img loading="lazy" width="230" height="100" src="./08-Variables, Constants and Arrays_files/felix.gif" alt="Programovací jazyk Forth - příklady" class="wp-image-353"></figure>
                           </div>
                           <h3><span id="Problémy_kapitola_8">Problémy - kapitola 8</span></h5>
                           <ol>
                              <li>
                                 Napište dvě slova s názvy BAKE-PIE a EAT-PIE. První slovo zvýší počet dostupných PIES o jedna. Druhé slovo snižuje počet o jedna a děkuje za koláč. Pokud však žádné koláče nejsou, napíše "Jaký koláč?". (ujistěte se, že na začátku nemáte žádné koláče.)
                                 <pre>EAT-PIE↵<span class="output">Jaký koláč? ok </span>
BAKE-PIE↵<span class="output">ok </span>.
EAT-PIE↵<span class="output">Děkuji! ok </span>
</pre>
                              </li>
                              <li>
                                 Napište slovo FREEZE-PIES, které vezme všechny dostupné koláče a přičte je k počtu koláčů v mrazáku. Nezapomeňte, že zmrazené koláče nelze jíst.
                                 <pre>BAKE-PIE BAKE-PIE FREEZE-PIES↵<span class="output">ok </span>
PIES ?↵<span class="output">0 ok </span>
FROZEN-PIES ?↵<span class="output">2 ok </span>
</pre>
                              </li>
                              <li>
                                 Definujte slovo .BASE, které vypíše aktuální hodnotu proměnné BASE v desítkové soustavě. Otestujte jej tak, že nejprve změníte hodnotu BASE na nějakou jinou hodnotu než deset. (Tohle je složitější, než se může zdát.)
                                 <pre>DECIMAL .BASE 10↵<span class="output">ok </span>
HEX .BASE 16↵<span class="output">ok </span>
</pre>
                              </li>
                              <li>
                                 Definujte slovo pro formátování čísel s názvem M., které vytiskne dvojciferné číslo s desetinnou tečkou. Poloha desetinné čárky v čísle je pohyblivá a závisí na hodnotě proměnné, kterou definujete jako PLACES. Například pokud do PLACES uložíte "1", dostanete
                                 <pre>200 000 M.↵<span class="output">20000.0 ok </span>
</pre>
                                 Tedy s desetinnou čárkou o jedno místo zprava. Nula v položce PLACES by neměla dát žádnou desetinnou čárku.
                              </li>
                              <li>
                                 Abyste měli přehled o zásobách barevných tužek v kanceláři, vytvořte pole, jehož každá buňka obsahuje počet různých barevných tužek. Definujte sadu slov tak, aby například výraz <code>ČERVENÉ TUŽKY</code> vrátil adresu buňky, která obsahuje počet červených tužek, atd. Pak nastavte tyto proměnné tak, aby označovaly následující počty:
                                 <pre>23 červených tužek
15 modrých tužek
12 zelených tužek
0 oranžových tužek
</pre>
                              </li>
                              <li>
                                 Histogram je grafické znázornění řady hodnot. Každá hodnota je znázorněna výškou nebo délkou sloupce. V tomto cvičení vytvoříte pole hodnot a vypíšete histogram, který pro každou hodnotu zobrazí řádek "*". Nejprve vytvořte pole s přibližně deseti buňkami. Každý prvek pole inicializujte hodnotou v rozsahu nula až sedmdesát. Potom definujte slovo PLOT, které bude pro každou hodnotu vypisovat řádek. Na každém řádku vypište číslo buňky následované počtem znaků "*", který se rovná obsahu této buňky. Například pokud má pole čtyři buňky a obsahuje hodnoty 1, 2, 3 a 4, pak PLOT vytvoří:
                                 <pre>1 *
2 **
3 ***
4 ****
</pre>
                              </li>
                              <li>
                                 Vytvořte aplikaci, která zobrazí hrací plochu tic-tac-toe, takže dva lidští hráči mohou provádět své tahy zadáváním z klávesnice. Například věta <code>4 X!</code> umístí "X" do políčka 4 (počítání začíná od 1) a vytvoří toto zobrazení:
                                 <pre> | |
---------
X | |
---------
  | |
</pre>
                                 Pak věta <code>3 O!</code> vloží "O" do pole 3 a vypíše zobrazení:
                                 <pre> | | O
---------
X | |
---------
  | |
</pre>
                                 Pro zapamatování obsahu tabule použijte pole bajtů, kde hodnota 1 znamená "X", -1 znamená "O" a 0 znamená prázdné pole.
                              </li>
                           </ol>
                           <div class="wp-block-genesis-blocks-gb-accordion gb-block-accordion gb-font-size-18">
                              <details>
                                 <summary class="gb-accordion-title">Odpovědi</summary>
                                 <div class="gb-accordion-text">
                                    <ol>
                                       <li>
                                          <pre>VARIABLE PIES 0 PIES !

: BAKE-PIE 1 PIES +! ;

: EAT-PIE
   PIES @ IF -1 PIES +!  ." Děkuji "
   ELSE ." Jaký koláč? " THEN ;
</pre>
                                       </li>
                                       <li>
                                          <pre>VARIABLE FROZEN-PIES 0 FROZEN-PIES !

: FREEZE-PIES PIES @ FROZEN-PIES +!  0 PIES !
</pre>
                                       </li>
                                       <li>
                                          <pre>: .BASE BASE @ DUP DECIMAL .  BASE !
</pre>
                                       </li>
                                       <li>
                                          <pre>VARIABLE PLACES 2 PLACES !

: M. ( s|d -- ) TUCK DABS
  &lt;# PLACES @ DUP -1 &lt;&gt; IF 0 DO # LOOP [CHAR] . HOLD
   ELSE DROP S&gt;D THEN #S ROT SIGN #&gt; TYPE SPACE ;
</pre>
                                       </li>
                                       <li>
                                          <pre>Vytvořit #PENCILS 4 buňky ALLOT

0 BUNĚK KONSTANTNÍ ČERVENÁ
1 BUŇKA KONSTANTNÍ ZELENÁ
2 BUŇKY KONSTANTNÍ MODRÁ
3 BUŇKY KONSTANTNÍ ORANŽOVÁ

: PENCILS ( barva -- addr ) #PENCILS + ;

23 ČERVENÝCH TUŽEK !
12 ZELENÝCH TUŽEK !
15 MODRÝCH TUŽEK !
0 ORANŽOVÝCH TUŽEK !
</pre>
                                       </li>
                                       <li>
                                          <pre>Vytvořit 'Vzorky 10 buněk ALLOT

: STAR [CHAR] * EMIT ;
: STARS ( #stars -- ) 0 ?DO STAR LOOP ;
: STARS ( n -- ) ?DUP IF STARS THEN ;
: SAMPLES ( sample# -- addr ) CELLS 'SAMPLES + ;
: INIT-SAMPLES 10 0 DO I 6 MOD I SAMPLES !  LOOP ;
: PLOT 10 0 DO CR I 2 .R SPACE I SAMPLES @ STARS LOOP CR ;

INIT-SAMPLES
</pre>
                                       </li>
                                       <li>
                                          <pre>Vytvořte tabuli 9 ALLOT

: SQUARE ( square# -- addr ) BOARD + ;
: CLEAR BOARD 9 ERASE ; CLEAR
: BAR ." | " ;
: DASHES CR 9 0 DO [CHAR] - EMITOVAT SMYČKU CR ;

: .BOX ( square# -- )
   SQUARE C@ DUP 0= IF 2 SPACES
      ELSE DUP 1 = IF ." X " ELSE ." O "
   THEN THEN DROP ;

: DISPLAY ( -- )
   CR 9 0 DO I IF I 3 MOD 0= IF DASHES
      ELSE BAR THEN THEN I .BOX
   LOOP CR QUIT ;

: PLAY ( player square# -- )
   1- 0 MAX 8 MIN ČTVEREC C! ;

: X!  ( square# -- ) 1 SWAP PLAY DISPLAY ;
: O!  ( square# -- ) -1 SWAP PLAY DISPLAY ;
</pre>
                                       </li>
                                    </ol>
                                 </div>
                              </details>
                           </div>
                        </div>
                     </div>
                  </article>
               </main>
            </div>
         </div>
      </div>
      <div class="site grid-container container hfeed grid-parent" id="page">
         <div class="site-content" id="content">
            <div class="content-area grid-parent mobile-grid-100 grid-70 tablet-grid-70" id="primary">
               <main class="site-main" id="main">
                  <article id="post-337" class="post-337 page type-page status-publish" itemtype="https://schema.org/CreativeWork" itemscope="">
                     <div class="inside-article">
                        <header class="entry-header" aria-label="Content">
                           <h2 class="entry-title" itemprop="headline">9. Pod kapotou</h2>
                        </header>
                        <div class="entry-content" itemprop="text">
                           <p> Zastavme se na chvíli u kapitoly, abychom zvedli kapotu Forthu a podívali se, co se děje uvnitř.</p>
                           <p>Některé z informací zde obsažených jsme uvedli již dříve, ale s rizikem nadbytečnosti se nyní podíváme na "stroj" Forth jako na celek, abychom viděli, jak to všechno do sebe zapadá.</p>
                           <h3><span id="Inside_INTERPRET">Vnitřní INTERPRET</span></h3>
                           <p>V první kapitole jsme se dozvěděli, že textový interpret, jehož jméno je INTERPRET, vybírá slova ze vstupního proudu a snaží se najít jejich definice ve slovníku. Pokud nějaké slovo najde, INTERPRET ho nechá provést.</p>
                           <figure class="wp-block-image"><img width="400" height="140" src="./09-Vykonávání kódu Forth_files/ch9-text-interpreter.gif" alt="Pomocí zaškrtávátka (&#39;) získáte ze slovníku Forth token pro vykonání&#39;definice." class="wp-image-484"></figure>
                           <p>Tyto samostatné operace můžeme provádět sami pomocí slov, která vykonávají složkové funkce INTERPRET. Například slovo ' (vyslovuje se <em>tick</em>) vyhledá definici ve slovníku a vrátí její <em>execution token</em>. Pokud jsme definovali GREET, jak jsme to udělali v <a href="https://www.forth.com/starting-forth/1-forth-stacks-dictionary/">kapitole 1</a>, můžeme nyní říci</p>
                           <pre class="wp-block-preformatted">' GREET U.↵<span class="output"> 4956608 ok </span>

</pre>
                           <p>a zjistí <em>execution token</em> GREET (ať už je jakýkoli).</p>
                           <p>Můžeme také přímo použít EXECUTE. INTERPRET provede definici, vzhledem k jejímu tokenu provedení ("xt") na zásobníku. Můžeme tedy říci</p>
                           <pre class="wp-block-preformatted">' GREET EXECUTE↵<span class="output"> Dobrý den, mluvím jazykem Forth ok </span>

</pre>
                           <p>a dosáhneme téhož, jako kdybychom pouze řekli GREET, jen oklikou.</p>
                           <p>Pokud tick nenajde slovo ve slovníku, provede ABORT" a vypíše chybovou zprávu.</p>
                           <p>Překladač textu Forth používá slovo související s tick, které vrací nulový příznak, pokud je slovo nalezeno. Název a použití tohoto slova se liší, ale podmíněná struktura věty INTERPRET vypadá vždy takto:</p>
                           <pre class="wp-block-preformatted">(najít slovo) IF (převést na číslo)<br> ELSE (provést slovo)<br>THEN</pre>
                           <p>To znamená, že pokud řetězec <em>není</em> definovaným slovem ve slovníku, pokusí se jej INTERPRET převést jako číslo. Pokud je to definované slovo, INTERPRET jej provede.</p>
                           <p>Slovo ' má několik způsobů použití. Můžete například použít výraz</p>
                           <pre class="wp-block-preformatted">' GREET .

</pre>
                           <p>zjistit, zda byl GREET definován, aniž by bylo nutné jej skutečně spustit (buď se vypíše xt, nebo <abbr title="Všechny moderní Forthy mají slovo [DEFINED] ( &#39;word&#39; -- f ) pro přímý test.">odpoví chybou</abbr>).</p>
                           <p>Můžete také použít xt pro DUMP obsahu definice, například takto:</p>
                           <pre class="wp-block-preformatted">' GREET 12 CELLS DUMP <br>A054620: 68 13 40 00 00 00 00 00 - 60 3D 03 0A 15 48 65 6C h.@.....'=...Hel A054630: 6C 6F 2C 20 49 20 73 70 - 65 61 6B 20 46 6F 72 74 lo, mluvím Fort A054640: 68 20 20 20 38 02 41 00 - 00 00 00 00 00 00 00 00 h 8.A......... ok</pre>
                           <p>Nebo můžete pomocí tiků implementovat něco, čemu se říká "vektorované provádění". Což nás přivádí k další části...</p>
                           <h3><span id="Vectored_Execution">Vektorované provádění</span></h3>
                           <p>Ačkoli to <em>zní <em>choulostivě, myšlenka vektorovaného spouštění je ve skutečnosti docela jednoduchá. Namísto <em>přímého vykonání definice<em>, jak jsme to udělali s větou</p>.
                           <pre class="wp-block-preformatted">' VELKÉ VYkonání

</pre>
                           <p>můžeme ji vykonat <em>nepřímo</em> tak, že její xt uchováme v proměnné a pak provedeme obsah této proměnné, například takto:</p>
                           <pre class="wp-block-preformatted">' GREET ukazatel !
pointer @ EXECUTE

</pre>
                           <p>Výhodou je, že můžeme později ukazatel změnit, takže jedno slovo může v různých časech provádět různé věci.</p>
                           <p>Tady je příklad, který si můžete sami vyzkoušet:</p>
                           <pre class="wp-block-preformatted">( 1 ) : HELLO ." Hello " ;<br>( 2 ) : GOODBYE ." (Dobrý den). Goodbye " ;<br>( 3 ) VARIABLE 'aloha ' HELLO 'aloha !<br>( 4 ) : ALOHA 'aloha @ EXECUTE ;</pre>
                           <p>V prvních dvou řádcích jsme jednoduše vytvořili slova, která vypisují řetězce "Hello" a "Goodbye". Ve třetím řádku jsme definovali proměnnou 'aloha. Ta bude naším ukazatelem. Ukazatel jsme inicializovali pomocí xt z HELLO. V řádku 4 jsme definovali slovo ALOHA, které provede definici, jejíž xt je v 'aloha.</p>
                           <p>Pokud nyní provedeme příkaz ALOHA, dostaneme</p>
                           <pre class="wp-block-preformatted">ALOHA↵<span class="output"> Hello ok </span>

</pre>
                           <p>Alternativně, pokud provedeme frázi</p>
                           <pre class="wp-block-preformatted">' GOODBYE 'aloha !

</pre>
                           <p>uložit xt GOODBYE do 'aloha, dostaneme</p>
                           <pre class="wp-block-preformatted">ALOHA↵<span class="output"> Goodbye ok </span>

</pre>
                           <p>Takže stejné slovo, ALOHA, může znamenat dvě různé věci.</p>
                           <p>Všimněte si, že jsme náš ukazatel pojmenovali 'aloha (což bychom vyslovili <em>tick-aloha</em>). Protože <em>tick</em> poskytuje xt, použijeme ho jako předponu, která naznačuje "xt z" ALOHA. Je konvencí jazyka Forth používat tuto předponu pro ukazatele vektorového provádění.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="257" src="./09-Vykonávání kódu Forth_files/ch9-pronounce-1.gif" alt="vektorované vykonávání ve Forthu, vně i uvnitř definic funkcí" class="wp-image-485"></figure>
                           </div>
                           <p>Tick vždy přejde na další slovo ve <em>vstupním proudu</em>. Co když ale tick umístíme dovnitř definice? Když provedeme definici, tick najde další slovo ve vstupním proudu, nikoliv další slovo v definici. Mohli bychom tedy definovat</p>
                           <pre class="wp-block-preformatted">: SAY ' 'aloha ! ;

</pre>
                           <p>tedy enter</p>
                           <pre class="wp-block-preformatted">SAY HELLO↵<span class="output"> ok </span>
ALOHA↵<span class="output"> Hello ok </span>

</pre>
                           <p>nebo</p>
                           <pre class="wp-block-preformatted">SAY GOODBYE↵<span class="output"> ok </span>
ALOHA↵<span class="output"> Sbohem ok </span>

</pre>
                           <p>uložit xt buď HELLO nebo GOODBYE do 'aloha.</p>
                           <p>Ale co když chceme, aby tik použil další slovo v <em>definici</em>? Musíme použít slovo ['] (<em>závorka-tykátová-závorka</em>) místo tykání. Například:</p>
                           <pre class="wp-block-preformatted">: COMING ['] HELLO 'aloha ! ;
: GOING ['] GOODBYE 'aloha ! ;

</pre>
                           <p>Nyní můžeme říci</p>
                           <pre class="wp-block-preformatted">PŘICHÁZÍ↵<span class="output"> ok </span>
ALOHA↵<span class="output"> Ahoj ok </span>
GOING↵<span class="output"> ok </span>
ALOHA↵<span class="output"> Sbohem ok </span>

</pre>
                           <dl class="forth">
                              <dt>' xxx</dt>
                              <dt>( - addr )</dt>
                              <dd>Pokusí se najít ve slovníku token provedení xxx (slovo, které následuje ve vstupním proudu) </dd>.
                              <dt>[']</dt>
                              <dt>( - ) spustit: ( - addr )</dt>
                              <dd>Používá se pouze v definici s dvojtečkou, sestaví exekuční token následujícího slova v definici jako literál.</dd>
                           </dl>
                           <h3><span id="The_Structure_of_a_Dictionary_Entry">Struktura slovníkového hesla</span></h3>
                           <p>Všechny definice, ať už byly definovány pomocí :, VARIABLE, VALUE, CREATE nebo jakýmkoli jiným "definičním slovem", mají společné tyto základní části:</p>
                           <pre class="wp-block-preformatted">pole name<br>pole link<br>pole code (nebo code pointer)<br>pole data</pre>.
                           <p>Na příkladu proměnné DATE si ukážeme, jak jsou tyto součásti uspořádány v jednotlivých položkách slovníku. V tomto schématu představuje každá vodorovná čára jednu buňku slovníku:</p>
                           <figure class="wp-block-image"><img loading="lazy" width="377" height="192" src="./09-Vykonávání kódu Forth_files/ch9-Forth-struktura-zadání-slovníku.gif" alt="struktura záznamů slovníku Forth" class="wp-image-486"></figure>
                           <p>Žádné dva systémy Forth nejsou v tomto ohledu stejné. Může existovat více základních částí, jejich velikost se může lišit a téměř jistě se liší i pořadí jednotlivých komponent.</p>
                           <p>V této knize se zabýváme pouze <em>funkcemi</em> čtyř komponent, nikoli jejich <em>pořadím</em> uvnitř slovníkového hesla.</p>
                           <h3><span id="Název">Jméno</span></h5>
                           <p>V našem příkladu obsahuje první bajt počet znaků v plném názvu definovaného slova (v DATE jsou čtyři písmena). Další čtyři bajty obsahují reprezentace ASCII čtyř písmen v názvu definovaného slova.</p>
                           <p>Všimněte si "precedenčního bitu" v diagramu. Tento bit se při kompilaci používá k určení, zda se má slovo během kompilace provést, nebo zda se má jednoduše zakompilovat do nové definice. Více o tom v <a href="https://www.forth.com/starting-forth/11-forth-compiler-defining-words/">kapitole 11</a>.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="200" height="279" src="./09-Vykonávání kódu Forth_files/ch9-link-field-monk.gif" alt="pole odkazu v definicích Forth pomáhá procházet slovníkem" class="wp-image-487"></figure>
                           </div>
                           <h3><span id="Odkaz">Odkaz</span></h5>
                           <p>Buňka "odkaz" obsahuje adresu předchozí definice v seznamu slovníku. Buňku odkazu lze použít při lineárním vyhledávání ve slovníku. Pro určité zjednodušení si představte, že to funguje takto:</p>
                           <p>Při každém přidání nového slova do slovníku kompilátor nastaví odkazové pole tak, aby ukazovalo na adresu předchozí definice. Zde nastavuje odkazové pole CUISINART tak, aby ukazovalo na definici CAR.</p>
                           <p>Při vyhledávání začíná klíště (nebo závorka-klíště-zásuvka atd.) s nejnovějším slovem a postupuje "řetězcem" zpět, přičemž k vyhledání další definice zpět používá adresu v každém odkazovém poli.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="200" height="183" src="./09-Provedení kódu Forth_files/ch9-link-field-tick.gif" alt="odkazové pole drží nulu pro první slovo ve slovníku Forth" class="wp-image-488"></figure>
                           </div>
                           <p>Pole odkazu první definice ve slovníku obsahuje nulu, která říká tick, aby to vzdal; slovo není ve slovníku.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="440" height="377" src="./09-Vykonávání kódu Forth_files/ch9-run-time-code-pointers.gif" alt="ukazatel kódu Forth ukazuje na kód běhu" class="wp-image-489"></figure>
                           <h3><span id="Code_Pointer">Ukazatel kódu</span></h5>
                           <p>Další je "ukazatel kódu". Právě xt obsažené v tomto ukazateli odlišuje proměnnou od konstanty nebo definice dvojtečky. Je to adresa instrukce, která se provede jako první, když se provede určitý typ slova. Koncepčně v případě proměnné ukazuje ukazatel na kód, který tlačí adresu proměnné na zásobník dat. V případě konstanty ukazuje ukazatel na kód, který obsah konstanty posune na zásobník dat. V případě definice dvojtečky ukazuje ukazatel na kód, který provede zbytek slov v definici dvojtečky. V praxi existuje mnoho způsobů, jak tento koncept realizovat, včetně realizace nativního kódu.</p>
                           <p>Kód, na který je ukazováno, se nazývá "kód za běhu", protože se používá při provádění slova tohoto typu (nikoli při definici nebo kompilaci slova tohoto typu).</p>
                           <p>Všechny proměnné (konceptuálně) mají stejný ukazatel kódu; všechny konstanty mají stejný vlastní ukazatel kódu atd.</p>
                           <p><em>Poznámka: Mnoho moderních implementací jazyka Forth má v poli kódu místo ukazatele na strojový kód skutečný strojový kód </em></p>.
                           <h3><span id="Data_pole">Datové pole</span></h5>
                           <p>Za ukazatelem na kód následuje datové pole. V proměnných a konstantách je datové pole pouze jedna buňka. V případě 2VARIABLE nebo 2CONSTANT jsou datovým polem dvě buňky. V poli může být datové pole libovolně dlouhé. V definici dvojtečky závisí délka datového pole na délce definice, jak si vysvětlíme v následující části. Přesně řečeno, definice dvojtečky v moderním Forthu nemá datové pole.</p>
                           <p>Kódový ukazatel xt, který dodává tick a který očekává EXECUTE, je výše definovaný kódový ukazatel. Začátek datového pole lze zjistit pomocí &gt;BODY, slova, které vypočítá datové pole dané xt. &gt;BODY nefunguje pro definice dvojtečky. Některé Forthy mohou dokonce zakázat použití &gt;BODY na jakoukoli systémovou datovou strukturu (proměnné konstanty, uživatel apod.).</p>
                           <h3><span id="The_Basic_Structure_of_a_Colon_Definition">Základní struktura definice dvojtečky</span></h3>
                           <p> Zatímco formát hlavičky a ukazatele kódu je u všech typů definic stejný, formát datového pole se u jednotlivých typů liší. Podívejme se na datové pole definice dvojtečky.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="200" height="227" src="./09-Vykonávání kódu Forth_files/ch9-photograph.gif" alt="struktura definice dvojtečky Forth" class="wp-image-490"></figure>
                           </div>
                           <p>Datové pole definice dvojtečky obsahuje <em>xty</em> dříve definovaných slov, která tvoří definici. Zde je slovníkové heslo pro definici slova FOTOGRAF, které je definováno jako</p>
                           <pre class="wp-block-preformatted">: FOTOGRAF
   ČAS OTEVŘENÍ ZÁVĚRKY EXPONOVAT ČAS ZAVŘENÍ ZÁVĚRKY ;

</pre>
                           <p>Při spuštění PHOTOGRAPH se postupně provedou definice, na které ukazují po sobě jdoucí xts. Mechanismus, který čte seznam xts a provádí definice, na které ukazují, se nazývá "interpret adres" </p>.
                           <p>Slovo ; na konci definice sestavuje xt slova zvaného EXIT. Jak vidíte na obrázku, xt EXIT se nachází v poslední buňce slovníkového hesla. Interpret adresy provede EXIT, když se dostane na tuto adresu, stejně jako provede ostatní slova v definici. EXIT ukončí provádění interpretu adresy, jak uvidíme v následující části.</p>
                           <h3><span id="Nested_Levels_of_Execution">Nested Levels of Execution</span></h3>
                           <p>Úkolem funkce EXIT je vrátit tok provádění do další definice vyšší úrovně, která odkazuje na aktuální definici. Podívejme se, jak to zjednodušeně funguje.</p>
                           <p>Předpokládejme, že večeře se skládá ze tří chodů:</p>
                           <pre class="wp-block-preformatted">: VEČEŘE POLÉVKA PŘEDKRM DEZERT ;

</pre>
                           <p>a že dnešní ENTREE se jednoduše skládá z</p>
                           <pre class="wp-block-preformatted">: ENTREE KUŘECÍ RÝŽE ;

</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="200" height="194" src="./09-Provádění kódu Forth_files/ch9-dinner-1.gif" alt="ukazatel interpretu sleduje tokeny provádění všech funkcí v definici" class="wp-image-491"></figure>
                           </div>
                           <p>Vykonáváme funkci DINNER a právě jsme dokončili funkci SOUP. Ukazatel, který používá interpret adresy, se nazývá "ukazatel interpretu". Protože dalším chodem po SOUP je ENTREE, ukazuje náš ukazatel interpretu na buňku, která obsahuje xt ENTREE.</p>
                           <p>Děj, který interpreter adres provádí, si lze představit jako "volání podprogramu" všech xt v seznamu, přičemž návratový zásobník slouží k uchovávání návratových adres a EXIT funguje jako strojová instrukce RTS (návrat z podprogramu).</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="140" height="198" src="./09-Execution of Forth Code_files/ch9-quit.gif" alt="QUIT vyčistí návratový zásobník a spustí interpreter hledající vstup" class="wp-image-492"></figure>
                           </div>
                           <h3><span id="One_Step_Beyond">Jeden krok za hranice</span></h5>
                           <p>Teď vás samozřejmě zajímá: Co se stane, když konečně provedeme EXIT v DINNER. Čí návratová adresa se nachází na návratovém zásobníku? Na co se vrátíme?</p>
                           <p>No, nezapomeňte, že DINNER byl právě proveden pomocí EXECUTE, což je součást INTERPRET. INTERPRET je smyčka, která kontroluje celý vstupní proud. Předpokládáme-li, že jsme po DINNER zadali ↵, pak už není co interpretovat. Když tedy ukončíme INTERPRET, kde nás to nechá? V nejvzdálenější definici každého terminálu, která se nazývá QUIT.</p>
                           <p>QUIT ve zjednodušené podobě vypadá takto:</p>
                           <pre class="wp-block-preformatted">: QUIT BEGIN<br> (vyčistit návratový zásobník)<br> (přijmout vstup)<br> INTERPRET<br> ." ok " CR<br> ZPĚT ;</pre>
                           <p>(Poznámky v závorkách představují slova a věty, které ještě nebyly pokryty.) Vidíme, že za slovem INTERPRET následuje zpráva s tečkou, "ok" a CR, což je samozřejmě to, co vidíme po dokončení interpretace.</p>
                           <p>Následuje fráze</p>
                           <pre class="wp-block-preformatted">AGAIN

</pre>
                           <p>která nás bezpodmínečně vrací na začátek cyklu, kde vymažeme návratový zásobník a opět čekáme na vstup.</p>
                           <p>Pokud provedeme QUIT na libovolné úrovni provádění, okamžitě ukončíme provádění naší aplikace a znovu vstoupíme do smyčky QUIT. Návratový zásobník bude vymazán (bez ohledu na to, kolik úrovní návratových adres jsme tam měli, protože nyní bychom žádnou z nich nemohli použít) a systém bude čekat na vstup. Vidíte, proč lze QUIT použít k tomu, aby se na našem terminálu neobjevila zpráva "ok".</p>
                           <h3><span id="Abandoning_the_Nest">Odchod z hnízda</span></h5>
                           <p>Je možné zařadit EXIT doprostřed definice. Pokud bychom například předefinovali ENTREE takto:</p>
                           <pre class="wp-block-preformatted">: ENTREE CHICKEN EXIT RICE ;

</pre>
                           <p>tedy při následném provedení VEČEŘE ukončíme hned za CHICKEN a vrátíme se k dalšímu chodu po ENTREE, tedy DESSERTu.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="77" src="./09-Vykonávání kódu Forth_files/ch9-dinner-exit.gif" alt="EXIT pro opuštění vnořených cyklů a dalších struktur" class="wp-image-493"></figure>
                           <p>EXIT se běžně používá k ukončení hluboce vnořených podmíněných struktur.</p>
                           <dl class="forth">
                              <dt>EXIT</dt>
                              <dt>( - )</dt>
                              <dd>Pokud je zakomponován do definice dvojtečky, ukončí provádění v tomto bodě.</dd>
                              <dt>QUIT</dt>
                              <dt>( - )</dt>
                              <dd>Vymaže návratový zásobník a vrátí řízení do terminálu. Není uvedena žádná zpráva.</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="288" height="388" src="./09-Execution of Forth Code_files/ch9-Forth-memory-map.gif" alt="Paměťová mapa Forthu: systémové proměnné a slovník" class="wp-image-494"></figure>
                           </div>
                           <h3><span id="Forth_Geography">Zeměpis jazyka Forth</span></h3>
                           <p>Toto je paměťová mapa typického systému Forth:</p>
                           <h3><span id="System_Variables">Systémové proměnné</span></h5>
                           <p>Tato část paměti obsahuje "systémové proměnné", které vytváří základní jádro jazyka Forth a používá je celý systém. Uživatel je obvykle nepoužívá.</p>
                           <h3><span id="User_Dictionary">Uživatelský slovník</span></h5>
                           <p>Slovník se bude rozrůstat do větší paměti, jak budete přidávat vlastní definice. Na další volnou buňku ve slovníku v každém okamžiku ukazuje proměnná nazvaná CP. Během procesu kompilace se ukazatel CP upravuje buňku po buňce tak, jak je položka přidávána do slovníku. CP je tedy záložka kompilátoru; ukazuje na místo ve slovníku, kde může kompilátor provést další kompilaci.</p>
                           <p>CP se používá také pomocí slova ALLOT, které posune CP o daný počet bajtů. Například věta</p>
                           <pre class="wp-block-preformatted">5 CELLS ALLOT

</pre>
                           <p>přidá k CP dvacet, takže kompilátor ponechá ve slovníku místo pro pětibuněčné pole.</p>
                           <p>Souvisejícím slovem je ZDE, které je jednoduše definováno jako</p>
                           <pre class="wp-block-preformatted">: ZDE CP @ ;

</pre>
                           <p>pro vložení hodnoty CP na zásobník. Slovo , (čárka), které ukládá jednovětnou hodnotu do další volné buňky slovníku, je jednoduše definováno</p>
                           <pre class="wp-block-preformatted">: , ZDE !  CELL ALLOT ;

</pre>
                           <p>to znamená, že uloží hodnotu do HERE a posune ukazatel slovníku o jednu buňku, aby pro ni zbylo místo.</p>
                           <p>Pomocí HERE můžete zjistit, kolik paměti potřebuje jakákoli část vaší aplikace, a to jednoduše porovnáním HERE z předchozího stavu s HERE po kompilaci. Například,</p>
                           <pre class="wp-block-preformatted">HERE INCLUDE random.f HERE SWAP - . ↵<span class="output"> 196 ok </span></pre>
                           <p>ukazuje, že definice načtené zdrojovým souborem random.f zaplnily 196 bajtů paměťového prostoru ve slovníku.</p>
                           <h3><span id="The_Pad">Pad</span></h5>
                           <p>V určité vzdálenosti od místa ZDE se ve slovníku nachází malá oblast paměti nazývaná "podložka". Podobně jako scratchpad se obvykle používá k uložení řetězců znaků ASCII, se kterými se manipuluje před odesláním do terminálu. Například slova pro formátování čísel používají pad k uchování číslic ASCII během procesu převodu, předtím, než se provede TYPE.</p>
                           <p>Velikost bloku je neomezená. Ve většině systémů jsou mezi začátkem padu a vrcholem zásobníku parametrů stovky kilobajtů.</p>
                           <p>Protože adresa začátku padu je definována vzhledem k poslední položce slovníku, přesune se při každém přidání nové definice nebo provedení příkazu FORGET nebo MARKER. Toto uspořádání se však ukazuje jako bezpečné, protože pad není nikdy použit, když nastane některá z těchto událostí. Slovo PAD vrací aktuální adresu začátku bloku. Definuje se jednoduše:</p>
                           <pre class="wp-block-preformatted">: PAD ZDE 340 + ;

</pre>
                           <p>To znamená, že vrací adresu, která je o pevný počet bajtů dále než ZDE. (Skutečný počet se liší.)</p>
                           <h3><span id="Parameter_Stack">Zásobník parametrů</span></h5>
                           <p>Daleko nad podložkou v paměti se nachází oblast vyhrazená pro zásobník parametrů. Ačkoli si rádi představujeme, že se hodnoty skutečně pohybují někde nahoru nebo dolů, když je "vyskakujeme" a "posunujeme", ve skutečnosti se nic nepohybuje. Jediné, co se mění, je ukazatel na "vrchol" zásobníku.</p>
                           <p>Jak vidíte níže, když "vložíme číslo na zásobník", ve skutečnosti se stane to, že se "dekrementuje" ukazatel (takže ukazuje na další volné místo směrem k dolní části paměti) a pak se naše číslo uloží tam, kam ukazuje ukazatel. Když "odstraníme číslo ze zásobníku", číslo se načte z místa, kam ukazuje ukazatel, a pak se ukazatel inkrementuje. Jakákoli čísla nad ukazatelem zásobníku na naší mapě jsou bezvýznamná.</p>
                           <p>Při přidávání nových hodnot na zásobník se zásobník "zvětšuje směrem k malé paměti" </p>.
                           <figure class="wp-block-image"><img loading="lazy" width="440" height="188" src="./09-Execution of Forth Code_files/ch9-stack-pointer.gif" alt="SP@ - zásobník parametrů jazyka Forth (zásobník dat) roste směrem k nízké paměti" class="wp-image-495"></figure>
                           <p>Ukazatel zásobníku se načítá pomocí slova SP@ (vyslovuje se <em>s-p-fetch</em>). Protože SP@ udává adresu horního umístění zásobníku, věta</p>
                           <pre class="wp-block-preformatted">SP@ @

</pre>
                           <p> načte obsah horní části zásobníku. Tato operace je samozřejmě totožná s operací DUP. Pokud bychom měli na zásobníku pět hodnot, mohli bychom pátou z nich zkopírovat dolů pomocí fráze</p>
                           <pre class="wp-block-preformatted">SP@ 4 CELLS + @

</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="140" height="158" src="./09-Execution of Forth Code_files/ch9-stack-bottom.gif" alt="SP0 ukazuje na dno zásobníku parametrů jazyka Forth&#39;s (zásobník dat)" class="wp-image-496"></figure>
                           </div>
                           <p>(ale to se nepovažuje za správnou programátorskou praxi).</p>
                           <p>Na dno zásobníku ukazuje proměnná S0 (<em>s-nulou</em>). S0 obsahuje adresu následující buňky <em>pod</em> buňkou "prázdného zásobníku".</p>
                           <p><em>[Poznámka redakce: Názvy S0 a SP@ nejsou ve standardním jazyce Forth definovány. Váš systém Forth pro ně může mít jiné názvy]</em></p>
                           <p>Všimněte si, že u čísel dvojí délky je buňka vyššího řádu uložena na nižší paměťové adrese, ať už na zásobníku nebo ve slovníku. Operátory 2@ a 2! udržují pořadí buněk konzistentní.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="300" height="222" src="./09-Execution of Forth Code_files/ch9-stack-double-number.gif" alt="pořadí buněk u dvojčísel Forth" class="wp-image-497"></figure>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="100" height="194" src="./09-Vykonávání kódu Forth_files/ch9-pronounce-2.gif" alt="Proměnná TIB obsahuje adresu vstupní vyrovnávací paměti terminálu, alias bufferu vstupních zpráv" class="wp-image-498"></figure>
                           </div>
                           <h3><span id="Input_Message_Buffer">Vyrovnávací paměť vstupních zpráv</span></h5>
                           <p>TIB obsahuje počáteční adresu pro "vyrovnávací paměť vstupních zpráv" neboli "Terminal Input Buffer", která roste směrem k <em>vysoké</em> paměti (stejným směrem jako podložka). Když zadáváte text z terminálu, uloží se do této vyrovnávací paměti, odkud jej interpreter textu prohledá.</p>
                           <h3><span id="Return_Stack">Zásobník pro návrat</span></h5>
                           <p>Nad vyrovnávací pamětí se nachází návratový zásobník, který funguje stejně jako zásobník parametrů. Neexistují žádná vysokoúrovňová slova jazyka Forth analogická slovům S0 a SP@, která by odkazovala na návratový zásobník.</p>
                           <h3><span id="User_Variables">Uživatelské proměnné</span></h5>
                           <p>Další část paměti obsahuje "uživatelské proměnné". Mezi tyto proměnné patří BASE, SP0 a mnoho dalších, kterými se budeme zabývat v některé z příštích částí.</p>
                           <p>Tímto končí naše putování po paměťové mapě typického systému Forth.</p>
                           <p>Tady jsou slova, která jsme právě probrali a která se týkají oblastí paměti v systému Forth:</p>
                           <dl class="forth">
                              <dt>ZDE</dt>
                              <dt>( - addr )</dt>
                              <dd>Vrátí nejbližší dostupné místo slovníku.</dd>
                              <dt>PAD</dt>
                              <dt>( - addr )</dt>
                              <dd>Vrací počáteční adresu oblasti scratchpadu, která slouží k uchování řetězců znaků pro meziproduktové zpracování.</dd>
                              <dt>SP@</dt>
                              <dt>( - addr )</dt>
                              <dd>Vrátí adresu vrcholu zásobníku před provedením SP@.</dd>.
                              <dt>S0</dt>
                              <dt>( - addr )</dt>
                              <dd>Proměnná uživatele. Obsahuje adresu spodní části zásobníku parametrů.</dd>
                           </dl>
                           <h3><span id="User_Variables-2">Uživatelské proměnné</span></h3>
                           <p>V následujícím seznamu je uvedena většina uživatelských proměnných. O některých se již nebudeme zmiňovat. Nesnažte se tuto tabulku zapamatovat. Jen si zapamatujte, kde je najdete.</p>
                           <p>Zde jsou uvedena další slova, která se týkají oblastí paměti v systému Forth:</p>
                           <dl class="forth">
                              <dt>TIB</dt>
                              <dt>( - addr )</dt>
                              <dd>Vrací adresu začátku vstupní vyrovnávací paměti terminálu </dd>.
                              <dt>#TIB</dt>
                              <dt>( - addr )</dt>
                              <dd>Zadává velikost obsahu vstupní vyrovnávací paměti terminálu.</dd>
                              <dt>BASE</dt>
                              <dt>( - addr )</dt>
                              <dd></dd>
                              <dt>H</dt>
                              <dt>( - addr )</dt>
                              <dd>Ukazatel na slovník. Ukazatel na další volný bajt.</dd>
                              <dt>&gt;IN</dt>
                              <dt>( - addr )</dt>
                              <dd>Ukazatel na aktuální pozici analyzovanou ve vstupním proudu.</dd>
                           </dl>
                           <p>Uživatelské proměnné nejsou jako běžné proměnné. U obyčejné proměnné (definované slovem VARIABLE) se hodnota uchovává v těle slovníkového záznamu. Každá uživatelská proměnná je naproti tomu uchovávána v poli zvaném "uživatelská tabulka". Slovníkový záznam pro každou uživatelskou proměnnou je umístěn jinde; jeho tělo obsahuje offset do uživatelské tabulky. Při spuštění názvu uživatelské proměnné, například BASE, se tento offset přidá k počáteční adrese uživatelské tabulky, což umožňuje používat @ nebo ! běžným způsobem.</p>
                           <figure class="wp-block-image"><img loading="lazy" width="440" height="153" src="./09-Vykonávání kódu Forth_files/ch9-user-variables.gif" alt="Uživatelské proměnné Forth jsou uloženy v uživatelské tabulce, jinak než běžné proměnné" class="wp-image-499"></figure>
                           <p>Hlavní výhodou uživatelských proměnných je, že libovolný počet úloh může používat stejnou <em>definici</em> proměnné a každá z nich dostane svou vlastní <em>hodnotu</em> (protože každá úloha má nejen své zásobníky, ale také svou vlastní uživatelskou tabulku). Každá úloha, která provádí</p>
                           <pre class="wp-block-preformatted">Základní @

</pre>
                           <p>získá hodnotu BASE ze své vlastní uživatelské tabulky. Tím se ušetří spousta místa v systému a zároveň je možné, aby se každá úloha prováděla nezávisle.</p>
                           <p>Uživatelské proměnné jsou definovány slovem USER. Pořadí uživatelských proměnných v tabulce a jejich offsetové hodnoty se v jednotlivých systémech liší.</p>
                           <p>Shrňme si, že existují tři druhy proměnných: Systémové proměnné obsahují hodnoty používané celým systémem Forth. Uživatelské proměnné obsahují hodnoty, které jsou pro každou úlohu jedinečné, i když jejich definice mohou používat všechny úlohy v systému. Běžné proměnné mohou být přístupné buď v rámci celého systému, nebo pouze v rámci jedné úlohy.</p>
                           <h3><span id="Forth_Vocabularies">Slovníky jazyka Forth</span></h3>
                           <p>Systémy Forth poskytují způsoby správy slovníku uspořádáním slov do slovníků. Programátor může například vytvořit slovník pro všechna slova týkající se určitého projektu. Systému lze zadat pokyny, v jakých slovnících a v jakém pořadí má dané slovo vyhledávat.</p>
                           <p>Informace o slovnících naleznete v normě ANS nebo ISO Forth nebo v <a href="https://www.forth.com/forth-books/">Příručce programátora jazyka Forth</a>, která nabízí diskusi o rozsahu, slovnících a pořadí vyhledávání.</p>
                           <h3><span id="Chapter_Summary">Shrnutí kapitoly</span></h3>
                           <h3><span id="Forth_Words">Slova jazyka Forth</span></h5>
                           <p>Tady je slovníček slovíček Forth, o kterých pojednává tato kapitola:</p>
                           <dl class="forth">
                              <dt>' xxx</dt>
                              <dt>( - addr )</dt>
                              <dd>Pokusí se najít ve slovníku token provedení xxx (slovo, které následuje ve vstupním proudu) </dd>.
                              <dt>[']</dt>
                              <dt>( - ) spustit: ( - addr )</dt>
                              <dd>Používá se pouze v definici s dvojtečkou, sestaví exekuční token následujícího slova v definici jako literál.</dd>
                              <dt>EXIT</dt>
                              <dt>( - )</dt>
                              <dd>Při kompilaci v definici dvojtečky ukončí provádění v tomto bodě.</dd>
                              <dt>QUIT</dt>
                              <dt>( - )</dt>
                              <dd>Vymaže návratový zásobník a vrátí řízení do terminálu. Není uvedena žádná zpráva.</dd>
                              <dt>ZDE</dt>
                              <dt>( - addr )</dt>
                              <dd>Vrátí další dostupné umístění slovníku.</dd>
                              <dt>PAD</dt>
                              <dt>( - addr )</dt>
                              <dd>Vrací počáteční adresu oblasti scratchpadu, která slouží k uchování řetězců znaků pro meziproduktové zpracování.</dd>
                              <dt>SP@</dt>
                              <dt>( - addr )</dt>
                              <dd>Vrátí adresu vrcholu zásobníku před provedením SP@.</dd>.
                              <dt>S0</dt>
                              <dt>( - addr )</dt>
                              <dd>Proměnná uživatele. Obsahuje adresu spodní části zásobníku parametrů.</dd>
                              <dt>TIB</dt>
                              <dt>( - addr )</dt>.
                              <dd>Vrací adresu začátku vstupní vyrovnávací paměti terminálu.</dd>
                              <dt>#TIB</dt>
                              <dt>( - addr )</dt>
                              <dd>Zadává velikost obsahu vstupní vyrovnávací paměti terminálu.</dd>
                              <dt>BASE</dt>
                              <dt>( - addr )</dt>
                              <dd></dd>
                              <dt>H</dt>
                              <dt>( - addr )</dt>
                              <dd>Ukazatel na slovník. Ukazatel na další volný bajt.</dd>
                              <dt>&gt;IN</dt>
                              <dt>( - addr )</dt>
                              <dd>Ukazatel na aktuální pozici analyzovanou ve vstupním proudu.</dd>
                           </dl>
                           <h3><span id="Review_of_Terms">Přehled pojmů</span></h5>
                           <dl>
                              <dt>Překladač adres</dt>
                              <dd>Druhý ze dvou interpretů jazyka Forth, který provádí data (seznam adres, seznam volání, strojový kód, ...) nalezená ve slovníkovém záznamu definice dvojtečky. Interpret adresy také zpracovává vnořování úrovní provádění slov uvnitř slov.</dd>
                              <dt>Tělo</dt>
                              <dd>kódové a datové pole slovníkového hesla jazyka Forth.</dd>
                              <dt>Cfa</dt>
                              <dd>adresa kódového pole; adresa kódového pole ukazatele slovníkového záznamu.</dd>
                              <dt>Kódové pole ukazatele</dt>
                              <dd>buňka ve slovníkovém záznamu, která nějakým způsobem ukazuje na xt běhového kódu pro tento konkrétní typ definice. Například ve slovníkovém hesle zkompilovaném pomocí : by pole ukazovalo na interpret adresy.</dd>
                              <dt>Definice slova</dt>
                              <dd>Slovo jazyka Forth, které vytváří slovníkovou položku. Příkladem může být :, CONSTANT, VARIABLE atd.</dd>.
                              <dt>Hlava</dt>
                              <dd>políčko názvu a odkazu slovníkového hesla jazyka Forth.</dd>
                              <dt>Vyrovnávací paměť vstupní zprávy</dt>
                              <dd>oblast paměti v rámci terminálové úlohy, která slouží k ukládání textu, jak přichází z terminálu. Příchozí zdrojový text je zde interpretován.</dd>
                              <dt>Pole odkazu</dt>
                              <dd>buňka ve slovníkovém hesle, která obsahuje adresu předchozí definice a používá se při vyhledávání ve slovníku.</dd>
                              <dt>Pole Název</dt>
                              <dd>oblast slovníkového hesla, která obsahuje název definovaného slova spolu s počtem znaků v názvu.</dd>
                              <dt>Pad</dt>
                              <dd>oblast paměti v rámci terminálové úlohy, která se používá jako scratchovací oblast pro uchování řetězců znaků pro meziproduktové zpracování.</dd>
                              <dt>Datové pole</dt>
                              <dd>oblast slovníkového hesla, která obsahuje "obsah" definice: pro CONSTANT hodnotu konstanty, pro VARIABLE hodnotu proměnné; pro definici dvojtečky seznam xt slov, která se mají postupně vykonat při provádění definice.</dd>
                              <dt>Kód v době běhu</dt>
                              <dd>rutina zkompilovaná v paměti, která určuje, co se stane, když se provede člen dané třídy slov. Run-time kód pro definici dvojtečky je interpret adresy; run-time kód pro proměnnou vytlačí adresu těla proměnné na zásobník.</dd>
                              <dt>Systémová proměnná</dt>
                              <dd>jedna ze sady proměnných poskytovaných jazykem Forth, na které se odkazuje celý systém (libovolná úloha). V kontrastu s "uživatelskými proměnnými" </dd>.
                              <dt>Úloha</dt>
                              <dd>ve Forthu oddíl v paměti, který obsahuje minimálně zásobník parametrů a návratový zásobník a sadu uživatelských proměnných.</dd>
                              <dt>Uživatelská proměnná</dt>
                              <dd>jedna ze sady proměnných poskytovaných jazykem Forth, jejichž hodnoty jsou pro každou úlohu jedinečné. V kontrastu se "systémovými proměnnými" </dd>.
                              <dt>Vektorované provádění</dt>
                              <dd>způsob specifikace kódu, který má být proveden, tím, že se neuvede adresa samotného kódu, ale adresa umístění, které obsahuje xt kódu. Toto umístění se často nazývá "vektor". Jak se v systému mění okolnosti, lze vektor přenastavit tak, aby ukazoval na nějakou jinou část kódu.</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="aligncenter"><img loading="lazy" width="230" height="100" src="./09-Provedení kódu Forth_files/felix.gif" alt="Programovací jazyk Forth - příklady" class="wp-image-353"></figure>
                           </div>
                           <h3><span id="Problémy_kapitola_9">Problémy - kapitola 9</span></h5>
                           <ol>
                              <li>
                                 Nejprve si zopakujte&nbsp;<a href="https://www.forth.com/starting-forth/2-stack-manipulation-operators-arithmetic/">Kap. 2</a>, Prob. 5. Aniž byste měnili některou z těchto definic, napište slovo POČTY, které umožní soudci volitelně zadat počet počtů u libovolného trestného činu. Například zápis
                                 <pre>ZLOČIN, KTERÝ BYL OBVINĚN Z POKUŠENÍ 3 POČTY DAŇOVÝM PŘESTUPKEM, BUDE-VYŠETŘEN.
</pre>
                                 vypočítá a vypíše rozsudek za jeden případ sázkové kanceláře a tři případy daňového úniku.
                              </li>
                              <li>Jaká je počáteční adresa vašeho soukromého slovníku?</li>
                              <li>Jak daleko je ve vašem systému PAD od začátku vašeho soukromého slovníku?</li>
                           </ol>
                           <div class="wp-block-genesis-blocks-gb-accordion gb-block-accordion gb-font-size-18">
                              <details>
                                 <summary class="gb-accordion-title">Odpovědi</summary>
                                 <div class="gb-accordion-text">
                                    <ol>
                                       <li>
                                          <pre>: COUNTS ' -ROT 0 DO OVER EXECUTE LOOP NIP ;
</pre>
                                       </li>
                                       <li><code>ZDE . </code></li>
                                       <li><code>ZDE - .</code></li>
                                    </ol>
                                 </div>
                              </details>
                           </div>
                        </div>
                     </div>
                  </article>
               </main>
            </div>
         </div>
      </div>
      <div class="site grid-container container hfeed grid-parent" id="page">
         <div class="site-content" id="content">
            <div class="content-area grid-parent mobile-grid-100 grid-70 tablet-grid-70" id="primary">
               <main class="site-main" id="main">
                  <article id="post-340" class="post-340 page type-page status-publish" itemtype="https://schema.org/CreativeWork" itemscope="">
                     <div class="inside-article">
                        <header class="entry-header" aria-label="Content">
                           <h2 class="entry-title" itemprop="headline">10. I/O a vy</h2>
                        </header>
                        <div class="entry-content" itemprop="text">
                           <p>V této kapitole si vysvětlíme, jak jazyk Forth zvládá <abbr title="Pro začátečníky: I/O je zkratka z &#39;input-output,&#39; což označuje data, text nebo signály, které počítač posílá nebo přijímá. Mezi I/O zařízení patří terminály, tiskárny, diskové jednotky, tlačítka atd.">I/O znakových řetězců</abbr> na disk a z disku a terminálu. </p>
                           <p>Konkrétně probereme příkazy pro přístup na disk, výstupní příkazy, příkazy pro manipulaci s řetězci, vstupní příkazy a převod čísel na vstup.</p>
                           <h3><span id="Output_Operators">Výstupní operátory</span></h3>
                           <p>Slovo EMIT převezme na zásobník jednu reprezentaci ASCII, přičemž použije pouze bajt nejnižšího řádu, a vytiskne tento znak na terminál. Například v desítkové soustavě:</p>
                           <pre class="wp-block-preformatted">65 EMIT↵<span class="output"> A ok </span>
66 EMIT↵<span class="output"> B ok </span>

</pre>
                           <p>Slovní příkaz TYPE vypíše na terminál celý řetězec znaků zadaný počáteční adresou řetězce v paměti a počtem v tomto tvaru:</p>
                           <pre class="wp-block-preformatted">( addr u -- )

</pre>
                           <p>V našich definicích formátování čísel jsme již viděli TYPE, aniž bychom se museli starat o adresu a počet, protože jsou automaticky dodávány pomocí #&gt;.</p>
                           <p>Předáme TYPE adresu, o které víme, že obsahuje řetězec znaků. Pamatujete si, že počáteční adresu vstupní vyrovnávací paměti terminálu vrací TIB? Předpokládejme, že zadáme následující příkaz:</p>
                           <pre class="wp-block-preformatted">TIB #TIB @ TYPE

</pre>
                           <p>Tímto zadáme 15 znaků ze vstupní vyrovnávací paměti terminálu, která obsahuje právě zadaný příkaz:</p>
                           <pre class="wp-block-preformatted">TIB #TIB @ TYPE↵<span class="output"> TIB #TIB @ TYPE ok </span>

</pre>
                           <p>Na chvíli odbočíme a podíváme se na fungování .". V době kompilace, když překladač narazí na uvozovku s tečkou, zkompiluje následný řetězec přímo do slovníku, písmeno po písmenu, až po ohraničující dvojitou uvozovku. Aby měl přehled, zkompiluje do slovníkové položky také <em>počet</em> znaků. Vzhledem k definici</p>
                           <pre class="wp-block-preformatted">: TEST ." sample " ;

</pre>
                           <p>a při pohledu na bajty ve slovníku spíše horizontálně než vertikálně, zde je to, co kompilátor sestavil:</p>
                           <figure class="wp-block-image"><img width="384" height="40" src="./10-Vstupní a výstupní operátory_soubory/ch10-TEST-tečka-citace.webp" alt="uložení řetězců ve slovníku Forth" class="wp-image-500"></figure>
                           <p>Pokud bychom chtěli, mohli bychom sami zadat slovo "SAMPLE" (bez provedení příkazu TEST) s větou</p>
                           <pre class="wp-block-preformatted">' TEST &gt;BODY CELL+ 1+ 7 TYPE

</pre>
                           <p>kde</p>
                           <pre class="wp-block-preformatted">' TEST &gt;BODY

</pre>
                           <p>dává nám adresu těla TEST,</p>
                           <pre class="wp-block-preformatted">CELL+ 1+

</pre>
                           <p>přesune nás za adresu a počet na začátek řetězce (písmeno "s") a</p>
                           <pre class="wp-block-preformatted">7 TYPE

</pre>
                           <p>typuje řetězec "sample."</p>
                           <p>Toto malé cvičení se nemusí zdát příliš užitečné. Ale pojďme ještě o krok dál.</p>
                           <p>Pamatujete si, jak jsme v naší aplikaci na určování velikosti vajec definovali LABEL pomocí vnořených příkazů IF...THEN? Můžeme naši definici přepracovat pomocí TYPE. Nejprve zajistíme, aby všechny štítky měly stejnou délku, a "spojíme je" v rámci jedné definice jako pole řetězců. (Nejdelší štítek můžeme zkrátit na "XTRA LRG", takže každý štítek bude mít osm znaků včetně koncové mezery.)</p>
                           <pre class="wp-block-preformatted">: "LABEL" ." REJECT SMALL MEDIUM LARGE XTRA LRGERROR " ;

</pre>
                           <p>Pokud zadáme</p>
                           <pre class="wp-block-preformatted">' "LABEL" &gt;BODY CELL+ 1+

</pre>
                           <p>pro získání adresy začátku řetězce můžeme zadat libovolný konkrétní štítek odsazením do pole. Chceme-li například štítek 2, jednoduše k počáteční adrese přičteme šestnáct (2 x 8) a zadáme osm znaků názvu:</p>
                           <pre class="wp-block-preformatted">16 + 8 TYPE

</pre>
                           <p>Nyní předefinujeme LABEL tak, aby převzal číslo kategorie od nuly do pěti a použil je k indexování do pole řetězců, takto:</p>
                           <pre class="wp-block-preformatted">: LABEL 8 * ['] "LABEL" &gt;BODY CELL+ 1+ + 8 TYPE SPACE ;

</pre>
                           <p>Připomeňte si, že slovo ['] je stejné jako ' s tím rozdílem, že může být použito pouze uvnitř definice pro sestavení adresy dalšího slova v definici (v tomto případě "LABEL"). Později, když provedeme příkaz LABEL, příkaz bracket-tick-bracket následovaný příkazem to-body přenese adresu těla příkazu "LABEL" na zásobník. Přičte se číslo odpovídající CELL+ 1+, pak se přičte řetězcový offset, aby se vypočítala adresa konkrétního jména štítku, které chceme.</p>
                           <p>Tento druh řetězcového pole se někdy nazývá "superřetězec". V rámci konvence pojmenování má název superřetězce obvykle kolem sebe uvozovky. Všimněte si, že tento způsob se v praxi nikdy nepoužívá, protože stejného výsledku lze dosáhnout pomocí zcela přenosného ANS Forthova slova C", a to takto:</p>
                           <pre class="wp-block-preformatted">: "LABEL" C" REJECT SMALL MEDIUM LARGE XTRA LRGERROR " ;
: LABEL 8 * "LABEL" 1+ + 8 TYPE SPACE ;

</pre>
                           <p>Naše nová verze LABELu poběží o něco rychleji, protože nemusí provádět řadu porovnávacích testů, než narazí na číslo, které odpovídá argumentu. Místo toho použije argument k výpočtu adresy příslušného řetězce, který má být zadán.</p>
                           <p>Všimněte si však, že pokud argument LABELu přesáhne rozsah nula až pět, dostanete smetí. Pokud bude LABEL v aplikaci použit pouze v rámci EGGSIZE, není to žádný problém. Pokud jej však bude používat "koncový uživatel", tedy člověk, raději index "ořízněte", například takto:</p>
                           <pre class="wp-block-preformatted">: POPISEK 0 MAX 5 MIN POPISEK ;

</pre>
                           <dl class="forth">
                              <dt>TYP</dt>
                              <dt>( addr u - )</dt>
                              <dd>Přenáší znaky u, začínající na adrese, na aktuální výstupní zařízení.</dd>
                           </dl>
                           <h3><span id="Outputting_Strings_from_Disk">Výstup řetězců z disku</span></h3>
                           <p>Již dříve jsme se zmínili, že slovo BLOCK zkopíruje daný blok do volné vyrovnávací paměti a adresu vyrovnávací paměti ponechá na zásobníku. Pomocí této adresy jako výchozího bodu můžeme indexovat do jednoho z 1 024 bajtů bufferu a zadat libovolný řetězec, který nás zajímá. Chceme-li například vypsat řádek 0 bloku 1, můžeme říci (za předpokladu, že jste provedli příkaz USE blocks.forth)</p>
                           <pre class="wp-block-preformatted">CR 1 BLOCK 64 TYPE↵
<span class="output" style="font-size: 0.8em;"> ok </span>

</pre>
                           <p>Pro vypsání osmého řádku bychom mohli k adrese přidat 512 (8 x 64), například takto:</p>
                           <pre class="wp-block-preformatted">CR 1 BLOCK 512 + 64 TYPE

</pre>
                           <p>Než uvedeme zajímavější příklad, je na čase představit slovo, které s TYPE úzce souvisí.</p>
                           <dl class="forth">
                              <dt>-TRAILING</dt>
                              <dt>( addr u1 - addr u2 )</dt>.
                              <dd>Eliminuje koncové mezery z řetězce, který začíná na adrese, snížením počtu z u1 (původní počet bajtů) na u2 (zkrácený počet bajtů).</dd>
                           </dl>
                           <div class="sc-info-box normal full">
                              <p></p>
                              <h3><span id="Handy_Hint_A_Random_Number_Generator">Handy Hint: Generátor náhodných čísel</span></h5>
                              <p>Tento jednoduchý generátor pseudonáhodných čísel může být užitečný pro hry, i když pro složitější aplikace, jako jsou simulace, jsou k dispozici lepší verze.</p>
                              <pre>( Generování náhodných čísel -- vysoká úroveň )
PROMĚNNÁ rnd ZDE rnd !
: RANDOM rnd @ 31421 * 6927 + DUP rnd ! ;
: CHOOSE ( u1 -- u2 ) RANDOM UM* NIP ;
</pre>
                              <p>kde CHOOSE vrací náhodné celé číslo v rozsahu 0 = nebo &lt; u2 &lt; u1. </p>
                              <p>Tady je návod k použití:</p>
                              <p>Chcete-li vybrat náhodné číslo v rozsahu od nuly do deseti (ale bez deseti), jednoduše zadejte</p>
                              <pre>10 VYBRAT

</pre>
                              <p>a CHOOSE ponechá náhodné číslo na zásobníku.<br></p>
                           </div>
                           <p>-TRAILING lze použít bezprostředně před příkazem TYPE, aby se nevytiskly koncové mezery. Jeho vložením do našeho prvního příkladu výše bychom například získali</p>
                           <pre class="wp-block-preformatted">CR 1 BLOCK 64
-TRAILING TYPE↵
<span class="output"> ok </span>

</pre>
                           <p>Následující příklad používá TYPE</p>
                           <pre class="wp-block-preformatted">Použití blocks.forth
: POOF
  16 CHOOSE 64 *
  2 BLOK +
  CR 64 -TRAILING
  TYP ;

</pre>
                           <p>zkuste to:</p>
                           <pre class="wp-block-preformatted">POOF↵
<span class="output">kvalifikovaný v pořádku </span>
POOF↵
<span class="output">flexibilní ok </span>
POOF↵
<span class="output">celkem ok </span>

</pre>
                           <h3><span id="Internal_String_Operators">Interní řetězcové operátory</span></h3>
                           <p>Příkazy pro přesun řetězců znaků nebo datových polí jsou velmi jednoduché. Každý z nich vyžaduje tři argumenty: zdrojovou adresu, cílovou adresu a počet.</p>
                           <dl class="forth">
                              <dt>CMOVE</dt>
                              <dt>( addr1 addr2 u - )</dt>
                              <dd>Kopíruje oblast paměti dlouhou u bajtů, bajt po bajtu začínající na adrese addr1, do paměti začínající na adrese addr2. Přesun začíná obsahem addr1 a pokračuje směrem k vyšší paměti.</dd>
                              <dt>Přesun&gt;</dt>
                              <dt>( addr1 addr2 u - )</dt>
                              <dd>Je-li u větší než nula, zkopíruje se u po sobě jdoucích znaků z datového prostoru začínajícího na adrese c-addr1 do prostoru začínajícího na adrese c-addr2, přičemž se postupuje znak po znaku od vyšších adres k nižším adresám.</dd>
                              <dt>Přesun</dt>
                              <dt>( addr1 addr2 u - )</dt>
                              <dd>Po tomto přesunu obsahují bajty u na adrese addr2 přesně to, co obsahovaly bajty u na adrese addr1 před přesunem (nedochází k žádnému "clobberingu").</dd>
                           </dl>
                           <p>Všimněte si, že tyto příkazy dodržují určité konvence, se kterými jsme se již setkali:</p>
                           <ul>
                              <li>Pokud argumenty obsahují zdroj a cíl, zdroj předchází cíli.</li>
                              <li>Když argumenty obsahují adresu a počet (jako je tomu u příkazu TYPE), adresa předchází počtu.</li>
                           </ul>
                           <p>A tak u těchto tří slov jsou argumenty</p>
                           <pre class="wp-block-preformatted">( source destination count -- )

</pre>
                           <p>Chceme-li například přesunout celý obsah vyrovnávací paměti do PAD, napíšeme</p>
                           <pre class="wp-block-preformatted">210 BLOCK PAD 1024 CMOVE

</pre>
                           <p>Ačkoli na strojích s adresou buňky by přesun mohl být rychlejší, kdyby probíhal po jednotlivých buňkách, například takto:</p>
                           <pre class="wp-block-preformatted">210 BLOCK PAD 1024 MOVE

</pre>
                           <p>Slovo CMOVE&gt; umožňuje přesunout řetězec do oblasti, která je v paměti výše, ale která překrývá zdrojovou oblast.</p>
                           <p>Pokud byste použili CMOVE, první písmeno řetězce by se zkopírovalo do druhého bajtu, ale tím by se "zaklopilo" druhé písmeno řetězce. Konečným výsledkem by byl řetězec složený z jediného znaku.</p>
                           <ul class="wp-block-gallery columns-2">
                              <li class="blocks-gallery-item">
                                 <figure><img loading="lazy" width="140" height="273" src="./10-Vstupní a výstupní operátory_soubory/ch10-CMOVE.gif" alt="" data-id="501" data-link="https://www.forth.com/starting-forth/10-input-output-operators/ch10-cmove/#main" class="wp-image-501"></figure>
                              </li>
                              <li class="blocks-gallery-item">
                                 <figure><img loading="lazy" width="140" height="269" src="./10-Input and Output Operators_files/ch10-CMOVEto.gif" alt="" data-id="502" data-link="https://www.forth.com/starting-forth/10-input-output-operators/ch10-cmoveto/#main" class="wp-image-502"></figure>
                              </li>
                           </ul>
                           <p>Použití CMOVE&gt; v této situaci zabrání tomu, aby se řetězec během přesunu sám od sebe zkomolil.</p>
                           <p>Jistě jste si všimli, že CMOVE lze použít k vyplnění pole určitým bajtem. Ve starších systémech mohlo být pomocí tohoto triku definováno slovo FILL, které jsme si představili dříve. Na moderních Forthách se doporučuje explicitně použít FILL, pokud je vyplnění to, co chcete provést. Chceme-li například do 1024 bajtů padu uložit prázdná místa, řekneme</p>
                           <pre class="wp-block-preformatted">PAD 1024 CHAR BL FILL

</pre>
                           <h3><span id="Jednoznakový_vstup">Jednoznakový vstup</span></h3>
                           <p>Slovo KEY čeká na zadání jediné klávesy z klávesnice terminálu a ponechá ekvivalent znaku ASCII na zásobníku v bajtu nejnižšího řádu.</p>
                           <p>Chcete-li jej provést přímo, musíte za ním následovat návrat, například takto:</p>
                           <pre class="wp-block-preformatted">KEY↵

</pre>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="183" src="./10-Vstupní a výstupní operátory_soubory/ch10-KEY.gif" alt="přijmout vstupní znak" class="wp-image-503"></figure>
                           <p>Kurzor se posune o mezeru, ale terminál <em>nevypíše</em> "ok"; čeká na váš vstup. Stiskněte například písmeno "A" a na obrazovce se "ozve" písmeno "A", po kterém bude následovat "ok". Hodnota ASCII je nyní na zásobníku, takže zadejte .:</p>
                           <pre class="wp-block-preformatted">KEY A↵<span class="output"> ok </span>
.↵<span class="output"> 65 ok </span>

</pre>
                           <p>Takto nemusíte hledat v tabulce, abyste zjistili kód ASCII znaku.</p>
                           <p> Uvnitř definice můžete také uvést KEY. Vykonávání definice se při výskytu KEY zastaví, dokud není přijat vstupní znak. Například následující definice vypíše daný počet bloků za sebou, počínaje aktuálním blokem, a počká na stisknutí libovolné klávesy, než vypíše další:</p>
                           <pre class="wp-block-preformatted">: BLOKY ( count -- )
        SCR @ + SCR @ DO I SEZNAM KLÁVES DROP LOOP ;

</pre>
                           <p>V tomto případě zahodíme hodnotu ponechanou u KEY, protože nás nezajímá, jaká je.</p>
                           <p>Nebo můžeme přidat funkci, která nám umožní buď kdykoli opustit smyčku stiskem klávesy return, nebo pokračovat stiskem jakékoli jiné klávesy, například jako mezerník. V takovém případě provedeme podmíněný test na hodnotě vrácené klávesou KEY.</p>
                           <pre class="wp-block-preformatted">13 KONSTANT #EOL<br><br>: BLOKY ( count -- ) SCR @ + SCR @ DO<br> I LIST<br> KEY #EOL = ( cr) IF LEAVE THEN<br> LOOP ;</pre>
                           <p>Všimněte si, že v některých systémech Forth je klávesa carriage-return přijímána jako řádkový znak (10) nebo jako nula (nula).</p>
                           <dl class="forth">
                              <dt>KEY</dt>
                              <dt>( - char )</dt>
                              <dd>Vrací ASCII hodnotu dalšího dostupného znaku z aktuálního vstupního zařízení.</dd>
                           </dl>
                           <h3><span id="String_Input_Commands_from_the_Bottom_up">Příkazy řetězcového vstupu, odspodu nahoru</span></h3>
                           <p>S řetězcovým vstupem souvisí několik slov. Začneme od těch nejnižších a přejdeme k některým slovům vyšší úrovně.</p>
                           <dl class="forth">
                              <dt>PŘIJMOUT</dt>
                              <dt>( addr u1 - u2 )</dt>
                              <dd>Přijme z klávesnice terminálu znaky u1 (nebo do návratu vozíku) a uloží je, počínaje adresou. Vrátí se počet přijatých znaků.</dd>
                              <dt>Slovo</dt>
                              <dt>( char - addr )</dt>
                              <dd>Zpracuje jedno slovo ze vstupního proudu, přičemž jako oddělovač použije znak (obvykle prázdný). Přesune řetězec na adresu ZDE s počítadlem v prvním bajtu, přičemž adresu ponechá na zásobníku.</dd>
                           </dl>
                           <p>Slovo ACCEPT zastaví provádění úlohy a čeká na vstup z klávesnice. Očekává daný počet stisků kláves nebo návrat vozíku, podle toho, co přijde dříve. Příchozí text se uloží počínaje adresou uvedenou jako argument, na zásobník se vrátí počet přijatých znaků.</p>
                           <p>Například věta</p>
                           <pre class="wp-block-preformatted">TIB 80 ACCEPT

</pre>
                           <p>očekává až osmdesát znaků a uloží je do vstupní vyrovnávací paměti terminálu (TIB). (Ukládání přímo do TIB není standardní, ale např. iForth s touto tradicí nemá problém)</p>.
                           <p>Tato věta se používá v definici QUIT pro získání vstupu pro INTERPRET.</p>
                           <p>Přejděme k dalšímu operátoru vstupu řetězce vyšší úrovně. Právě jsme si vysvětlili, že QUIT obsahuje frázi</p>
                           <pre class="wp-block-preformatted">... TIB 80 ACCEPT #TIB !  INTERPRET ...

</pre>
                           <p>Jak ale textový interpret prohledá vstupní buffer terminálu a vybere v něm každé jednotlivé slovo? Pomocí fráze</p>
                           <pre class="wp-block-preformatted">BL WORD

</pre>
                           <p>WORD prohledá vstupní proud a hledá zadaný oddělovač, v tomto případě mezeru, a přesune podřetězec do jiného vlastního bufferu s počtem v prvním bajtu bufferu. Nakonec zanechá adresu bufferu na zásobníku, aby INTERPRET (nebo kdokoli jiný) věděl, kde jej má hledat. Vyrovnávací paměť WORD obvykle začíná ZDE, takže uvedená adresa je ZDE.</p>
                           <p>WORD vyhledá zadaný oddělovač ve vstupní vyrovnávací paměti terminálu a přesune podřetězec do vyrovnávací paměti WORD s počtem v prvním bajtu.</p>
                           <div class="wp-block-image">
                              <figure class="alignright">
                                 <img width="200" height="115" src="./10-Vstupní a výstupní operátory_soubory/ch10-toIN.webp" alt="&gt;IN - ukazatel vstupního bufferu" class="wp-image-504″/&gt;&lt;/figure&gt;&lt;/div&gt;
                                    &lt;p&gt;Když spouštíte slova přímo z terminálu, WORD prohledá vstupní vyrovnávací paměť počínaje TIB. Při tom posune vstupní buffer o &lt;em&gt;ukazatel&lt;/em&gt;, zvaný &gt;IN, takže při každém spuštění WORDu se skenuje &lt;em&gt;další&lt;/em&gt; slovo ve vstupním proudu. WORD ví, že skenování ukončí, když &gt;IN @ bude větší než #TIB @, počet přijatých znaků.&lt;/p&gt;
                                    &lt;p&gt;&gt;IN je "relativní ukazatel"; to znamená, že neobsahuje skutečnou adresu, ale spíše offset, který má být přičten ke skutečné adrese, což je v tomto případě TIB. Například poté, co WORD naskenuje řetězec "STAR", je hodnota &gt;IN pět.&lt;/p&gt;
                                    &lt;figure class=" wp-block-image"=""><img width="400" height="142" src="./10-Input and Output Operators_files/ch10-input-buffer.webp" alt="oddělovací znaky ve vstupní vyrovnávací paměti a &gt;IN" class="wp-image-505″/&gt;&lt;/figure&gt;
                                    &lt;p&gt;WORD ignoruje počáteční výskyty oddělovače (dokud nenarazí na jiný znak). Můžete zadat&lt;/p&gt;
                                    &lt;pre class=" wp-block-preformatted"="">STAR
                                 <p>(tj. STAR, před kterým je několik mezer) a ve vyrovnávací paměti WORD získáte přesně stejný řetězec, jak je uvedeno výše.</p>
                                 <p>K WORDu se vrátíme později v této kapitole. Prozatím však definujme slovo, které používá WORD a které je užitečnější pro zpracování řetězcového vstupu:</p>
                                 <pre class="wp-block-preformatted">: TEXT ( delimiter -- ) PAD 258 BL FILL WORD COUNT PAD SWAP MOVE ;

</pre>
                                 <p>TEXT, stejně jako WORD, vezme oddělovač a prohledává vstupní proud, dokud nenajde jím ohraničený řetězec. Poté řetězec přesune na pad. Na TEXTu je obzvláště příjemné, že před přesunem řetězce pad zaslepí. Díky tomu je velmi vhodný pro použití s TYPE. Zde je jednoduchý příklad:</p>
                                 <pre class="wp-block-preformatted">CREATE moje-jméno 40 ALLOT<br>: I M BL TEXT PAD moje-jméno 40 MOVE ;</pre>
                                 <p>V prvním řádku definujeme pole s názvem my-name. Ve druhém řádku definujeme slovo s názvem I'M, které nám umožní zadat</p>
                                 <pre class="wp-block-preformatted">I'M EDWARD↵<span class="output"> ok </span>

</pre>
                                 <p>Definice slova I'M se rozpadá takto: věta</p>
                                 <pre class="wp-block-preformatted">BL TEXT

</pre>
                                 <p>prohledá zbytek vstupního proudu a hledá mezeru nebo konec řádku podle toho, co nastane dříve. (Oddělovač, který dáváme TEXT, ve skutečnosti používá WORD, který je obsažen v definici TEXT.) TEXT pak přesune větu na pěkně čistý "pad".</p>
                                 <p>Výraz</p>
                                 <pre class="wp-block-preformatted">PAD my-name 40 MOVE

</pre>
                                 <p>přemístí čtyřicet bajtů z padu do pole nazvaného my-name, kde bezpečně zůstane tak dlouho, jak budeme potřebovat.</p>
                                 <p>Nyní bychom mohli definovat GREET takto:</p>
                                 <pre class="wp-block-preformatted">: GREET ." Ahoj, " moje-jméno 40 -TRAILING TYPE ." , mluvím forthsky. " ;

</pre>
                                 <p>takže provedením příkazu GREET získáme</p>
                                 <pre class="wp-block-preformatted">GREET↵<span class="output"> Ahoj, EDWARD, mluvím jazykem Forth. ok </span>

</pre>
                                 <p>Naneštěstí naše definice I'M hledá jako oddělovač mezeru. To znamená, že osoba se jménem Mary Kay nedostane své celé jméno do my-name.</p>
                                 <p>Chceme-li získat kompletní vstupní proud, nechceme "vidět" vůbec žádný oddělovač, kromě konce řádku. Místo "BL TEXT" bychom měli použít větu</p>
                                 <pre class="wp-block-preformatted">1 TEXT

</pre>
                                 <p>ASCII 1 je řídicí znak, který nebude odeslán z klávesnice, a proto se neobjeví ve vstupní vyrovnávací paměti. Proto je "1 TEXT" konvence používaná pro načtení celého vstupního bufferu až po návrat vozíku. Předefinováním I'M tímto způsobem může Mary Kay dostat své jméno do my-name, mezeru a vše.</p>
                                 <p>Pomocí jiných oddělovačů, například čárek, můžeme "přijmout" řadu řetězců a každý z nich uložit do jiného pole pro různé účely. Vezměme si tento příklad, ve kterém slovo VITALS používá čárky jako oddělovače k oddělení tří vstupních polí:</p>
                                 <pre class="wp-block-preformatted">( Formulář milostného dopisu )<br>Vytvořte jméno 14 ALLOT<br>Vytvořte oči 12 ALLOT<br>Vytvořte mě 14 ALLOT<br><br>: VITALS<br> [CHAR] , TEXT PAD name 14 MOVE<br> [CHAR] , TEXT PAD eyes 12 MOVE<br> 1 TEXT PAD me 14 MOVE ;<br><br>: LETTER PAGE ." Vážený " jméno 14 -TIP POJIŠTĚNÍ ." ,"<br> CR ." Jdu do nebe, kdykoli vidím tvé hluboké " <br> oči 12 -TRAILING TYPE ." oči. Můžeš <br> CR ." jít v pátek do kina? "<br> CR 30 MÍST ." S láskou, "<br> CR 30 SPACES me 14 -TRAILING TYPE<br> CR ." P.S. Vezmi si na sebe něco " oči 12 -TRAILING TYPE<br> .", ať se těma očima můžeš pochlubit! " ;</pre>
                                 <p>Který vám umožní vstoupit</p>
                                 <pre class="wp-block-preformatted">VITÁŽE Alice,modrá,Fred↵<span class="output"> ok </span>

</pre>
                                 <p>tedy enter</p>
                                 <pre class="wp-block-preformatted">LETTER

</pre>
                                 <p>Vždy to funguje.</p>
                                 <p>Dosud byl veškerý náš vstup ve stylu "Forth"; to znamená, že čísla <em>předcházejí</em> příkazy (takže příkaz najde své číslo na zásobníku) a řetězce <em>následují</em> příkazy (takže příkaz najde svůj řetězec ve vstupním proudu). Tento styl využívá jednu z jedinečných vlastností jazyka Forth: čeká na vaše příkazy, nevyzývá vás k nim.</p>
                                 <p>Pokud však chcete, můžete do definice vložit ACCEPT, aby si od vás pod kontrolou definice vyžádala vstup. Můžeme například spojit dvě slova JÁ a VÍM do jediného slova, které "vyzve" uživatele k zadání jména. Například,</p>
                                 <pre class="wp-block-preformatted">GREET↵
<span class="output">Jak se jmenujete? </span>

</pre>
                                 <p>v tomto okamžiku se provádění zastaví, aby uživatel mohl zadat jméno:</p>
                                 <pre class="wp-block-preformatted">GREET↵
<span class="output">Jak se jmenujete?</span>Travis Mc Gee↵
<span class="output">Dobrý den, Travis Mc Gee, mluvím Forth. ok </span>

</pre>
                                 <p>Mohli bychom to udělat takto:</p>
                                 <pre class="wp-block-preformatted">: GREET CR ." Jak se jmenuješ?"
       TIB 40 ACCEPT #TIB !  0 &gt;IN !
       1 TEXT CR ." Dobrý den, "
       PAD 40 -TRAILING TYPE ." , mluvím jazykem Forth. " ;

</pre>
                                 <p>Vysvětlili jsme všechny věty ve výše uvedené definici kromě této:</p>
                                 <pre class="wp-block-preformatted">#TIB !  0 &gt;IN !

</pre>
                                 <p>Pamatujte si, že TEXT, protože používá WORD, vždy používá &gt;IN jako referenční bod. Když však uživatel zadá slovo GREET, aby provedl tuto definici, bude řetězec GREET uložen ve vstupní vyrovnávací paměti terminálu a &gt;IN bude ukazovat za "GREET". ACCEPT <em>nepoužívá</em> &gt;IN jako svůj referenční bod, takže uloží uživatelovo jméno začínající na TIB, nad GREET. Pokud byste <em>teď</em> provedli TEXT, vynechalo by se prvních pět písmen uživatelova jména. Je nutné vynulovat hodnotu &gt;IN, aby se TEXT podíval tam, kam ACCEPT jméno uložil.</p>
                                 <h3><span id="Number_Input_Conversion">Převod číselného vstupu</span></h3>
                                 <p>Když na terminálu zadáte číslo, Forth automaticky převede tento řetězec znaků na binární hodnotu a posune ji na zásobník. Jazyk Forth také poskytuje příkaz, který vám umožní převést znakový řetězec začínající na <em>libovolném</em> místě paměti na binární hodnotu.</p>
                                 <dl class="forth">
                                    <dt>&gt;ČÍSLO</dt>
                                    <dt>( ud1 addr1 u1 - ud2 addr2 u2 )</dt>
                                    <dd>Vrácená hodnota ud2 je nepodepsaný výsledek převodu znaků v řetězci zadaném addr1 u1 na číslice pomocí čísla v BASE a přičtení každé z nich do ud1 po vynásobení ud1 číslem v BASE. Převod pokračuje zleva doprava, dokud nenarazíte na znak, který nelze převést, včetně jakéhokoli "+" nebo "-", nebo dokud není řetězec zcela převeden. Adresa addr2 je umístění prvního nekonvertovaného znaku nebo prvního znaku za koncem řetězce, pokud byl řetězec zcela konvertován. Délka u2 je počet nekonvertovaných znaků v řetězci.</dd>
                                 </dl>
                                 <p>Tady je příklad, který používá &gt;ČÍSLO:</p>
                                 <pre class="wp-block-preformatted">: PLUS 0. BL WORD COUNT &gt;NUMBER 2DROP DROP + ." = " . ;

</pre>
                                 <p>PLUS nám umožňuje dokázat každému skeptikovi, že Forth by mohl používat infixový zápis, kdyby chtěl. Můžeme zadat</p>
                                 <pre class="wp-block-preformatted">2 PLUS 13↵<span class="output"> = 15 ok </span>

</pre>
                                 <p>Při provedení příkazu PLUS se "2" dostane na zásobník v binární podobě, zatímco "3" bude stále ve vstupním proudu jako řetězec. Výraz</p>
                                 <pre class="wp-block-preformatted">0. BL WORD

</pre>
                                 <p>přečte řetězec a poskytne akumulátor pro &gt;NUMBER; &gt;NUMBER jej převede na binární tvar a na zásobník vloží výsledek o dvojnásobné délce plus nepřevedený řetězec. Řetězec a horní polovinu dvojnásobně dlouhého výsledku zahodíme. Nyní + sečte obě jednovětné hodnoty a . vypíše výsledek.</p>
                                 <p>Poznamenejte, že pomocí &gt;NUMBER můžete vytvořit vlastní specializované procedury pro převod vstupních čísel. Protože &gt;NUMBER vrací adresu prvního nepřeveditelného znaku, můžete se rozhodovat podle toho, zda je znakem pomlčka, tečka nebo cokoli jiného. Můžete se také rozhodovat na základě umístění nepřevoditelného znaku v rámci čísla. Například můžete napsat rutinu, která vám umožní zadat číslo s desetinnou tečkou a pak jej odpovídajícím způsobem škáluje.</p>
                                 <h3><span id="A_Closer_Look_at_WORD">Podívejte se blíže na WORD</span></h3>
                                 <p>Dosud jsme hovořili pouze o použití WORDu ke skenování vstupní vyrovnávací paměti <em>terminálu</em> (v níž jsou uloženy znaky, které jsou z terminálu PŘIJÍMÁNY). Pokud si však připomeneme, že věta</p>
                                 <pre class="wp-block-preformatted">BL WORD

</pre>
                                 <p>používá textový interpret, uvědomíme si, že WORD ve skutečnosti prohledává vstupní <em>stream</em>, což je buď vstupní buffer terminálu, vyhodnocovaný řetězec, nebo paměť disku, do které se vkládá nebo vkládá.</p>
                                 <p>Pro dosažení této flexibility používá WORD kromě ukazatele &gt;IN i další ukazatele. Ostatní ukazatele zajišťují, že se WORD podívá do paměti (když provádí EVALUATE), na disk (když provádí LOAD nebo INCLUDED) nebo do vstupního bufferu terminálu.</p>
                                 <p>Užitečným slovem, které lze použít ve spojení s WORD, je COUNT. Připomeňme, že WORD ponechává délku slova v prvním bajtu vyrovnávací paměti WORD a také ponechává <em>adresu</em> tohoto bajtu na zásobníku.</p>
                                 <figure class="wp-block-image"><img loading="lazy" width="300" height="89" src="./10-Vstupní a výstupní operátory_files/ch10-COUNT-1.gif" alt="výstupní operátory - WORD a COUNT" class="wp-image-506"></figure>
                                 <p>Slovo COUNT umístí počet na zásobník a zvýší adresu takto:</p>
                                 <figure class="wp-block-image"><img loading="lazy" width="300" height="88" src="./10-Vstupní a výstupní operátory_soubory/ch10-COUNT-2.gif" alt="výstupní operátory - WORD a COUNT" class="wp-image-507"></figure>
                                 <p>Odchod ze zásobníku s adresou řetězce a počtem jako příslušnými argumenty pro TYPE, MOVE atd.</p>
                                 <p>COUNT se používá v definici TEXT, kterou jsme uvedli o několik částí zpět.</p>
                                 <dl class="forth">
                                    <dt>COUNT</dt>
                                    <dt>( addr1 - addr2 u )</dt>
                                    <dd>Převede řetězec znaků, jehož délka je obsažena v jeho prvním bajtu, do tvaru vhodného pro TYPE, přičemž adresu prvního znaku a délku ponechá na zásobníku.</dd>
                                 </dl>
                                 <p>Použití funkce WORD si dále ukážeme na jednom z příkladů v <a href="https://www.forth.com/starting-forth/12-forth-code-examples/">kapitole 12</a>.</p>
                                 <h3><span id="String_Comparisons">Porovnávání řetězců</span></h3>
                                 <p>Tady je slovo Forth, které můžete použít k porovnávání řetězců znaků:</p>
                                 <dl class="forth">
                                    <dt>SROVNÁVÁNÍ</dt>
                                    <dt>( addr1 u1 addr2 u2 - n )</dt>
                                    <dd>Porovná řetězec zadaný pomocí addr1 a u1 s řetězcem zadaným pomocí addr2 a u2. Řetězce se porovnávají, počínaje zadanými adresami, znak po znaku až do délky kratšího řetězce, nebo dokud se nenajde rozdíl. Pokud jsou oba řetězce až do délky kratšího řetězce stejné, pak je delší řetězec větší než kratší. n je -1, pokud je řetězec zadaný adresou addr1 a u1 menší než řetězec zadaný adresou addr2 a u2. n je nula, pokud jsou řetězce stejné. n je 1, pokud je řetězec zadaný adresou addr1 a u1 větší než řetězec zadaný adresou addr2 a u2.</dd>
                                 </dl>
                                 <p>COMPARE lze použít k testování, zda se dva znakové řetězce rovnají nebo zda je jeden z nich abecedně větší nebo menší než druhý.</p>
                                 <h3><span id="Chapter_Summary">Shrnutí kapitoly</span></h3>
                                 <h3><span id="Předposlední_slova">Předposlední slova</span></h5>
                                 <p>Tady je seznam slov Forth, která jsme probrali v této kapitole:</p>
                                 <dl class="forth">
                                    <dt>TYP</dt>
                                    <dt>( addr u - )</dt>
                                    <dd>Přenáší znaky u, začínající na adrese, na aktuální výstupní zařízení.</dd>
                                    <dt>-TRAILING</dt>
                                    <dt>( addr u1 - addr u2 )</dt>
                                    <dd>Eliminuje koncové mezery z řetězce začínajícího na adrese snížením počtu z u1 (původní počet bajtů) na u2 (zkrácený počet bajtů).</dd>
                                    <dt>CMOVE</dt>
                                    <dt>( addr1 addr2 u - )</dt>
                                    <dd>Kopíruje oblast paměti dlouhou u bajtů, bajt po bajtu začínající na addr1, do paměti začínající na addr2. Přesun začíná obsahem addr1 a pokračuje směrem k vyšší paměti.</dd>
                                    <dt>Přesun&gt;</dt>
                                    <dt>( addr1 addr2 u - )</dt>
                                    <dd>Je-li u větší než nula, zkopíruje se u po sobě jdoucích znaků z datového prostoru začínajícího na adrese c-addr1 do prostoru začínajícího na adrese c-addr2, přičemž se postupuje znak po znaku od vyšších adres k nižším adresám.</dd>
                                    <dt>Přesun</dt>
                                    <dt>( addr1 addr2 u - )</dt>
                                    <dd>Po tomto přesunu obsahují bajty u na adrese addr2 přesně to, co obsahovaly bajty u na adrese addr1 před přesunem (nedochází k žádnému "clobberingu").</dd>
                                    <dt>KEY</dt>
                                    <dt>( - char )</dt>
                                    <dd>Vrací ASCII hodnotu dalšího dostupného znaku z aktuálního vstupního zařízení.</dd>
                                    <dt>ACCEPT</dt>
                                    <dt>( addr u1 - u2 )</dt>
                                    <dd>Přijme znaky u1 (nebo do návratu vozíku) z klávesnice terminálu a uloží je, počínaje adresou. Vrátí se počet přijatých znaků.</dd>
                                    <dt>Slovo</dt>
                                    <dt>( char - addr )</dt>
                                    <dd>Zpracuje jedno slovo ze vstupního proudu, přičemž jako oddělovač použije znak (obvykle prázdný). Přesune řetězec na adresu ZDE s počítadlem v prvním bajtu, přičemž adresu ponechá na zásobníku.</dd>
                                    <dt>&gt;ČÍSLO</dt>
                                    <dt>( ud1 addr1 u1 - ud2 addr2 u2 )</dt>
                                    <dd>Vrácená hodnota ud2 je nepodepsaný výsledek převodu znaků v řetězci zadaném addr1 u1 na číslice pomocí čísla v BASE a přičtení každé z nich do ud1 po vynásobení ud1 číslem v BASE. Převod pokračuje zleva doprava, dokud nenarazíte na znak, který nelze převést, včetně jakéhokoli "+" nebo "-", nebo dokud není řetězec zcela převeden. Adresa addr2 je umístění prvního nekonvertovaného znaku nebo prvního znaku za koncem řetězce, pokud byl řetězec zcela konvertován. Délka u2 je počet nekonvertovaných znaků v řetězci.</dd>
                                    <dt>SOUČET</dt>
                                    <dt>( addr1 - addr2 u )</dt>
                                    <dd>Převede řetězec znaků, jehož délka je obsažena v jeho prvním bajtu, do tvaru vhodného pro TYPE tak, že na zásobníku ponechá adresu prvního znaku a délku.</dd>
                                    <dt>KOMPARACE</dt>
                                    <dt>( addr1 u1 addr2 u2 - n )</dt>
                                    <dd>Porovná řetězec zadaný pomocí addr1 a u1 s řetězcem zadaným pomocí addr2 a u2. Řetězce se porovnávají, počínaje zadanými adresami, znak po znaku až do délky kratšího řetězce, nebo dokud se nenajde rozdíl. Pokud jsou oba řetězce až do délky kratšího řetězce stejné, pak je delší řetězec větší než kratší. n je -1, pokud je řetězec zadaný adresou addr1 a u1 menší než řetězec zadaný adresou addr2 a u2. n je nula, pokud jsou řetězce stejné. n je 1, pokud je řetězec zadaný adresou addr1 a u1 větší než řetězec zadaný adresou addr2 a u2.</dd>
                                 </dl>
                                 <h3><span id="Review_of_Terms">Přehled termínů</span></h5>
                                 <dl>
                                    <dt>Relativní ukazatel</dt>
                                    <dd>Proměnná, která určuje umístění vzhledem k začátku pole nebo řetězce - nejedná se o absolutní adresu.</dd>
                                    <dt>Nadřetězec</dt>
                                    <dd>V jazyce Forth pole znaků, které obsahuje řadu řetězců. K libovolnému řetězci lze přistupovat indexováním do pole.</dd>
                                    <dt>Virtuální paměť</dt>
                                    <dd>Zacházení s velkokapacitní pamětí (například diskem), jako by to byla rezidentní paměť; také mechanismus operačního systému, který toto zacházení umožňuje.</dd>
                                 </dl>
                                 <div class="wp-block-image">
                                    <figure class="aligncenter"><img loading="lazy" width="230" height="100" src="./10-Vstupní a výstupní operátory_soubory/felix.gif" alt="Programovací jazyk Forth - příklady" class="wp-image-353"></figure>
                                 </div>
                                 <h3><span id="Problémy_Kapitola_10">Problémy - kapitola 10</span></h5>
                                 <ol class="sf-numbered">
                                    <li>
                                       Podle starobylé legendy obdařuje Buddha všechny osoby narozené v každém roce zvláštními, užitečnými vlastnostmi, které představuje jedno z dvanácti zvířat. Každému roku vládne jiné zvíře a každých dvanáct let se cyklus opakuje. Například o osobách narozených v roce 1900 se říká, že se narodily v "roce krysy". Umění věštit na základě těchto vlivů natálního roku se nazývá "Juneeshee"."<br>Tady je pořadí cyklu:<br>Krysa, Vůl, Tygr, Králík, Drak, Had, Kůň, Beran, Opice, Kohout, Pes, Kanec. Napište slovo .ZVÍŘE, které napíše jméno zvířete odpovídající jeho postavení v cyklu, jak je zde uvedeno; např,
                                       <pre>0 .ANIMAL↵<span class="output"> RAT ok </span></pre>
                                    </li>
                                    <li>
                                       <p>Nyní napište slovo s názvem (JUNEESHEE), které bere jako argument rok narození a vypíše jméno přidruženého zvířete. (1900 je rok narození krysy, 1901 je rok narození vola atd.<br></p>)<br></p>
                                    </li>
                                    <li>
                                       <p>Nakonec napište slovo JUNEESHEE, které se uživatele zeptá na jeho rok narození a vypíše jméno zvířete, které se k dané osobě v červnu narodilo. Definujte jej tak, aby uživatel nemusel po zadání roku stisknout klávesu "return".&nbsp;</p>
                                    </li>
                                 </ol>
                                 <div class="wp-block-genesis-blocks-gb-accordion gb-block-accordion gb-font-size-18">
                                    <details>
                                       <summary class="gb-accordion-title">Odpovědi</summary>
                                       <div class="gb-accordion-text">
                                          <ol>
                                             <li>
                                                <pre>: ANIMALS ( -- addr )
   C" krysa vůl tygr králíkdrakohub kůň beran opicekohout pes kanec " ;

: .ANIMAL ( index -- )
   6 * ZVÍŘATA 1+ + 6 -VLEČNÝ TYP ;
</pre>
                                             </li>
                                             <li>
                                                <pre>: (JUNEESHEE) ( rok -- )
   1900 - 12 MOD ." Narodili jste se v roce "
   .ZVÍŘE [ZNAK] . EMIT CR ;
</pre>
                                             </li>
                                             <li>
                                                <pre>: DIGIT ( -- číslice ) KEY DUP EMIT [CHAR] 0 - ;

: YEAR ( -- rok ) ( doufejme, že zadá správné číslice! )
   0 4 0 DO 10 * DIGIT + LOOP ;

: JUNEESHEE
   CR ." V jakém roce jste se narodili? " ROK CR (JUNEESHEE) ;
</pre>
                                             </li>
                                          </ol>
                                       </div>
                                    </details>
                                 </div>
                              </figure>
                           </div>
                        </div>
                     </div>
                  </article>
               </main>
            </div>
         </div>
      </div>
      <div class="site grid-container container hfeed grid-parent" id="page">
         <div class="site-content" id="content">
            <div class="content-area grid-parent mobile-grid-100 grid-70 tablet-grid-70" id="primary">
               <main class="site-main" id="main">
                  <article id="post-344" class="post-344 page type-page status-publish" itemtype="https://schema.org/CreativeWork" itemscope="">
                     <div class="inside-article">
                        <header class="entry-header" aria-label="Content">
                           <h2 class="entry-title" itemprop="headline">11. Rozšíření překladače</h2>
                        </header>
                        <div class="entry-content" itemprop="text">
                           <p>V porovnání s běžnými jazyky je překladač jazyka Forth zcela zaostalý. Tradiční kompilátory jsou obrovské programy určené k překladu libovolné předvídatelné, legální kombinace dostupných operátorů do strojového jazyka. Ve Forthu však většinu práce při kompilaci vykonává jediná definice, dlouhá jen několik řádků. Speciální struktury, jako jsou podmínky a cykly, nekompiluje kompilátor, ale kompilovaná slova (IF, DO atd.)</p>
                           <p>Abyste se jednoduchým způsobům jazyka Forth nevysmívali, všimněte si, že Forth je mezi jazyky jedinečný v tom, jak snadno můžete kompilátor rozšířit. Definování nových, specializovaných kompilátorů je stejně snadné jako definování jakéhokoli jiného slova, jak brzy uvidíte.</p>
                           <p>Když máte rozšiřitelný kompilátor, máte velmi silný jazyk!</p>
                           <h3 id="h-just-a-question-of-time"><span id="Just_a_Question_of_Time">Jen otázka času</span></h3>
                           <p>Než se naplno pustíme do této kapitoly, zopakujme si jeden konkrétní pojem, který může začínajícím programátorům jazyka Forth činit problémy. Je to otázka času.</p>
                           <p>Používali jsme termín "čas běhu", když jsme mluvili o věcech, které se dějí, když je slovo <em>vykonáno</em>, a "čas kompilace", když jsme mluvili o věcech, které se dějí, když je slovo <em>kompilováno</em>. Zatím je to dobré. Věci se ale trochu zamotají, když se jedno slovo chová jak v době běhu, tak v době kompilace.</p>
                           <p>Obecně existují dvě třídy slov, která se chovají oběma způsoby. Pro účely této diskuse budeme tyto dvě třídy nazývat "definující slova" a "kompilující slova" </p>.
                           <p>Definiční slovo je slovo, které po provedení sestaví novou definici. Definující slovo určuje chování každého člena "rodiny" slov, které definuje, v době kompilace a v době běhu. Na příkladu definičního slova CONSTANT, když řekneme</p>
                           <pre class="wp-block-preformatted">80 CONSTANT MARGIN</pre>
                           <p>spustíme <em>chování CONSTANT v době kompilace</em>; to znamená, že CONSTANT sestaví novou položku slovníku konstantního typu s názvem MARGIN a do pole jejího parametru uloží hodnotu80. Když však řekneme</p>
                           <pre class="wp-block-preformatted">MARGIN</pre>
                           <p>vykonáme <em>chování v době běhu</em> funkce CONSTANT; to znamená, že funkce CONSTANT na zásobník strčí hodnotu 80. V tomto případě se jedná o chování, které se projevuje v době běhu. Definováním slov se budeme dále zabývat v několika následujících částech.</p>
                           <p>Druhým typem slova, které má dvojí chování, je "sestavovací slovo". Kompilující slovo je slovo, které používáme <em>vnitř</em> definice dvojtečky a které během kompilace této definice skutečně něco dělá.</p>
                           <p>Jedním z příkladů je slovo .", které při kompilaci zkompiluje textový řetězec do slovníkového hesla s počtem před ním a při spuštění jej napíše. Dalšími příklady jsou slova řídicí struktury jako IF a LOOP, která se rovněž chovají v době kompilace odlišně od svého chování v době běhu. Zkompilování slov prozkoumáme poté, co probereme definování slov.</p>
                           <h3 id="h-how-to-define-a-defining-word"><span id="How_to_Define_a_Defining_Word">Jak definovat definiční slovo</span></h3>
                           <p>Tady jsou standardní definiční slova jazyka Forth, kterými jsme se dosud zabývali:</p>
                           <pre class="wp-block-preformatted">:    <br>VARIABLE <br>2VARIABLE <br>CONSTANT <br>2CONSTANT <br>CREATE </pre>
                           <p>Co mají všechny společné? Každý z nich se používá k definování množiny slov s podobnými vlastnostmi v době kompilace a běhu.</p>
                           <p>A jak jsou všechna tato definující slova <em>definována</em>? Nejprve si na tuto otázku odpovíme metaforicky.</p>
                           <p>Řekněme, že se zabýváte výrobou keramických slánek. Pokud plánujete vyrobit dostatečné množství slánek, zjistíte, že nejjednodušší je nejprve vyrobit formu. Forma zaručí, že všechny vaše solničky budou mít stejný design, a zároveň vám umožní vyrobit každou solničku v jiné barvě. Při výrobě formy musíte vzít v úvahu dvě věci:</p>
                           <ul>
                              <li>Jak bude <em>forma</em> fungovat. (Např. jak dostanete hlínu do formy a z formy, aniž byste formu rozbili nebo nechali vyniknout švy?)</li> </li>.
                              <li>Jak bude <em>třepadlo</em> fungovat. (Např. kolik otvorů by v něm mělo být? Kolik soli by se do něj mělo vejít? atd.</li>
                           </ul>
                           <p>Přeneseme-li tuto analogii zpět do jazyka Forth, definice definičního slova musí specifikovat dvě věci: chování <em>v době kompilace a chování</em> v době běhu pro tento typ slova.</p>
                           <p>Zadržte na chvíli tuto myšlenku, zatímco se podíváme na nejzákladnější z definičních slov ve výše uvedeném seznamu: CREATE. V době kompilace vezme CREATE jméno ze vstupního proudu a vytvoří pro něj záhlaví slovníku.</p>
                           <p>V době běhu CREATE přesune adresu těla EXAMPLE na zásobník.</p>
                           <p>Co se stane, když použijeme CREATE uvnitř definice? Uvažujme tento příklad, který je definicí pro VARIABLE:</p>
                           <pre class="wp-block-preformatted">: VARIABLE ( -- ) CREATE 0 , ;</pre>
                           <p>Když provedeme VARIABLE jako v</p>
                           <pre class="wp-block-preformatted">VARIABLE ORANGES</pre>
                           <p>Pomocí CREATE nepřímo vytvoříme hlavu slovníku s názvem ORANGES a xt, který ukazuje na běhový kód CREATE. Poté přidělíme buňku pro samotnou proměnnou (s "0 ,").</p>
                           <p>Protože chování proměnné za běhu je totožné s chováním slova definovaného pomocí CREATE, nemusí mít VARIABLE vlastní run-time kód, může použít run-time kód CREATE.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img width="100" height="312" src="./11-Definování slov ve Forth_files/ch11-pronounce-1.gif" alt="definování slov - definování jiného chování za běhu pomocí DOES" class="wp-image-509"></figure>
                           </div>
                           <p>Jak můžeme v definičním slově určit jiné chování za běhu? Pomocí slova DOES&gt;, jak je znázorněno zde:</p>
                           <pre class="wp-block-preformatted">: DEFINUJÍCÍ SLOVO CREATE (operace v době kompilace)<br> DOES&gt; (operace v době běhu) ; </pre>
                           <p>Pro ilustraci, následující příklad by mohl být platnou definicí pro CONSTANT (i když ve skutečnosti je CONSTANT obvykle definován ve strojovém kódu):</p>
                           <pre class="wp-block-preformatted">: CONSTANT ( n -- ) CREATE , DOES&gt; @ ;</pre>
                           <p> Abychom viděli, jak tato definice funguje, představme si, že ji používáme k definici konstanty s názvem TROMBONES, takto:</p>
                           <pre class="wp-block-preformatted">76 CONSTANT TROMBONES</pre>
                           <p><strong>Část pro kompilaci:</strong></p>
                           <dl class="code">
                              <dt>CREATE</dt>
                              <dd>Vytvoří novou položku slovníku (např. TROMBONES)</dd>
                              <dt>,</dt>
                              <dd>Zkompiluje hodnotu (např. 76) pro konstantu ze zásobníku do pole parametrů konstanty.</dd>
                           </dl>
                           <p><strong>Část času běhu:</strong></p>
                           <dl class="code">
                              <dt>DOES&gt;</dt>
                              <dd>Označuje konec chování v době kompilace a začátek chování v době běhu. V době běhu ponechá DOES&gt; na zásobníku adresu těla definovaného slova.</dd>
                              <dt>@</dt>
                              <dd>Vybere obsah konstanty, přičemž použije adresu těla, která bude v době běhu na zásobníku.</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="400" height="111" src="./11-Definování slov ve Forth_files/ch11-trombones.gif" alt="definování slov - chování v době kompilace a chování v době běhu" class="wp-image-510"></figure>
                           </div>
                           <p>Slova, která <em>předcházejí</em> DOES&gt;, určují, co bude forma dělat; slova, která <em>následují</em> DOES&gt;, určují, co bude dělat produkt formy.</p>
                           <dl class="forth">
                              <dt>DĚLÁ&gt;</dt>
                              <dt>čas běhu: ( - addr)</dt>
                              <dd>Používá se při vytváření definičního slova; označuje konec jeho části v době kompilace a začátek jeho části v době běhu. Operace run-time jsou uvedeny ve vyšší úrovni Forthu. V době běhu bude adresa těla definovaného slova na zásobníku.</dd>
                           </dl>
                           <h3 id="h-definování-slov, která si můžete definovat sami"><span id="Definování_slov, která si můžete definovat sami">Definování slov, která si můžete definovat sami</span></h3>
                           <p>Níže uvádíme několik příkladů definičních slov, která si můžete vytvořit sami.</p>
                           <p>Připomeňte si, že v našem pojednání o "Příkazech pro zadávání řetězců" v <a href="https://www.forth.com/starting-forth/10-input-output-operators/">Kap. 10</a> jsme uvedli příklad, který využíval pole znakových řetězců s názvy JMÉNO, OČI a MĚ. Pokaždé, když jsme použili jedno z těchto jmen, následoval počet znaků. V definici vstupu jsme napsali</p>
                           <pre class="wp-block-preformatted">... PAD NAME 14 MOVE</pre>
                           <p>a ve výstupní definici jsme napsali</p>
                           <pre class="wp-block-preformatted">... NAME 14 -TRAILING TYPE ...</pre>
                           <p>a tak dále.</p>
                           <p>Odstraníme počítání vytvořením definičního slova s názvem CHARACTERS, jehož definice produktu při provádění ponechá na zásobníku adresu <em>a</em> počítání.</p>
                           <p>Použijeme jej takto: řekneme-li</p>
                           <pre class="wp-block-preformatted">20 CHARACTERS ME</pre>
                           <p>vytvoříme pole s názvem ME, které bude mít k dispozici dvacet znaků pro znakový řetězec.</p>
                           <p>Při spuštění ME získáme adresu pole a počet na zásobníku. Nyní můžeme napsat</p>
                           <pre class="wp-block-preformatted">PAD ME MOVE</pre>
                           <p>namísto</p>
                           <pre class="wp-block-preformatted">PAD ME 20 MOVE</pre>
                           <p>nebo</p>
                           <pre class="wp-block-preformatted">ME -TIP POHYBU</pre>
                           <p>místo</p>
                           <pre class="wp-block-preformatted">ME 20 -TRAILING TYPE</pre>
                           <p>Takto bychom mohli definovat CHARAKTERY:</p>
                           <pre class="wp-block-preformatted">: CHARACTERS CREATE DUP , ALLOT<br> DOES&gt; ( -- addr len ) DUP CELL+ SWAP @ ;</pre>
                           <p>který se rozpadá takto:</p>
                           <dl class="code">
                              <dt>CREATE</dt>
                              <dd>Vytvoří novou položku slovníku (např. ME)</dd>.
                              <dt>DUP , ALLOT</dt>
                              <dd>Zakomponuje počet (např. dvacet) do první buňky pole pro budoucí použití. Pak přidělí dalších dvacet bajtů nad rámec počtu pro řetězec.</dd>
                              <dt>DOPLNÍ&gt;</dt>
                              <dd>Označí začátek kódu za běhu, přičemž za běhu ponechá na zásobníku adresu těla součinu-slova.</dd>
                              <dt>DUP</dt>
                              <dd>Zkopíruje adresu těla </dd>.
                              <dt>CELL+</dt>
                              <dd>Posune adresu tak, aby směřovala za počítadlo, na začátek řetězce znaků.</dd>
                              <dt>SWAP @</dt>
                              <dd>Vymění adresu řetězce s adresou počtu a načte počet. Na zásobníku je nyní ( addr count - ).</dd>
                           </dl>
                           <p>Právě jsme rozšířili náš překladač! Naše nové slovo CHARACTERS je definiční slovo, které vytváří datovou strukturu a proceduru, kterou považujeme za užitečnou. CHARACTERS nejenže zjednodušuje naše vstupní a výstupní definice, ale také nám umožňuje v případě potřeby měnit délku libovolného řetězce pouze na jednom místě (tj. tam, kde ho definujeme).</p>
                           <p>Náš další příklad by mohl být užitečný v aplikaci, kde je potřeba velké množství polí bajtů (nikoli CHAR!). Vytvořme definiční slovo s názvem STRING takto:</p>
                           <pre class="wp-block-preformatted">: STRING CREATE ALLOT DOES&gt; + ;

</pre>
                           <p>použije se ve formuláři</p>
                           <pre class="wp-block-preformatted">30 STRING VELIKOSTNÍ ZAŘÍZENÍ

</pre>
                           <p>pro vytvoření pole o délce třicet bajtů. Pro přístup k libovolnému bajtu v tomto poli stačí říci:</p>
                           <pre class="wp-block-preformatted">6 VALVE C@

</pre>
                           <p>což nám poskytne aktuální nastavení hydraulického ventilu 6 v čerpací stanici oleje. Při spuštění přidá VALVE argument 6 k adrese těla, kterou zanechal DOES&gt;, čímž vznikne správná bajtová adresa.</p>
                           <p>Pokud naše aplikace vyžaduje inicializaci velkého počtu polí na nulu, můžeme inicializaci zahrnout do alternativního definičního slova s názvem 0STRING:</p>
                           <pre class="wp-block-preformatted">: ERASED HERE OVER ERASE ALLOT ;
   : 0STRING CREATE ERASED DOES&gt; + ;

</pre>
                           <p>Nejprve definujeme ERASED, aby vymazal daný počet bajtů, počínaje HERE, a teprve poté ALLOToval daný počet bajtů.</p>
                           <p>Poté v naší nové verzi jednoduše nahradíme ERASED za ALLOT.</p>
                           <p>Změnou definice definičního slova můžete změnit vlastnosti všech členských slov této rodiny. Tato schopnost výrazně usnadňuje vývoj programu. Například můžete při vývoji programu začlenit určité druhy kontroly chyb a poté, co se ujistíte, že program běží správně, je odstranit.</p>
                           <p>Zde je uvedena verze STRING, která za běhu zaručuje, že index do pole je platný:</p>
                           <pre class="wp-block-preformatted">: STRING CREATE DUP , ALLOT<br> DOES&gt; 2DUP @ U&lt; 0= ABORT" Chyba rozsahu " + CELL+ ; </pre>
                           <p>který se rozpadá takto:</p>
                           <dl class="code">
                              <dt>DUP , ALLOT</dt>
                              <dd>Složí počet a přidělí daný počet bajtů.</dd>
                              <dt>DOES&gt; 2DUP @</dt>
                              <dd>V době běhu při zadání argumentu na zásobníku vytvoří<br>( arg addr arg count - )</dd>.
                              <dt>U&lt; 0=</dt>
                              <dd>Testuje, zda argument není menší než maximum, tj. uložený počet. Protože U&lt; je porovnání bez znaménka, budou se záporné argumenty jevit jako velmi vysoká čísla, a proto testem také neprojdou.</dd>
                              <dt>ABORT" Chyba rozsahu"</dt>.
                              <dd>Zkontrolujte, zda test porovnání selhal.</dd>
                              <dt>+ CELL+</dt>
                              <dd>V opačném případě přidá argument do adresy těla a navíc další buňku pro vynechání počtu.</dd>
                           </dl>
                           <p>Tady je další způsob, jak může použití definičních slov pomoci při vývoji. Řekněme, že se najednou rozhodnete, že všechna pole, která jste definovali pomocí STRING, jsou příliš velká na to, aby byla uchovávána v paměti počítače, a místo toho by měla být uchovávána na disku. Stačí, když předefinujete část STRING pro běh. Tento nový STRING vypočítá, ve kterém záznamu na disku by byl daný bajt obsažen, přečte záznam do vyrovnávací paměti pomocí INCLUDED a vrátí adresu požadovaného bajtu v této vyrovnávací paměti. Takto definovaný řetězec by mohl obsáhnout mnoho po sobě jdoucích záznamů (pomocí stejné techniky jako v Probl. 5, <a href="https://www.forth.com/starting-forth/10-input-output-operators/">Kap. 10</a>).</p>
                           <obrázek class="wp-block-table arrayGrid">
                              <table>
                                 <tbody>
                                    <tr>
                                       <td>&nbsp;</td>
                                       <td>c0</td>
                                       <td>c1</td>
                                       <td>c2</td>
                                       <td>c3</td>
                                    </tr>
                                    <tr>
                                       <td>r0</td>
                                       <td>&nbsp;</td>
                                       <td>&nbsp;</td>
                                       <td>&nbsp;</td>
                                       <td>&nbsp;</td>
                                    </tr>
                                    <tr>
                                       <td>r1</td>
                                       <td>&nbsp;</td>
                                       <td>&nbsp;</td>
                                       <td>&nbsp;</td>
                                       <td>&nbsp;</td>
                                    </tr>
                                    <tr>
                                       <td>r2</td>
                                       <td>&nbsp;</td>
                                       <td>&nbsp;</td>
                                       <td>&nbsp;</td>
                                       <td>&nbsp;</td>
                                    </tr>
                                    <tr>
                                       <td>r3</td>
                                       <td>&nbsp;</td>
                                       <td>&nbsp;</td>
                                       <td>&nbsp;</td>
                                       <td>&nbsp;</td>
                                    </tr>
                                 </tbody>
                              </table>
                           </figure>
                           <p>Definiční slova můžete použít k vytvoření nejrůznějších datových struktur. Někdy je například užitečné vytvářet vícerozměrná pole. Zde je příklad definičního slova, které vytváří dvourozměrná pole bajtů dané velikosti:</p>
                           <pre class="wp-block-preformatted">: ARRAY ( #rows #cols -- ) CREATE DUP , * ALLOT<br> DOES&gt; ( member: row col -- addr )<br> ROT OVER @ * + + CELL+ ; </pre>
                           <p>Chceme-li vytvořit pole čtyři krát čtyři bajty, řekneme</p>
                           <pre class="wp-block-preformatted">4 4 POLE ARRAY

</pre>
                           <p>Pro přístup například k bajtu v řádku 2, sloupci 1 bychom mohli říci</p>
                           <pre class="wp-block-preformatted">2 1 BOARD C@

</pre>
                           <p>Takto obecně funguje naše ARRAY. Protože nám počítač umožňuje pouze jednorozměrná pole, musíme simulovat druhý rozměr. Zatímco naše pomyslné pole vypadá takto</p>
                           <figure class="wp-block-table">
                              <table class="has-fixed-layout">
                                 <tbody>
                                    <tr>
                                       <td>&nbsp;</td>
                                       <td>c0</td>
                                       <td>c1</td>
                                       <td>c2</td>
                                       <td>c3</td>
                                    </tr>
                                    <tr>
                                       <td>r0</td>
                                       <td>0</td>
                                       <td>1</td>
                                       <td>2</td>
                                       <td>3</td>
                                    </tr>
                                    <tr>
                                       <td>r1</td>
                                       <td>4</td>
                                       <td>5</td>
                                       <td>6</td>
                                       <td>7</td>
                                    </tr>
                                    <tr>
                                       <td>r2</td>
                                       <td>8</td>
                                       <td>9</td>
                                       <td>10</td>
                                       <td>11</td>
                                    </tr>
                                    <tr>
                                       <td>r3</td>
                                       <td>12</td>
                                       <td>13</td>
                                       <td>14</td>
                                       <td>15</td>
                                    </tr>
                                 </tbody>
                              </table>
                           </figure>
                           <p>Naše skutečné pole vypadá takto</p>
                           <figure class="wp-block-table arrayGrid">
                              <table>
                                 <tbody>
                                    <tr>
                                       <td>řádek#</td>
                                       <td>0</td>
                                       <td>1</td>
                                       <td>2</td>
                                       <td>3</td>
                                    </tr>
                                    <tr>
                                       <td>offset#</td>
                                       <td>0 1 2 3</td>
                                       <td>4 5 6 7</td>
                                       <td>8 9 10 11</td>
                                       <td>12 13 14 15</td>
                                    </tr>
                                 </tbody>
                              </table>
                           </figure>
                           <p>Pokud chcete adresu bajtu v řádku 2, sloupci 1, lze ji vypočítat vynásobením čísla řádku (2) počtem sloupců v každém řádku (4) a následným přičtením čísla sloupce (1), což znamená, že chcete devátý bajt ve skutečném poli. Tento výpočet musí členové ARRAY provést za běhu. Všimněte si, že k provedení tohoto výpočtu potřebuje každý slovní člen vědět, kolik sloupců je v každém řádku jeho konkrétního pole. Z tohoto důvodu musí ARRAY při kompilaci uložit tuto hodnotu na začátek pole.</p>
                           <p>Pro zvědavce uvádíme efekty zásobníku části pole za běhu:</p>
                           <obrázek class="wp-block-table">
                              <table>
                                 <tbody>
                                    <tr>
                                       <td><strong>Operace</strong></td>
                                       <td><strong>Obsah zásobníku</strong></td>
                                    </tr>
                                    <tr>
                                       <td></td>
                                       <td>řádek col addr</td>
                                    </tr>
                                    <tr>
                                       <td>ROT</td>
                                       <td>col addr row</td>
                                    </tr>
                                    <tr>
                                       <td>OVER @</td>
                                       <td>col addr row #cols</td>
                                    </tr>
                                    <tr>
                                       <td>*</td>
                                       <td>col addr index</td>
                                    </tr>
                                    <tr>
                                       <td>+ + CELL+</td>
                                       <td>addr</td>
                                    </tr>
                                 </tbody>
                              </table>
                           </figure>
                           <p>K vypočtené adrese je nutné přidat buňku, protože první buňka pole obsahuje počet sloupců.</p>
                           <p>Náš poslední příklad je vizuálně nejzajímavější, ne-li nejužitečnější.</p>
                           <pre class="wp-block-preformatted">: STAR [CHAR] * EMIT ;<br><br>: .ROW CR 8 0 DO<br> DUP 128 AND IF STAR ELSE SPACE THEN<br> 1 LSHIFT LOOP DROP ;<br><br>: SHAPE CREATE 8 0 DO C, LOOP<br> DOES&gt; DUP 7 + DO I C@ . ROW -1 +LOOP CR ;<br><br>HEX <br>18 18 3C 5A 99 24 24 24 SHAPE MAN<br>81 42 24 18 18 24 24 81 SHAPE EQUIS<br>AA AA FE FE 38 38 38 FE SHAPE CASTLE<br>DECIMAL </pre>
                           <p>.ROW vypíše vzor hvězdiček a mezer, který odpovídá 8bitovému číslu na zásobníku. Například:</p>
                           <pre class="wp-block-preformatted">2 BASE !↵<span class="output"> ok </span>
00111001 .ROW↵
<span class="output"> *** * ok </span>
DECIMAL↵<span class="output"> ok </span>

</pre>
                           <p>Definiční slovo SHAPE přebírá osm argumentů ze zásobníku a definuje tvar, který po provedení vytiskne mřížku 8 × 8, která odpovídá osmi argumentům. Například:</p>
                           <pre class="wp-block-preformatted">MAN↵<span class="output">
   **
   **
  ****
 * ** *
* ** *
  * *
  * *
  * *
ok </span>
</pre>
                           <p>Shrneme-li to, definující slova mohou být mimořádně mocným nástrojem. Když vytvoříte nové definiční slovo, rozšíříte tím svůj překladač. Tradiční jazyky jako Fortran nebo BASIC tuto flexibilitu neposkytují, protože tyto tradiční překladače a interprety jsou nepružné balíky, které říkají: "Používejte mou instrukční sadu, nebo na to zapomeňte!"</p>
                           <p>Skutečná síla definičních slov spočívá v tom, že mohou zjednodušit váš problém. Jejich správným použitím můžete zkrátit dobu programování, zmenšit velikost programu a zlepšit jeho čitelnost. Flexibilita jazyka Forth je v tomto ohledu ve srovnání s tradičními jazyky tak radikální, že tomu mnoho lidí ani nevěří. Tak teď jste se o tom přesvědčili.</p>
                           <p>V další části se seznámíte s dalším způsobem, jak rozšířit schopnosti překladače jazyka Forth.</p>
                           <h3 id="h-how-to-control-the-colon-compiler"><span id="How_to_Control_the_Colon_Compiler">Jak ovládat překladač dvojteček</span></h3>
                           <p>Kompilátory jsou slova, která se používají uvnitř definic dvojteček, aby v době kompilace něco provedly. Nejzřejmějšími příklady kompilujících slov jsou slova řídicí struktury, jako jsou IF, THEN, DO, LOOP atd. Protože programátoři Forthu způsob fungování těchto konkrétních slov často nemění, nebudeme se jimi dále zabývat. Místo toho se budeme zabývat skupinou slov, která řídí dvojtečku kompilátoru, a lze z nich tedy vytvořit <em>jakýkoli</em> typ kompilujícího slova.</p>
                           <p>Připomeňte si, že dvojtečkový překladač běžně vyhledá každé slovo zdrojové definice a zkompiluje adresu každého slova do slovníkového hesla - to je vše. Překladač dvojtečky však <em>nekompiluje</em> adresu kompilujícího slova - provede ho.</p>
                           <p>Jak dvojtečkový překladač pozná rozdíl? Tím, že kontroluje <em>bit přednosti definice</em>. Pokud je tento bit "vypnutý", adresa slova se zkompiluje. Pokud je bit "zapnutý", slovo se provede okamžitě; taková slova se nazývají <em>bezprostřední</em> slova.</p>
                           <p>Slovo IMMEDIATE činí slovo "okamžitým". Používá se ve tvaru:</p>
                           <pre class="wp-block-preformatted">: definice jména ; IMMEDIATE

</pre>
                           <p>tj. provede se ihned po sestavení definice.</p>
                           <p>Pro okamžitý příklad uveďme definici</p>
                           <pre class="wp-block-preformatted">: SAY-HELLO ." Hello" ; IMMEDIATE </pre>
                           <p>Můžeme provést SAY-HELLO interaktivně, stejně jako kdyby <em>nebylo</em> okamžité.</p>
                           <pre class="wp-block-preformatted">SAY-HELLO↵<span class="output"> Hello ok </span>

</pre>
                           <p>Ale pokud vložíme SAY-HELLO do jiné definice, provede se v <em>času kompilace</em>:</p>
                           <pre class="wp-block-preformatted">: "POZDRAVIT SAY-HELLO ." Mluvím forthsky " ;↵<span class="output"> Hello ok </span> </pre>
                           <p>než při <em>vykonávání</em>:</p>
                           <pre class="wp-block-preformatted">GREET↵<span class="output"> Mluvím Forth ok </span>

</pre>
                           <p>Než budeme pokračovat, ujasněme si terminologii. Lidé z Forthu dodržují konvenci týkající se termínů "run time" a "compile time". V tomto příkladu jsou tyto termíny definovány vzhledem ke GREETu. Řekli bychom tedy, že SAY-HELLO má "chování v době kompilace", ale nemá "chování v době běhu". Je zřejmé, že SAY-HELLO má své vlastní chování v době běhu, ale vzhledem ke GREETu tomu tak není.</p>
                           <p>Abychom si udrželi rovnítko, nazvěme v tomto příkladu GREET "kompilací"; to znamená definicí, o jejíž kompilaci se jedná. SAY-HELLO nemá vůči svému compilee žádné chování za běhu.</p>
                           <p>Tady je příklad bezprostředního slova, které znáte: definice kompilujícího slova BEGIN. Je to jednodušší, než jste si možná mysleli:</p>
                           <pre class="wp-block-preformatted">: ZAČÍNÁME ZDE ; BEZPROSTŘEDNĚ

</pre>
                           <p>BEGIN jednoduše uloží adresu HERE v době kompilace na zásobník. Proč? Protože dříve nebo později se objeví UNTIL nebo REPEAT a buď musí vědět, na jakou adresu ve slovníku se má vrátit v případě, že se musí opakovat. To je adresa, kterou BEGIN zanechal na zásobníku.</p>
                           <p>Při kompilaci zanechává BEGIN na zásobníku adresu HERE. BEGIN však do kompilace nic nezakompiluje; pro BEGIN neexistuje žádné chování za běhu.</p>
                           <p>Na rozdíl od BEGIN má většina kompilujících slov <em>do</em> chování v době běhu. Aby slovo mělo chování za běhu, musí se do kompilátoru zkompilovat adresa chování za běhu, která již musí být definována jako slovo.</p>
                           <p>Dobrým příkladem je DO. Stejně jako BEGIN musí DO v době kompilace poskytnout adresu ZDE, na kterou se LOOP nebo +LOOP vrátí. Ale na rozdíl od BEGIN má DO také chování za běhu: musí na návratový zásobník posunout limit a index.</p>
                           <p>Chování DO za běhu je definováno slovem nižší úrovně, někdy nazývaným (DO) nebo 2&gt;R. Definice DO je následující:</p>
                           <pre class="wp-block-preformatted">: DO POSTPONE 2&gt;R ZDE ; IMMEDIATE

</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="160" height="118" src="./11-Definování slov ve Forth_files/ch11-2-to-r.gif" alt="POSTPONE a chování za běhu - použití definujících slov" class="wp-image-511"></figure>
                           </div>
                           <p>Slovo POSTPONE zjistí adresu dalšího slova v definici (v tomto případě 2&gt;R) a zkompiluje jeho adresu do definice compilee, takže v době běhu bude provedeno 2&gt;R.</p>
                           <p>Dalším příkladem je definice ;. V době kompilace musí středník provést následující věci:</p>
                           <ol>
                              <li>zakompilovat adresu EXIT do kompilovaného slovníkového hesla,</li>
                              <li>zpřístupnit nové slovo kompilátoru dvojtečky a</li>
                              <li>ukončí režim kompilace.</li>
                           </ol>
                           <p>Tady je definice středníku:</p>
                           <pre class="wp-block-preformatted">: ; POSTPONE EXIT REVEAL POSTPONE [ ; IMMEDIATE </pre>
                           <p>První věta kompiluje EXIT a poskytuje chování za běhu. Druhá fráze, která představuje chování v době kompilace, nejprve vystaví slovo, které se kompiluje, a pak se dostane ven z kompilátoru.</p>
                           <p>Jaký je důvod pro REVEAL? Když jsou slova v procesu kompilace, nejsou ještě k nalezení v překladači dvojtečky. To se provádí proto, aby bylo možné předefinovat existující slova ve smyslu staré definice plus dalšího kódu, například:</p>
                           <pre class="wp-block-preformatted">: CR CR SPACE ;

</pre>
                           <p>Pokud by při sestavování nového CR bylo možné zjistit jeho název, název původního CR by byl zablokován a museli bychom udělat například:</p>
                           <pre class="wp-block-preformatted">: _cr_ CR ; <br>: CR _cr_ SPACE ; </pre>
                           <p>Slovo POSTPONE lze také použít k sestavení bezprostředního slova, jako by nebylo bezprostřední. Vzhledem k našemu předchozímu příkladu, v němž je SAY-HELLO bezprostřední definicí, bychom mohli definovat</p>
                           <pre class="wp-block-preformatted">: POZDRAV ODLOŽIT SAY-HELLO ." Mluvím Forth " ;↵<span class="output"> ok </span> </pre>
                           <p>vynucuje, aby se SAY-HELLO kompilovalo, a ne provádělo při kompilaci. Tedy:</p>
                           <pre class="wp-block-preformatted">GREET↵<span class="output"> Dobrý den, mluvím forthsky ok </span>

</pre>
                           <p>Nezapomeňte si všimnout "inteligence" zabudované v POSTPONE. POSTPONE analyzuje další slovo ve vstupním proudu, rozhodne, zda je bezprostřední, nebo ne, a podle toho pokračuje. Pokud slovo nebylo okamžité, POSTPONE zkompiluje adresu slova do zkompilované definice; představte si to jako odloženou kompilaci. Pokud je slovo okamžité, POSTPONE zkompiluje adresu tohoto slova do definice <em>současně definované</em>; jde o běžnou kompilaci, ale okamžitého slova, které by se jinak provedlo.</p>
                           <p>Pro přehled uvádíme dvě slova, která jsou užitečná při vytváření nových kompilačních slov:</p>
                           <dl class="forth">
                              <dt>PŘÍMÉ</dt>
                              <dt>( - )</dt>
                              <dd>Označí naposledy definované slovo jako slovo, které se při setkání s ním během kompilace spíše provede, než aby se kompilovalo </dd>.
                              <dt>POSTPONE xxx</dt>
                              <dt>( - )</dt>
                              <dd>
                                 <ol>
                                    <li>Používá se v definici slova pro kompilaci. Když je naopak kompilující slovo použito ve zdrojové definici, bude do slovníkového hesla zakompilován token provedení xxx, takže při spuštění nové definice bude provedeno xxx.</li>
                                    <li>Použití v definici s dvojtečkou způsobí, že okamžité slovo xxx bude zkompilováno, jako by nebylo okamžité; při spuštění definice bude provedeno xxx.</li>
                                 </ol>
                              </dd>
                           </dl>
                           <h3 id="h-more-compiler-controlling-words"><span id="More_Compiler-Controlling_Words">More Compiler-Controlling Words</span></h5>
                           <p>Existují dvě další slova řídící překladač, která byste měli znát. Slova [ a ] lze použít uvnitř definice dvojtečky pro zastavení kompilace, respektive pro její opětovné spuštění. Jakákoli slova, která se mezi nimi objeví, budou provedena "okamžitě", tj. v době kompilace.</p>
                           <p>Podívejte se na tento příklad:</p>
                           <pre class="wp-block-preformatted">: SAY-HELLO ." Hello " ;
: GREET [ SAY-HELLO ] ." Mluvím forth " ;↵<span class="output"> Hello ok </span>

GREET↵<span class="output"> Mluvím Forth ok </span>
</pre>
                           <p>V tomto příkladu je SAY-HELLO <em>není</em> okamžité slovo, přesto když zkompilujeme GREET, SAY-HELLO se vykoná "okamžitě" </p>.
                           <p>Pro lepší příklad musíme nejprve zavést slovo LITERÁRNÍ.</p>
                           <p>Jak si možná vzpomínáte, číslo, které se objevuje v definici dvojtečky, se nazývá "literál". Příkladem je "4" v definici</p>
                           <pre class="wp-block-preformatted">: ČTYŘI-VÍCE 4 + ;

</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="292" height="202" src="./11-Definování slov ve Forth_files/ch11-four-more.gif" alt="použití doslovných hodnot v definicích dvojteček - LITERAL" class="wp-image-512"></figure>
                           </div>
                           <p>Použití literálu v definici dvojtečky vyžaduje dvě buňky. První z nich obsahuje prováděcí token rutiny, která po provedení přesune obsah druhé buňky (samotné číslo) na zásobník.</p>
                           <p>Název této rutiny se může lišit; říkejme jí "kód pro běh literálu" nebo jednoduše (LITERÁL). Když se překladač dvojtečky setká s číslem, nejprve zkompiluje run-time kód pro literál a poté zkompiluje samotné číslo.</p>
                           <p>Slovo, které budete nejčastěji používat pro kompilaci literálu, je LITERÁL (bez závorek). LITERAL zkompiluje jak run-time kód, tak samotnou hodnotu. Pro ilustraci:</p>
                           <pre class="wp-block-preformatted">: ČTYŘI-VÍCE [ 4 ] LITERAL + ;

</pre>
                           <p>Zde slovo LITERAL zkompiluje jako literál "4", které jsme vložili na zásobník mezi hranaté závorky. Získáme tak slovníkový záznam, který je totožný s tím, který je uveden výše.</p>
                           <p>Když už víme o LITERÁLU vše, co je třeba vědět, můžeme také uvést lepší příklad [ a ]. Představme si definici dvojtečky, ve které potřebujeme zadat bajt z řádku 2, sloupce 3 pole BOARD, které jsme definovali v předchozí části. Pro získání adresy tohoto bajtu bychom mohli použít větu</p>
                           <pre class="wp-block-preformatted">BOARD 2 8 ( #cols) * 3 + CELL+ +

</pre>
                           <p>ale její provedení je časově náročné</p>
                           <pre class="wp-block-preformatted">2 8 * 3 +

</pre>
                           <p>Při každém použití této definice. Alternativně bychom mohli napsat</p>
                           <pre class="wp-block-preformatted">BOARD 19 CELL+ +

</pre>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="140" height="176" src="./11-Definice slov ve Forth_files/ch11-pronounce-2.gif" alt="aritmetika při kompilaci zadaná pomocí [ a ] (levá závorka a pravá závorka)" class="wp-image-513"></figure>
                           </div>
                           <p>ale lidským čtenářům není jasné, co přesně 19 znamená, a je iritující, že kvůli přenositelnosti musíme stále psát CELL+, ačkoli 1 CELLS je jen konstanta.</p>
                           <p>Nejlepším řešením je psát</p>
                           <pre class="wp-block-preformatted">BOARD [ 2 8 ( #cols) * 3 + CELL+ ] LITERAL +

</pre>
                           <p>Tady se aritmetika provede pouze jednou, v době kompilace, a výsledek se zkompiluje jako literál.</p>
                           <p>Tady je hloupý příklad, který vám může vnuknout nápady pro praktičtější aplikace. Tato definice vám umožní nahlédnout do nitra samotného slova:</p>
                           <pre class="wp-block-preformatted">: DUMP-THIS [ ZDE ] LITERÁL 32 DUMP ." DUMP-THIS" ; </pre>
                           <div class="wp-block-image">
                              <figure class="alignleft"><img loading="lazy" width="131" height="118" src="./11-Definování slov ve Forth_files/ch11-dump-this.gif" alt="ZDE ukazuje na adresu dalšího volného bajtu kódu" class="wp-image-514"></figure>
                           </div>
                           <p>Při spuštění funkce DUMP-THIS dojde k výpisu paměti, do které byla funkce DUMP-THIS definována. Měli byste vidět, jak váš Forth sestaví literální hodnotu "zde", literál "32", token provedení DUMP a pak jak inlinuje řetězec "DUMP-THIS". (V době kompilace ukazuje HERE na adresu dalšího volného bajtu kódu. LITERAL toto číslo zkompiluje do definice jako literál, takže bude sloužit jako argument pro DUMP za běhu."</p>.
                           <p>Mimochodem, zde je definice LITERÁLU:</p>
                           <pre class="wp-block-preformatted">: LITERAL POSTPONE (LITERAL) , ; IMMEDIATE

</pre>
                           <p>Nejdříve se zkompiluje adresa běhového kódu, pak se zkompiluje samotná hodnota (pomocí čárky).</p>
                           <dl class="forth">
                              <dt>LITERÁL</dt>
                              <dt>zkompiluje: ( n - ) run: ( - n )</dt>
                              <dd>Používá se pouze uvnitř definice dvojtečky. Při kompilaci zkompiluje hodnotu ze zásobníku do definice jako literál. V době běhu se hodnota vloží na zásobník.</dd>
                              <dt>[</dt>
                              <dt>( - )</dt>
                              <dd>Ukončí režim kompilace.</dd>
                              <dt>]</dt>
                              <dt>( - )</dt>.
                              <dd>Přepne do režimu kompilace.</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="200" height="170" src="./11-Definování slov ve Forth_files/ch11-curtain-call.gif" alt="Textový interpret Forth a kompilátor kódu" class="wp-image-515"></figure>
                           </div>
                           <h3 id="h-curtain-calls"><span id="Curtain_Calls">Volání opony</span></h3>
                           <p>Tato část nám dává příležitost rozloučit se s textovým interpretem a překladačem dvojteček a možná se na ně podívat v novém světle.</p>
                           <p>Tady je definice INTERPRETU, která bude fungovat ve většině systémů Forth:</p>
                           <pre class="wp-block-preformatted">: INTERPRET ( -- )<br> BEGIN<br> BL FIND IF EXECUTE <br> ?STACK ABORT" Stack empty"<br> ELSE NUMBER THEN <br> AGAIN ; </pre>
                           <p>Podrobně jsme se zabývali každým slovem obsaženým v této definici; INTERPRET můžeme popsat v angličtině prostým "překladem" jeho definice, například takto:</p>
                           <blockquote class="wp-block-quote">
                              <p>Začněte smyčku. V rámci smyčky se pokuste vyhledat další slovo ze vstupního proudu. Pokud není definováno, zkuste jej převést na číslo. Pokud <em>je</em> definováno, proveďte jej a poté zkontrolujte, zda je zásobník prázdný. (Pokud je, ukončete smyčku a vypište "STACK EMPTY.") Pak nekonečnou smyčku opakujte.</p>
                           </blockquote>
                           <p>Jak vidíte, textový interpret Forth je jednoduchá, ale výkonná struktura. Nyní porovnejme jeho strukturu se strukturou překladače dvojtečky:</p>
                           <pre class="wp-block-preformatted">: ] ( -- )<br> BEGIN<br> BL FIND DUP IF <br> -1 = IF EXECUTE ?STACK ABORT" Stack empty" <br> ELSE , THEN<br> ELSE DROP (NUMBER) POSTPONE LITERAL THEN <br> AGAIN ; </pre>
                           <p>První věc, které jste si asi všimli, je, že název dvojtečky překladače není :, ale ]. Definice : po vytvoření hlavy slovníku a provedení několika dalších podivných úkonů vyvolá ].</p>
                           <p>Další věc, které jste si možná všimli, je, že překladač je poněkud podobný překladači. Přeložme si definici do češtiny:</p>
                           <ul>
                              <li>Začíná cyklus. V rámci smyčky se pokusí vyhledat další slovo ze vstupního proudu. Pokud není definováno, pokus se ho převést na číslo, a pokud je to číslo, zkompiluj ho jako literál.</li>
                              <li>Jestliže <em>je</em> definováno, FIND otestoval precedenční bit slova. Pokud je slovo bezprostřední, provede jej a zkontroluje, zda je zásobník prázdný. Pokud <em>není</em> bezprostřední, vrátil FIND symbol provedení, který lze zkompilovat. Pak se nekonečná smyčka opakuje.</li>
                           </ul>
                           <p>Srovnejte to s INTERPRET a uvidíte, že ] by se dalo nazvat interpretem se schopností rozhodnout, zda se má kterékoli slovo vykonat nebo zkompilovat. Právě jednoduchost této konstrukce umožňuje tak snadno přidávat nová kompilující slova.</p>
                           <p>Shrnem jsme si ukázali dva způsoby, jak rozšířit kompilátor jazyka Forth:</p>
                           <ol>
                              <li>Přidání nových, specializovaných kompilátorů vytvořením nových definičních slov.</li>
                              <li>Rozšířit stávající dvojtečkový kompilátor vytvořením nových kompilujících slov.</li>
                           </ol>
                           <p> Zatímco tradiční kompilátory se snaží být univerzálními nástroji, kompilátor jazyka Forth je souborem samostatných jednoduchých nástrojů ... s prostorem pro další.</p>
                           <p>Který přístup se zdá být užitečnější:</p>
                           <figure class="wp-block-image"><img loading="lazy" width="400" height="186" src="./11-Definování slov ve Forth_files/ch11-simplicity-vs-complexity.gif" alt="způsoby rozšíření kompilátorů Forth" class="wp-image-516"></figure>
                           <h3 id="h-souhrn kapitoly"><span id="Souhrn kapitoly">Souhrn kapitoly</span></h3>
                           <h3 id="h-slovy_předmluvy"><span id="Slova_předmluvy">Slovy_předmluvy</span></h5>
                           <p>Tady je slovníček slov, která jsou obsažena v této kapitole:</p>
                           <dl class="forth">
                              <dt>DĚLÁ&gt;</dt>
                              <dt>čas běhu: ( - addr)</dt>
                              <dd>Používá se při vytváření definičního slova; označuje konec jeho části v době kompilace a začátek jeho části v době běhu. Operace run-time jsou uvedeny ve vyšší úrovni Forthu. V době běhu bude adresa těla definovaného slova na zásobníku.</dd>
                              <dt>IMMEDIATE</dt>
                              <dt>( - )</dt>
                              <dd>Označí naposledy definované slovo jako slovo, které se při setkání s ním během kompilace nebude kompilovat, ale vykoná.</dd>
                              <dt>POSTPONE xxx</dt>
                              <dt>( - )</dt>
                              <dd>
                                 <ol>
                                    <li>Používá se v definici slova pro kompilaci. Když je naopak kompilující slovo použito ve zdrojové definici, bude do slovníkového hesla zakompilován token provedení xxx, takže při spuštění nové definice bude provedeno xxx.</li>
                                    <li>Použití v definici s dvojtečkou způsobí, že okamžité slovo xxx bude zkompilováno, jako by nebylo okamžité; při spuštění definice bude provedeno xxx.</li>
                                 </ol>
                              </dd>
                              <dt>LITERÁLA</dt>
                              <dt>kompilovat: ( n - ) spustit: ( - n )</dt>
                              <dd>Používá se pouze uvnitř definice dvojtečky. Při kompilaci zkompiluje hodnotu ze zásobníku do definice jako literál. V době běhu se hodnota vloží na zásobník.</dd>
                              <dt>[</dt>
                              <dt>( - )</dt>
                              <dd>Ukončí režim kompilace.</dd>
                              <dt>]</dt>
                              <dt>( - )</dt>.
                              <dd>Přepne do režimu kompilace.</dd>
                           </dl>
                           <h3 id="h-review-of-terms"><span id="Review_of_Terms">Přehled podmínek</span></h5>
                           <dl>
                              <dt>Chování v době kompilace</dt>
                              <dd>1. při odkazu na <em>definiční</em> slova: posloupnost instrukcí, které budou provedeny při spuštění definičního slova - tyto instrukce provedou kompilaci členských slov;<br>2. při odkazu na <em>kompilující</em> slova: chování kompilujícího slova, obsaženého v definici dvojtečky, během kompilace definice.</dd>
                              <dt>Kompilace</dt>
                              <dd>kompilovaná definice. Ve vztahu ke kompilujícímu slovu je compilee definice, jejíž kompilaci kompilující slovo ovlivňuje.</dd>
                              <dt>Kompilující slovo</dt>
                              <dd>slovo použité uvnitř definice s dvojtečkou, které provádí nějakou akci během procesu kompilace.</dd>
                              <dt>Definiční slovo</dt>
                              <dd>slovo, které po provedení sestaví nové slovníkové heslo. Definiční slovo určuje chování každého člena "rodiny" slov, které definuje, v době kompilace a v době běhu.</dd>
                              <dt>Precedenční bit</dt>
                              <dd>V heslech slovníku jazyka Forth bit, který udává, zda se má slovo při setkání s ním během kompilace spíše provést než zkompilovat.</dd>
                              <dt>Chování za běhu</dt>
                              <dd>1. při odkazu na <em>definiční</em> slova: posloupnost instrukcí, která bude provedena při spuštění některého členu;<br>2. při odkazu na <em>kompilující</em> slova: rutina, která bude provedena při kompilaci. Ne všechna kompilující slova mají chování za běhu.</dd>
                           </dl>
                           <div class="wp-block-image">
                              <figure class="aligncenter"><img loading="lazy" width="230" height="100" src="./11-Definování slov ve Forth_files/felix.gif" alt="Programovací jazyk Forth - příklady" class="wp-image-353"></figure>
                           </div>
                           <h3 id="h-problems-chapter-11"><span id="Problems_Chapter_11">Problémy ... Kapitola 11</span></h5>
                           <ol>
                              <li>
                                 Definujte definiční slovo s názvem LOADED-BY, které bude definovat slova, která při svém spuštění obsahují soubor. Příklad: V tomto případě se jedná o soubor, který se nachází v adresáři, který se nachází v adresáři:
                                 <pre>S" mail.forth" LOADED-BY CORRESPONDENCE
</pre>
                                 by definovalo slovo CORRESPONDENCE. Když je CORRESPONDENCE spuštěno, je do něj zahrnut soubor mail.forth.
                              </li>
                              <li>
                                 Definujte definiční slovo BASED, které vytvoří číselná výstupní slova pro konkrétní báze. Např,
                                 <pre>16 BASED H.
</pre>
                                 by definoval H. jako slovo, které vypíše vrchol zásobníku v hexadecimálním tvaru, ale trvale nezmění BASE.
                                 <pre>&gt;DECIMAL
17 DUP H. .↵ 11 17 ok
</pre>
                              </li>
                              <li>
                                 Definujte definiční slovo PLURAL, které převezme adresu slova, například CR nebo STAR, a vytvoří jeho množné číslo, například CRS nebo STARS. Pomocí zaškrtávátka poskytnete slovu PLURAL prováděcí token jednotného čísla. Například věta
                                 <pre>' CR PLURAL CRS
</pre>
                                 bude definovat CRS stejným způsobem, jako kdybyste ho definovali
                                 <pre>: CRS ( krát -- ) 0 DO CR LOOP ;
</pre>
                              </li>
                              <li>Předpokládejme, že francouzská slova pro DO a LOOP jsou TOURNE a RETOURNE. Pomocí slov DO a LOOP definujte TOURNE a RETOURNE jako francouzské "aliasy". Nyní je otestujte tím, že si napíšete francouzskou smyčku. </li>
                              <li>
                                 Napište slovo LOOPS, které způsobí, že se zbytek vstupního proudu až po návrat vozíku provede tolikrát, kolikrát je určeno hodnotou na zásobníku. Například,
                                 <pre>7 LOOPS CHAR * EMIT SPACE↵ * * * * * * * * ok
</pre>
                              </li>
                           </ol>
                           <div class="wp-block-genesis-blocks-gb-accordion gb-font-size-18 gb-block-accordion">
                              <details>
                                 <summary class="gb-accordion-title">Odpovědi</summary>
                                 <div class="gb-accordion-text">
                                    <ol>
                                       <li>
                                          <pre>: LOADED-BY ( addr len -- )
   CREATE HERE 2 CELLS + , ( addr) DUP ( count) ,
   &gt;R ZDE R@ MOVE ( get string)
   R&gt; ALLOT ( uvolnit místo)
   DOES&gt; 2@ SWAP INCLUDED ;
</pre>
                                       </li>
                                       <li>
                                          <pre>: BASED ( compile: new_base -- ) ( run: n -- )
   CREATE , DOES&gt; @ ( new_base )
   BASE @ &gt;R ( uložit starou BASE )
   BASE !  .
   R&gt; BASE ! ; ( obnovit BASE )
</pre>
                                       </li>
                                       <li>
                                          <pre>: PLURAL ( compile: xt -- ) ( run: #times -- )
   CREATE ,
   DOES&gt; @ SWAP ?DUP IF 0 DO DUP EXECUTE LOOP THEN DROP ;
</pre>
                                       </li>
                                       <li>
                                          <pre>: TOURNE POSTPONE DO ; IMMEDIATE
: RETOURNE POSTPONE LOOP ; IMMEDIATE
: TRY 10 0 TOURNE I .  RETOURNE ;
</pre>
                                       </li>
                                       <li>
                                          <pre>: LOOPS ( n -- ) &gt;IN @ SWAP 0 DO DUP &gt;IN !  INTERPRETOVAT SMYČKU DROP ;
</pre>
                                       </li>
                                    </ol>
                                 </div>
                              </details>
                           </div>
                        </div>
                     </div>
                  </article>
               </main>
            </div>
         </div>
      </div>
      <div class="site grid-container container hfeed grid-parent" id="page">
         <div class="site-content" id="content">
            <div class="content-area grid-parent mobile-grid-100 grid-70 tablet-grid-70" id="primary">
               <main class="site-main" id="main">
                  <article id="post-347" class="post-347 page type-page status-publish" itemtype="https://schema.org/CreativeWork" itemscope="">
                     <div class="inside-article">
                        <header class="entry-header" aria-label="Content">
                           <h2 class="entry-title" itemprop="headline">12. Klasický příklad</h2>
                        </header>
                        <div class="entry-content" itemprop="text">
                           <p>Programování ve Forthu je větší "umění" než programování v jakémkoli jiném jazyce. Podobně jako malíři kreslí tahy štětce, mají programátoři ve Forthu naprostou kontrolu nad tím, kam směřují a jak se tam dostanou. Charles Moore napsal: "Dobrý programátor může ve Forthu odvést fantastickou práci; špatný programátor může odvést katastrofální práci.". Dobrý programátor Forthu si musí být vědom "stylu" </p>.
                           <p>Styl jazyka Forth se nedá snadno naučit; je to téma, které si zaslouží vlastní knihu. Mezi některé prvky dobrého stylu jazyka Forth patří:</p>
                           <ul>
                              <li>jednoduchost,</li>
                              <li>používání mnoha krátkých definic namísto několika delších,</li>
                              <li>soulad mezi slovy a snadno pochopitelnými akcemi nebo datovými strukturami,</li>
                              <li>vhodně zvolené názvy a</li>
                              <li>dobře uspořádané soubory, jasně komentované.</li>
                           </ul>
                           <p>Jedním z dobrých způsobů, jak se naučit styl, je kromě pokusů a omylů také studium existujících aplikací jazyka Forth, včetně Forthu samotného. V této knize jsme uvedli definice mnoha slov systému Forth a doporučujeme vám, abyste v tomto studiu pokračovali sami.</p>
                           <p>Tato kapitola představuje klasickou aplikaci, Kalkulátor kuželových pilířů, která by měla sloužit jako příklad dobrého stylu jazyka Forth.</p>
                           <p>Tento příklad demonstruje způsob, jak převést matematickou rovnici do definice jazyka Forth; uvidíte, že práce s aritmetikou s pevnou řádovou čárkou nemusí nutně znamenat obětování rychlosti a kompaktnosti.</p>
                           <h3><span id="No_Weighting">No Weighting</span></h3>
                           <p>Naším klasickým příkladem je matematická úloha, o které by se mnoho lidí domnívalo, že ji lze vyřešit pouze pomocí plovoucí desetinné čárky. Ukážeme na něm, jak řešit poměrně složitou rovnici pomocí aritmetiky s pevnou řádovou čárkou, a předvedeme, že při všech výhodách použití pevné řádové čárky nemusí trpět rozsah a přesnost. Použití pevné řádové čárky má tu drobnou nevýhodu, že pro správný výpočet měřítkových koeficientů musíme znát počet bitů na buňku našeho Forthu. U moderních Forthů může být počet bitů na buňku 16, 32, 64 nebo i vyšší. Abychom následující popis příliš nekomplikovali, budeme předpokládat 16bitový hardware. To je pravděpodobně jediné prostředí, pro které bude tento příklad stejně užitečný. Také budeme předpokládat, že 1 CHARS je ekvivalentní jednomu bajtu.</p>
                           <p>V tomto příkladu budeme počítat hmotnost kuželovité hromady materiálu, přičemž budeme znát výšku hromady, úhel sklonu hromady a hustotu materiálu.</p>
                           <p>Aby byl příklad "konkrétnější", zvážíme několik obrovských hromad písku, štěrku a cementu. Sklon každé hromady, nazývaný "úhel sklonění", závisí na druhu materiálu. Například písek se hromadí strměji než štěrk.</p>
                           <figure class="wp-block-image"><img width="400" height="73" src="./12-A Classic Forth Code Example_files/ch12-sand-piles.webp" alt="Kalkulačky hmotnosti Forth" class="wp-image-519"></figure>
                           <p>(Ve skutečnosti se tyto hodnoty značně liší v závislosti na mnoha faktorech; pro ilustraci jsme zvolili přibližné úhly a hustoty)</p>.
                           <p>Tady je vzorec pro výpočet hmotnosti kuželové hromady vysoké <em>h</em> stop s úhlem sklonění <em>theta</em> stupňů, kde <em>D</em> je hustota materiálu v librách na stopu krychlovou:</p>
                           <figure class="wp-block-image"><img loading="lazy" width="281" height="145" src="./12-A Classic Forth Code Example_files/pile1.jpg" alt="W = pi h³D / 3 tan²(theta)" class="wp-image-520"></figure>
                           <p>Toto bude vzorec, který musíme vyjádřit ve Forthu.</p>
                           <h3><span id="Pro_Skeptiky">Pro Skeptiky</span></h5>
                           <p>
                              Objem kužele, <em>V</em>, je dán vztahem
                           </p>
                           <figure class="wp-block-image"><img loading="lazy" width="250" height="138" src="./12-A Classic Forth Code Example_files/pile2.jpg" alt="V=pi/3 b²h" class="wp-image-521"></figure>
                           <p>
                              kde <em>b</em> je poloměr základny a <em>h</em> je výška. Základnu můžeme vypočítat, když známe úhel, přesněji řečeno tečnu k úhlu. Tangens úhlu je jednoduše poměr úsečky označené <em>h</em> k úsečce označené <em>b</em> na tomto obrázku:
                           </p>
                           <figure class="wp-block-image"><img loading="lazy" width="200" height="143" src="./12-A Classic Forth Code Example_files/ch12-sand-piles-geometry.webp" alt="V=pi/3 b²h" class="wp-image-523"></figure>
                           <p>
                              Pokud tento úhel nazveme "theta", pak
                           </p>
                           <figure class="wp-block-image"><img loading="lazy" width="256" height="169" src="./12-A Classic Forth Code Example_files/pile3.jpg" alt="tan(theta) = h/b" class="wp-image-522"></figure>
                           <p>
                              Takto můžeme vypočítat poloměr základny pomocí
                           </p>
                           <figure class="wp-block-image"><img loading="lazy" width="256" height="169" src="./12-A Classic Forth Code Example_files/pile4.jpg" alt="b = h / tan(theta)" class="wp-image-524"></figure>
                           <p>
                              Když toto dosadíme do výrazu pro <em>V</em> a výsledek vynásobíme hustotou <em>D</em> v librách na krychlovou stopu, dostaneme vzorec uvedený v textu.
                           </p>
                           <p>Naplánujme naši aplikaci tak, abychom mohli nejprve zadat název materiálu, například</p>
                           <pre class="wp-block-preformatted">PÍSEK SUCHÝ

</pre>
                           <p>poté zadáme výšku hromady a získáme výsledek pro suchý písek.</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="135" height="87" src="./12-A Classic Forth Code Example_files/ch12-CEMENT-structure.webp" alt="Forth - příklady aplikací" class="wp-image-525"></figure>
                           </div>
                           <p>Předpokládejme, že pro jeden typ materiálu se hustota a úhel sklonění nikdy nemění. Obě tyto hodnoty můžeme pro každý typ materiálu uložit do tabulky. Protože nakonec potřebujeme spíše tangens každého úhlu než počet stupňů, uložíme tangens. Například úhel opadu pro hromadu cementu je 35˚, pro kterou je tangens 0,700. Tento údaj uložíme jako celé číslo 700.</p>
                           <p>Mějte na paměti, že naším cílem není jen získat odpověď; programujeme počítač nebo zařízení tak, aby pro nás získalo odpověď co nejrychlejším, nejefektivnějším a nejpřesnějším způsobem. Jak jsme naznačili v kapitole 5, psát rovnice pomocí aritmetiky s pevnou řádovou čárkou vyžaduje dodatečné přemýšlení. Ale na hardwaru, který by musel emulovat pohyblivou řádovou čárku, se toto úsilí vyplatí dvěma způsoby:</p>
                           <div class="wp-block-image">
                              <figure class="alignright"><img loading="lazy" width="200" height="179" src="./12-A Classic Forth Code Example_files/ch12-materials-calculator.webp" alt="kalkulačka hmotnosti materiálů" class="wp-image-526"></figure>
                           </div>
                           <ol>
                              <li>Výrazně se zlepšila rychlost běhu, což může být velmi důležité, pokud se na jednom výpočtu podílejí miliony kroků nebo pokud musíme provádět tisíce výpočtů každou minutu. Také,</li>
                              <li>velikost programu, která by byla rozhodující, kdybychom například chtěli tuto aplikaci umístit do kapesního zařízení určeného speciálně jako kalkulačka pro měření hromad. V tomto typu přístrojů se často používá jazyk Forth.</li>
                           </ol>
                           <p>Přistupme k našemu problému tak, že nejprve zvážíme měřítko. Výška našich pilot se pohybuje od 5 do 50 stop. Vypracováním naší rovnice pro hromadu cementu vysokou 50 stop zjistíme, že její hmotnost bude téměř 3 500 000 liber.</p>
                           <p>Protože však naše hromady nebudou mít tvar dokonalého kužele a protože naše hodnoty jsou průměrné, nemůžeme očekávat lepší přesnost než čtyři nebo pět desetinných míst. Pokud náš výsledek přepočítáme na tuny, dostaneme přibližně 17 500 tun. Tato hodnota se pohodlně vejde do rozsahu jednočíslí, a to i na 16bitovém hardwaru. Z tohoto důvodu napíšeme tuto aplikaci výhradně s aritmetickými operátory jedné délky. (Přestože v dalším textu budeme předpokládat 16bitový hardware, kód tak, jak je ukázán, poběží bez úprav na jakémkoli standardním systému Forth)</p>.
                           <p>Aplikace, které vyžadují větší přesnost, lze napsat pomocí aritmetiky dvojnásobné délky; pro ilustraci jsme dokonce napsali druhou verzi <em>této</em> aplikace pomocí matematiky dvojnásobné délky, jak uvidíte později. Naším záměrem je však ukázat, jaké přesnosti může jazyk Forth dosáhnout i při použití 16bitové matematiky.</p>
                           <p>Provedením dalšího testu s hromadou vysokou 40 stop jsme zjistili, že rozdíl jedné desetiny stopy ve výšce může znamenat rozdíl 25 tun v hmotnosti. Proto se rozhodneme škálovat naše vstupní údaje na stopy a palce, nikoli pouze na celé stopy.</p>
                           <p>Chtěli bychom, aby uživatel mohl zadat</p>
                           <pre class="wp-block-preformatted">15 FOOT 2 INCH PILE (15 stop a 2 palce)

</pre>
                           <p>kde slova FOOT a INCH převedou stopy a palce na desetiny palce a PILE provede výpočet. Takto bychom mohli definovat FOOT a INCH:</p>
                           <pre class="wp-block-preformatted">: FOOT 10 * ; <br>: INCH 100 12 */ 5 + 10 / + ; </pre>
                           <p>Použití INCH je nepovinné.</p>
                           <p>(Mimochodem, stejně snadno bychom mohli navrhnout zadávání v desetinách palce s desetinnou čárkou, například takto:</p>
                           <pre class="wp-block-preformatted">15.2

</pre>
                           <p>V tomto případě by číslo NUMBER převedlo vstup jako hodnotu o dvojnásobné délce. Protože provádíme pouze aritmetiku o jedné délce, mohl by PILE jednoduše začínat příkazem DROP, aby se eliminovala buňka vysokého řádu)</p>.
                           <p>Při zápisu definice PILE se musíme snažit zachovat maximální počet míst přesnosti, aniž bychom přetékali 15 bitů. Podle vzorce musíme nejprve provést kostkování argumentu. Uvědomme si však, že budeme mít argument, který může mít až 50 stop, což bude 500 jako škálované celé číslo. I na <em>čtverec</em> 500 vznikne 250 000, což překračuje kapacitu aritmetiky jedné délky při použití 16bitových buněk.</p>
                           <p>Můžeme uvažovat tak, že dříve nebo později v tomto výpočtu budeme muset vydělit 2000, abychom dostali odpověď v tunách. Proto se objevuje věta</p>
                           <pre class="wp-block-preformatted">DUP DUP 2000 */

</pre>
                           <p>odmocní argument a zároveň jej převede na tuny, přičemž využije dvojnásobné délky mezivýsledku */. Použijeme-li jako testovací argument 500, výše uvedená věta poskytne výsledek 125.</p>
                           <p>Naše hromada však může být i menší než 5 stop, což po vyčtverečkování znamená pouze 25. Dělení číslem 2000 by v celočíselné aritmetice vedlo k nule, což naznačuje, že příliš zmenšujeme.</p>
                           <p>Chceme-li zachovat maximální přesnost, neměli bychom zmenšovat více, než je nutné. Dělením deseti lze bezpečně pojmout 250 000. Definici PILE tedy začneme větou</p>
                           <pre class="wp-block-preformatted">DUP DUP 10 */

</pre>
                           <p>Celočíselný výsledek bude v této fázi škálován na jedno místo vpravo od desetinné čárky (25000 pro 2500,0).</p>
                           <p>Nyní musíme argument <em>zmenšit na kostku</em>. Přímé násobení opět povede k dvojnásobně dlouhému 32bitovému výsledku, takže musíme použít */ pro zmenšení měřítka. Zjistíme, že když použijeme jako dělitele číslo 1000, můžeme zůstat právě v rozsahu jedné délky. Náš výsledek bude v této fázi škálován na jedno místo <em>vlevo</em> od desetinné čárky (12500 pro 125000.) a stále bude přesný na 5 číslic.</p>
                           <p>Podle našeho vzorce musíme náš argument vynásobit číslem pí. Víme, že to můžeme ve Forthu provést pomocí věty</p>
                           <pre class="wp-block-preformatted">355 113 */

</pre>
                           <p>což nezpůsobuje žádné problémy se škálováním.</p>
                           <p>Dále musíme náš argument vydělit čtvercem tečny, což můžeme provést tak, že argument vydělíme tečnou <em>dvakrát</em>. Protože náš tangens je škálován na tři desetinná místa, vydělíme tangensem tak, že vynásobíme 1000 a vydělíme tabulkovou hodnotou. Budeme tedy používat větu</p>
                           <pre class="wp-block-preformatted">1000 TAN(THETA) */

</pre>
                           <p>Protože tuto operaci musíme provést dvakrát, vytvoříme z ní definici nazvanou /TAN (pro <em>dělení podle tangenty</em>) a slovo /TAN použijeme dvakrát v naší definici PILE. Náš výsledek bude v tomto okamžiku škálován na jedno místo vlevo od desetinné čárky (26711 pro 267110, použijeme-li naše maximální testovací hodnoty).</p>
                           <p> Zbývá jen vynásobit hustotu materiálu, z nichž nejvyšší je 131 liber na krychlovou stopu. Abychom se vyhnuli přetékání, zkusíme zmenšovat o dvě desetinná místa pomocí věty</p>
                           <pre class="wp-block-preformatted">Hustota 100 */

</pre>
                           <p>Ale testováním zjistíme, že výsledek v tomto bodě pro padesátimetrovou hromadu cementu bude 34 991, což právě překračuje 15bitový limit. Nyní je vhodná chvíle vzít v úvahu hodnotu 2000. Místo</p>
                           <pre class="wp-block-preformatted">Hustota 100 */

</pre>
                           <p>můžeme říci</p>
                           <pre class="wp-block-preformatted">DENSITY 200 */

</pre>
                           <p>a naše odpověď se nyní bude měnit na celé tuny.</p>
                           <div class="wp-block-genesis-blocks-gb-accordion gb-block-accordion gb-font-size-18">
                              <details>
                                 <summary class="gb-accordion-title">Zdroj programu</summary>
                                 <div class="gb-accordion-text">
                                    <pre class="wp-block-preformatted">\"Bez vážení" ze Starting Forth, kapitola 12<br>Proměnná DENSITY<br>Proměnná THETA<br>Proměnná ID<br><br>: " ( -- addr ) [CHAR] " WORD DUP C@ 1+ ALLOT ;<br><br>: MATERIÁL ( addr n1 n2 -- ) \ addr=řetězec, n1=hustota, n2=theta<br> CREATE , , , , <br> DOES&gt; ( -- ) DUP @ THETA !<br> CELL+ DUP @ DENSITY !  CELL+ @ ID ! ;<br><br>: .SUBSTANCE ( -- ) ID @ COUNT TYPE ;<br>: FOOT ( n1 -- n2 ) 10 * ;<br>: INCH ( n1 -- n2 ) 100 12 */ 5 + 10 / + ;<br>: /TAN ( n1 -- n2 ) 1000 THETA @ */ ;<br><br>: PILE ( n -- ) \ n=scaled height<br> DUP DUP 10 */ 1000 */ 355 339 */ /TAN /TAN<br> DENSITY @ 200 */ ." = " . ." tun " . SUBSTANCE ;<br><br>\ tabulka materiálů<br>\ řetězec-adresa hustota tan[theta] <br> " cement" 131 700 MATERIÁL CEMENT<br> " volný štěrk" 93 649 MATERIÁL VOLNÝ ŠTĚK<br> " balený štěrk" 100 700 MATERIÁL BALENÝ ŠTĚK<br> " suchý písek" 90 754 MATERIÁL SUCHÝ PÍSEK<br> " mokrý písek" 118 900 MATERIÁL MOKRÝ PÍSEK<br> " jíl" 120 727 MATERIÁL JÍL</pre>
                                 </div>
                              </details>
                           </div>
                           <p>Tady je příklad výstupu naší aplikace:</p>
                           <pre class="wp-block-preformatted">CEMENT↵<span class="output"> ok </span>
10 FOOT PILE↵<span class="output"> = 138 tun cementu ok </span>
10 FOOT 3 INCH PILE↵<span class="output"> = 151 tun cementu ok </span>
SUCHÝ PÍSEK↵<span class="output"> ok </span>
10 FOT PILE↵<span class="output"> = 81 tun suchého písku ok </span>
</pre>
                           <h3><span id="A_note_on_8220">Poznámka k "</span></h3>".
                           <p>Definice MATERIÁL přijímá pro každý materiál tři argumenty, z nichž jeden je adresa řetězce. .SUBSTANCE používá tuto adresu k zadání názvu materiálu.</p>
                           <p>Abychom mohli řetězec zařadit do slovníku a dát MATERIÁLU adresu, definovali jsme slovo ". Jak je vidět z jeho definice, " sestaví řetězec (ohraničený druhou uvozovkou) do slovníku s počtem v prvním bajtu a jeho adresu ponechá na zásobníku pro MATERIÁL. Abychom počet a řetězec zkompilovali do slovníku, musíme jednoduše spustit WORD, protože vyrovnávací paměť WORD je ZDE. Adresu řetězce získáme jako fillip, protože WORD také zanechá ZDE.</p>
                           <p>Jediné, co zbývá, je PŘIDĚLIT příslušný počet bajtů. Tento počet získáme načtením počtu z prvního bajtu řetězce a přičtením jedničky za počet bajtů.</p>
                           <h3><span id="Chapter_Summary">Shrnutí kapitoly</span></h3>
                           <h3><span id="Review_of_Terms">Přehled pojmů</span></h5>
                           <dl>
                              <dt>Záložka</dt>
                              <dd>ve Forthu dočasná definice vytvořená pouze za účelem testování definice vyšší úrovně.</dd>
                              <dt>Programování shora dolů</dt>
                              <dd>metodika programování, při níž je rozsáhlá aplikace rozdělena na menší celky, které lze podle potřeby dále dělit. Proces návrhu začíná přehledem neboli "shora" a postupuje dolů až k nejnižší úrovni detailů. Kódování jednotek nižší úrovně začíná až poté, co je navržena celá struktura aplikace.</dd>.
                           </dl>
                        </div>
                     </div>
                  </article>
               </main>
            </div>
         </div>
      </div>
   </body>
</html>